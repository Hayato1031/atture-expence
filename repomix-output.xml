This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
assets/
  README.md
public/
  index.html
  manifest.json
release/
  mac-arm64/
    AttureExpence.app/
      Contents/
        Frameworks/
          AttureExpence Helper (GPU).app/
            Contents/
              Info.plist
              PkgInfo
          AttureExpence Helper (Plugin).app/
            Contents/
              Info.plist
              PkgInfo
          AttureExpence Helper (Renderer).app/
            Contents/
              Info.plist
              PkgInfo
          AttureExpence Helper.app/
            Contents/
              Info.plist
              PkgInfo
          Electron Framework.framework/
            Versions/
              A/
                Libraries/
                  vk_swiftshader_icd.json
                Resources/
                  Info.plist
          Mantle.framework/
            Versions/
              A/
                Resources/
                  Info.plist
          ReactiveObjC.framework/
            Versions/
              A/
                Resources/
                  Info.plist
          Squirrel.framework/
            Versions/
              A/
                Resources/
                  Info.plist
        Info.plist
        PkgInfo
  builder-debug.yml
  builder-effective-config.yaml
src/
  components/
    Analytics/
      ExpenseChart.js
      FilterPanel.js
      FinancialSummary.js
      IncomeChart.js
      UserRanking.js
    common/
      FilePreviewDialog.js
      GlassCard.js
    Layout/
      Layout.js
    Navigation/
      Sidebar.js
    Registration/
      CategorySuggestion.js
      ExpenseForm.js
      FileUpload.js
      IncomeForm.js
      OCRButton.js
    Settings/
      ApiSettings.js
      CategorySettings.js
      DataManagement.js
      GeneralSettings.js
      ThemeSettings.js
    UserManagement/
      UserCard.js
      UserDialog.js
      UserForm.js
      UserList.js
  db/
    services/
      categoryService.js
      expenseService.js
      incomeService.js
      settingsService.js
      userService.js
    database.js
  hooks/
    useAnalytics.js
    usePageTransition.js
    useSettings.js
    useUsers.js
  pages/
    Analytics.js
    Dashboard.js
    FileTest.js
    Invoices.js
    Notifications.js
    Registration.js
    Settings.js
    TransactionList.js
    TrashManagement.js
    Users.js
  services/
    aiService.js
    categoryService.js
    expenseService.js
    fileService.js
    incomeService.js
    invoiceService.js
    notificationService.js
    ocrServiceNew.js
    settingsService.js
    storage.js
    trashService.js
    userService.js
  styles/
    animations.css
  theme/
    theme.js
  utils/
    formatters.js
    imagePreprocessing.js
  App.js
  index.css
  index.js
.gitignore
ICON_SETUP.md
main.js
NAVIGATION_README.md
package.json
preload.js
README.md
task.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(mkdir:*)",
      "Bash(npm install:*)",
      "Bash(npm start)",
      "Bash(pkill:*)",
      "Bash(true)",
      "Bash(node:*)",
      "Bash(npx electron:*)",
      "Bash(BROWSER=none npm run react-start 2 >& 1)",
      "Bash(timeout:*)",
      "Bash(PORT=3001 npm start)",
      "Bash(grep:*)",
      "Bash(npm run build:*)",
      "Bash(sed:*)",
      "Bash(rm:*)",
      "Bash(find:*)",
      "Bash(/Users/hayatonakamura/.nodebrew/node/v20.11.1/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/arm64-darwin/rg \"JPY|¥|\\$|€|£\" src/ --type js)",
      "Bash(/Users/hayatonakamura/.nodebrew/node/v20.11.1/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/arm64-darwin/rg \"toLocaleString|toLocaleDateString|toLocaleTimeString\" src/ --type js)",
      "Bash(/Users/hayatonakamura/.nodebrew/node/v20.11.1/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/arm64-darwin/rg \"useSettings|settings\\.\" src/ --type js)"
    ]
  },
  "enableAllProjectMcpServers": false
}
</file>

<file path="assets/README.md">
# Assets Folder

This folder contains application assets that should not be overwritten during builds.

## Icons
- icon.png (Linux)
- icon.ico (Windows)  
- icon.icns (macOS)

Replace these placeholder files with your actual application icons.

## Recommended Icon Sizes
- PNG: 512x512px
- ICO: Multi-size (16, 32, 48, 256px)
- ICNS: Multi-size (16, 32, 64, 128, 256, 512, 1024px)
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="AttureExpence - 経費・収入管理アプリケーション"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <title>AttureExpence</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="public/manifest.json">
{
  "short_name": "AttureExpence",
  "name": "AttureExpence - 経費・収入管理",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper (GPU).app/Contents/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict><key>CFBundleDisplayName</key><string>AttureExpence Helper (GPU)</string><key>CFBundleExecutable</key><string>AttureExpence Helper (GPU)</string><key>CFBundleIdentifier</key><string>com.attureexpence.app.helper.GPU</string><key>CFBundleName</key><string>Electron Helper (GPU)</string><key>CFBundlePackageType</key><string>APPL</string><key>CFBundleVersion</key><string>1.0.0</string><key>DTCompiler</key><string>com.apple.compilers.llvm.clang.1_0</string><key>DTSDKBuild</key><string>23A334</string><key>DTSDKName</key><string>macosx14.0</string><key>DTXcode</key><string>1501</string><key>DTXcodeBuild</key><string>15A507</string><key>LSEnvironment</key><dict><key>MallocNanoZone</key><string>0</string></dict><key>LSUIElement</key><true/><key>NSSupportsAutomaticGraphicsSwitching</key><true/></dict></plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper (GPU).app/Contents/PkgInfo">
APPL????
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper (Plugin).app/Contents/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict><key>CFBundleDisplayName</key><string>AttureExpence Helper (Plugin)</string><key>CFBundleExecutable</key><string>AttureExpence Helper (Plugin)</string><key>CFBundleIdentifier</key><string>com.attureexpence.app.helper.Plugin</string><key>CFBundleName</key><string>Electron Helper (Plugin)</string><key>CFBundlePackageType</key><string>APPL</string><key>CFBundleVersion</key><string>1.0.0</string><key>DTCompiler</key><string>com.apple.compilers.llvm.clang.1_0</string><key>DTSDKBuild</key><string>23A334</string><key>DTSDKName</key><string>macosx14.0</string><key>DTXcode</key><string>1501</string><key>DTXcodeBuild</key><string>15A507</string><key>LSEnvironment</key><dict><key>MallocNanoZone</key><string>0</string></dict><key>LSUIElement</key><true/><key>NSSupportsAutomaticGraphicsSwitching</key><true/></dict></plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper (Plugin).app/Contents/PkgInfo">
APPL????
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper (Renderer).app/Contents/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict><key>CFBundleDisplayName</key><string>AttureExpence Helper (Renderer)</string><key>CFBundleExecutable</key><string>AttureExpence Helper (Renderer)</string><key>CFBundleIdentifier</key><string>com.attureexpence.app.helper.Renderer</string><key>CFBundleName</key><string>Electron Helper (Renderer)</string><key>CFBundlePackageType</key><string>APPL</string><key>CFBundleVersion</key><string>1.0.0</string><key>DTCompiler</key><string>com.apple.compilers.llvm.clang.1_0</string><key>DTSDKBuild</key><string>23A334</string><key>DTSDKName</key><string>macosx14.0</string><key>DTXcode</key><string>1501</string><key>DTXcodeBuild</key><string>15A507</string><key>LSEnvironment</key><dict><key>MallocNanoZone</key><string>0</string></dict><key>LSUIElement</key><true/><key>NSSupportsAutomaticGraphicsSwitching</key><true/></dict></plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper (Renderer).app/Contents/PkgInfo">
APPL????
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper.app/Contents/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict><key>CFBundleDisplayName</key><string>AttureExpence Helper</string><key>CFBundleExecutable</key><string>AttureExpence Helper</string><key>CFBundleIdentifier</key><string>com.attureexpence.app.helper</string><key>CFBundleName</key><string>Electron Helper</string><key>CFBundlePackageType</key><string>APPL</string><key>CFBundleVersion</key><string>1.0.0</string><key>DTCompiler</key><string>com.apple.compilers.llvm.clang.1_0</string><key>DTSDKBuild</key><string>23A334</string><key>DTSDKName</key><string>macosx14.0</string><key>DTXcode</key><string>1501</string><key>DTXcodeBuild</key><string>15A507</string><key>LSEnvironment</key><dict><key>MallocNanoZone</key><string>0</string></dict><key>LSUIElement</key><true/><key>NSSupportsAutomaticGraphicsSwitching</key><true/></dict></plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/AttureExpence Helper.app/Contents/PkgInfo">
APPL????
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/Electron Framework.framework/Versions/A/Libraries/vk_swiftshader_icd.json">
{"file_format_version": "1.0.0", "ICD": {"library_path": "./libvk_swiftshader.dylib", "api_version": "1.0.5"}}
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/Electron Framework.framework/Versions/A/Resources/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleExecutable</key>
	<string>Electron Framework</string>
	<key>CFBundleIdentifier</key>
	<string>com.github.Electron.framework</string>
	<key>CFBundleName</key>
	<string>Electron Framework</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleVersion</key>
	<string>28.3.3</string>
	<key>DTCompiler</key>
	<string>com.apple.compilers.llvm.clang.1_0</string>
	<key>DTSDKBuild</key>
	<string>23A334</string>
	<key>DTSDKName</key>
	<string>macosx14.0</string>
	<key>DTXcode</key>
	<string>1501</string>
	<key>DTXcodeBuild</key>
	<string>15A507</string>
	<key>LSEnvironment</key>
	<dict>
		<key>MallocNanoZone</key>
		<string>0</string>
	</dict>
	<key>NSSupportsAutomaticGraphicsSwitching</key>
	<true/>
</dict>
</plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/Mantle.framework/Versions/A/Resources/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>Mantle</string>
	<key>CFBundleIdentifier</key>
	<string>org.mantle.Mantle</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>Mantle</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>0.0.0</string>
	<key>DTCompiler</key>
	<string>com.apple.compilers.llvm.clang.1_0</string>
	<key>DTSDKBuild</key>
	<string>23A334</string>
	<key>DTSDKName</key>
	<string>macosx14.0</string>
	<key>DTXcode</key>
	<string>1501</string>
	<key>DTXcodeBuild</key>
	<string>15A507</string>
	<key>NSPrincipalClass</key>
	<string></string>
</dict>
</plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/ReactiveObjC.framework/Versions/A/Resources/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>ReactiveObjC</string>
	<key>CFBundleIdentifier</key>
	<string>com.electron.reactive</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>ReactiveObjC</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>3.1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>0.0.0</string>
	<key>DTCompiler</key>
	<string>com.apple.compilers.llvm.clang.1_0</string>
	<key>DTSDKBuild</key>
	<string>23A334</string>
	<key>DTSDKName</key>
	<string>macosx14.0</string>
	<key>DTXcode</key>
	<string>1501</string>
	<key>DTXcodeBuild</key>
	<string>15A507</string>
	<key>NSHumanReadableCopyright</key>
	<string>Copyright © 2014 GitHub. All rights reserved.</string>
	<key>NSPrincipalClass</key>
	<string></string>
</dict>
</plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Frameworks/Squirrel.framework/Versions/A/Resources/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>Squirrel</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>com.github.Squirrel</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>Squirrel</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>DTCompiler</key>
	<string>com.apple.compilers.llvm.clang.1_0</string>
	<key>DTSDKBuild</key>
	<string>23A334</string>
	<key>DTSDKName</key>
	<string>macosx14.0</string>
	<key>DTXcode</key>
	<string>1501</string>
	<key>DTXcodeBuild</key>
	<string>15A507</string>
	<key>NSHumanReadableCopyright</key>
	<string>Copyright © 2013 GitHub. All rights reserved.</string>
	<key>NSPrincipalClass</key>
	<string></string>
</dict>
</plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict><key>CFBundleDisplayName</key><string>AttureExpence</string><key>CFBundleExecutable</key><string>AttureExpence</string><key>CFBundleIconFile</key><string>icon.icns</string><key>CFBundleIdentifier</key><string>com.attureexpence.app</string><key>CFBundleInfoDictionaryVersion</key><string>6.0</string><key>CFBundleName</key><string>AttureExpence</string><key>CFBundlePackageType</key><string>APPL</string><key>CFBundleShortVersionString</key><string>1.0.0</string><key>CFBundleVersion</key><string>1.0.0</string><key>DTCompiler</key><string>com.apple.compilers.llvm.clang.1_0</string><key>DTSDKBuild</key><string>23A334</string><key>DTSDKName</key><string>macosx14.0</string><key>DTXcode</key><string>1501</string><key>DTXcodeBuild</key><string>15A507</string><key>ElectronAsarIntegrity</key><dict><key>Resources/app.asar</key><dict><key>algorithm</key><string>SHA256</string><key>hash</key><string>34776031cb946bcaebb288e4ce2b3530bd1be3ebde3232e4ecad10928166e28c</string></dict></dict><key>LSApplicationCategoryType</key><string>public.app-category.finance</string><key>LSEnvironment</key><dict><key>MallocNanoZone</key><string>0</string></dict><key>LSMinimumSystemVersion</key><string>10.15</string><key>NSAppTransportSecurity</key><dict><key>NSAllowsArbitraryLoads</key><true/><key>NSAllowsLocalNetworking</key><true/><key>NSExceptionDomains</key><dict><key>127.0.0.1</key><dict><key>NSIncludesSubdomains</key><false/><key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key><true/><key>NSTemporaryExceptionAllowsInsecureHTTPSLoads</key><false/><key>NSTemporaryExceptionMinimumTLSVersion</key><string>1.0</string><key>NSTemporaryExceptionRequiresForwardSecrecy</key><false/></dict><key>localhost</key><dict><key>NSIncludesSubdomains</key><false/><key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key><true/><key>NSTemporaryExceptionAllowsInsecureHTTPSLoads</key><false/><key>NSTemporaryExceptionMinimumTLSVersion</key><string>1.0</string><key>NSTemporaryExceptionRequiresForwardSecrecy</key><false/></dict></dict></dict><key>NSBluetoothAlwaysUsageDescription</key><string>This app needs access to Bluetooth</string><key>NSBluetoothPeripheralUsageDescription</key><string>This app needs access to Bluetooth</string><key>NSCameraUsageDescription</key><string>This app needs access to the camera</string><key>NSHighResolutionCapable</key><true/><key>NSHumanReadableCopyright</key><string>Copyright © 2025 AttureExpence</string><key>NSMainNibFile</key><string>MainMenu</string><key>NSMicrophoneUsageDescription</key><string>This app needs access to the microphone</string><key>NSPrincipalClass</key><string>AtomApplication</string><key>NSQuitAlwaysKeepsWindows</key><false/><key>NSRequiresAquaSystemAppearance</key><false/><key>NSSupportsAutomaticGraphicsSwitching</key><true/></dict></plist>
</file>

<file path="release/mac-arm64/AttureExpence.app/Contents/PkgInfo">
APPL????
</file>

<file path="release/builder-debug.yml">
arm64:
  firstOrDefaultFilePatterns:
    - '!**/node_modules'
    - '!build{,/**/*}'
    - '!release{,/**/*}'
    - build/**/*
    - main.js
    - preload.js
    - node_modules/**/*
    - '!node_modules/*/{test,__tests__,tests,powered-test,example,examples}'
    - '!node_modules/.bin'
    - '!**/*.{iml,o,hprof,orig,pyc,pyo,rbc,swp,csproj,sln,xproj}'
    - '!.editorconfig'
    - '!**/._*'
    - '!**/{.DS_Store,.git,.hg,.svn,CVS,RCS,SCCS,.gitignore,.gitattributes}'
    - '!**/{__pycache__,thumbs.db,.flowconfig,.idea,.vs,.nyc_output}'
    - '!**/{appveyor.yml,.travis.yml,circle.yml}'
    - '!**/{npm-debug.log,yarn.lock,.yarn-integrity,.yarn-metadata.json}'
    - package.json
    - '!**/*.{iml,hprof,orig,pyc,pyo,rbc,swp,csproj,sln,suo,xproj,cc,d.ts,mk,a,o,forge-meta,pdb}'
    - '!**/._*'
    - '!**/electron-builder.{yaml,yml,json,json5,toml,ts}'
    - '!**/{.git,.hg,.svn,CVS,RCS,SCCS,__pycache__,.DS_Store,thumbs.db,.gitignore,.gitkeep,.gitattributes,.npmignore,.idea,.vs,.flowconfig,.jshintrc,.eslintrc,.circleci,.yarn-integrity,.yarn-metadata.json,yarn-error.log,yarn.lock,package-lock.json,npm-debug.log,appveyor.yml,.travis.yml,circle.yml,.nyc_output,.husky,.github,electron-builder.env}'
    - '!.yarn{,/**/*}'
    - '!.editorconfig'
    - '!.yarnrc.yml'
  nodeModuleFilePatterns:
    - '**/*'
    - build/**/*
    - main.js
    - preload.js
    - node_modules/**/*
    - '!node_modules/*/{test,__tests__,tests,powered-test,example,examples}'
    - '!node_modules/.bin'
    - '!**/*.{iml,o,hprof,orig,pyc,pyo,rbc,swp,csproj,sln,xproj}'
    - '!.editorconfig'
    - '!**/._*'
    - '!**/{.DS_Store,.git,.hg,.svn,CVS,RCS,SCCS,.gitignore,.gitattributes}'
    - '!**/{__pycache__,thumbs.db,.flowconfig,.idea,.vs,.nyc_output}'
    - '!**/{appveyor.yml,.travis.yml,circle.yml}'
    - '!**/{npm-debug.log,yarn.lock,.yarn-integrity,.yarn-metadata.json}'
</file>

<file path="release/builder-effective-config.yaml">
directories:
  output: release
  buildResources: build
appId: com.attureexpence.app
productName: AttureExpence
files:
  - filter:
      - build/**/*
      - main.js
      - preload.js
      - node_modules/**/*
      - '!node_modules/*/{test,__tests__,tests,powered-test,example,examples}'
      - '!node_modules/.bin'
      - '!**/*.{iml,o,hprof,orig,pyc,pyo,rbc,swp,csproj,sln,xproj}'
      - '!.editorconfig'
      - '!**/._*'
      - '!**/{.DS_Store,.git,.hg,.svn,CVS,RCS,SCCS,.gitignore,.gitattributes}'
      - '!**/{__pycache__,thumbs.db,.flowconfig,.idea,.vs,.nyc_output}'
      - '!**/{appveyor.yml,.travis.yml,circle.yml}'
      - '!**/{npm-debug.log,yarn.lock,.yarn-integrity,.yarn-metadata.json}'
extends: null
mac:
  category: public.app-category.finance
  icon: assets/icon.icns
win:
  target: nsis
  icon: assets/icon.ico
linux:
  target: AppImage
  icon: assets/icon.png
  category: Office
electronVersion: 28.3.3
</file>

<file path="src/components/Analytics/ExpenseChart.js">
import React, { useState } from 'react';
import {
  Box,
  Typography,
  ToggleButton,
  ToggleButtonGroup,
  Stack,
  Chip,
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import {
  PieChart as PieChartIcon,
  BarChart as BarChartIcon,
  ShowChart as LineChartIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import { Doughnut, Bar, Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  ArcElement,
} from 'chart.js';
import GlassCard, { GlassCardContent } from '../common/GlassCard';
import { formatCurrency, formatPercentage } from '../../utils/formatters';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  ArcElement
);

const ExpenseChart = ({ data, period = 'monthly' }) => {
  const theme = useTheme();
  const [chartType, setChartType] = useState('doughnut');

  const {
    categoryData = {
      labels: ['家賃', '交通費', '消耗品費', '接待費', '通信費', 'その他'],
      amounts: [120000, 45000, 32000, 28000, 22000, 25000],
      trends: [0, 12, -5, 25, 8, -3]
    },
    monthlyTrends = {
      labels: ['1月', '2月', '3月', '4月', '5月', '6月'],
      data: [850000, 780000, 920000, 800000, 850000, 890000]
    },
    comparisonData = {
      labels: ['1月', '2月', '3月', '4月', '5月', '6月'],
      currentYear: [850000, 780000, 920000, 800000, 850000, 890000],
      previousYear: [800000, 750000, 880000, 780000, 820000, 850000]
    }
  } = data || {};

  const colors = [
    'rgba(102, 126, 234, 0.8)',
    'rgba(250, 112, 154, 0.8)',
    'rgba(79, 172, 254, 0.8)',
    'rgba(168, 237, 234, 0.8)',
    'rgba(255, 236, 210, 0.8)',
    'rgba(240, 147, 251, 0.8)',
  ];

  const borderColors = [
    'rgba(102, 126, 234, 1)',
    'rgba(250, 112, 154, 1)',
    'rgba(79, 172, 254, 1)',
    'rgba(168, 237, 234, 1)',
    'rgba(255, 236, 210, 1)',
    'rgba(240, 147, 251, 1)',
  ];

  const doughnutData = {
    labels: categoryData.labels,
    datasets: [{
      data: categoryData.amounts,
      backgroundColor: colors,
      borderColor: borderColors,
      borderWidth: 2,
      hoverOffset: 15,
    }],
  };

  const barData = {
    labels: monthlyTrends.labels,
    datasets: [{
      label: `${period === 'quarterly' ? '四半期' : '月間'}支出`,
      data: monthlyTrends.data,
      backgroundColor: colors[0],
      borderColor: borderColors[0],
      borderWidth: 2,
      borderRadius: 8,
      borderSkipped: false,
    }],
  };

  const lineData = {
    labels: comparisonData.labels,
    datasets: [
      {
        label: '今年',
        data: comparisonData.currentYear,
        borderColor: borderColors[0],
        backgroundColor: colors[0],
        fill: true,
        tension: 0.4,
        pointRadius: 6,
        pointHoverRadius: 8,
        pointBackgroundColor: borderColors[0],
        pointBorderColor: '#fff',
        pointBorderWidth: 2,
      },
      {
        label: '前年',
        data: comparisonData.previousYear,
        borderColor: borderColors[1],
        backgroundColor: colors[1],
        fill: true,
        tension: 0.4,
        pointRadius: 6,
        pointHoverRadius: 8,
        pointBackgroundColor: borderColors[1],
        pointBorderColor: '#fff',
        pointBorderWidth: 2,
      },
    ],
  };

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top',
        labels: {
          color: theme.palette.text.primary,
          padding: 20,
          usePointStyle: true,
          pointStyle: 'circle',
        },
      },
      tooltip: {
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        titleColor: theme.palette.text.primary,
        bodyColor: theme.palette.text.primary,
        borderColor: theme.palette.divider,
        borderWidth: 1,
        cornerRadius: 12,
        displayColors: true,
        callbacks: {
          label: function(context) {
            const value = context.parsed.y || context.parsed;
            return `${context.dataset.label || context.label}: ${formatCurrency(value, true)}`;
          },
        },
      },
    },
    scales: chartType !== 'doughnut' ? {
      y: {
        beginAtZero: true,
        grid: {
          color: theme.palette.divider,
        },
        ticks: {
          color: theme.palette.text.secondary,
          callback: function(value) {
            return formatCurrency(value, true);
          },
        },
      },
      x: {
        grid: {
          color: theme.palette.divider,
        },
        ticks: {
          color: theme.palette.text.secondary,
        },
      },
    } : {},
    interaction: {
      intersect: false,
      mode: 'index',
    },
    animation: {
      duration: 1500,
      easing: 'easeInOutQuart',
    },
  };

  const doughnutOptions = {
    ...chartOptions,
    plugins: {
      ...chartOptions.plugins,
      legend: {
        position: 'right',
        labels: {
          color: theme.palette.text.primary,
          padding: 20,
          usePointStyle: true,
          pointStyle: 'circle',
          generateLabels: function(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              return data.labels.map((label, index) => {
                const value = data.datasets[0].data[index];
                const total = data.datasets[0].data.reduce((sum, val) => sum + val, 0);
                const percentage = ((value / total) * 100).toFixed(1);
                return {
                  text: `${label}: ¥${value.toLocaleString()} (${percentage}%)`,
                  fillStyle: data.datasets[0].backgroundColor[index],
                  strokeStyle: data.datasets[0].borderColor[index],
                  lineWidth: 2,
                  index: index,
                };
              });
            }
            return [];
          },
        },
      },
    },
    cutout: '60%',
  };

  const chartVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: {
      opacity: 1,
      scale: 1,
      transition: {
        duration: 0.8,
        ease: [0.4, 0, 0.2, 1],
      },
    },
    exit: {
      opacity: 0,
      scale: 0.9,
      transition: {
        duration: 0.3,
      },
    },
  };

  const renderChart = () => {
    switch (chartType) {
      case 'doughnut':
        return <Doughnut data={doughnutData} options={doughnutOptions} />;
      case 'bar':
        return <Bar data={barData} options={chartOptions} />;
      case 'line':
        return <Line data={lineData} options={chartOptions} />;
      default:
        return <Doughnut data={doughnutData} options={doughnutOptions} />;
    }
  };

  const getTotalExpense = () => {
    if (!categoryData.amounts || categoryData.amounts.length === 0) return 0;
    return categoryData.amounts.reduce((sum, amount) => sum + (amount || 0), 0);
  };

  const getTopCategory = () => {
    if (!categoryData.amounts || categoryData.amounts.length === 0) {
      return { name: 'データなし', amount: 0, trend: 0 };
    }
    const maxIndex = categoryData.amounts.indexOf(Math.max(...categoryData.amounts));
    return {
      name: categoryData.labels[maxIndex] || 'データなし',
      amount: categoryData.amounts[maxIndex] || 0,
      trend: categoryData.trends[maxIndex] || 0
    };
  };

  const topCategory = getTopCategory();

  return (
    <GlassCard>
      <GlassCardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h5" fontWeight="bold">
            支出分析
          </Typography>
          <ToggleButtonGroup
            value={chartType}
            exclusive
            onChange={(e, newChartType) => newChartType && setChartType(newChartType)}
            size="small"
            sx={{
              '& .MuiToggleButton-root': {
                color: 'rgba(255, 255, 255, 0.7)',
                borderColor: 'rgba(255, 255, 255, 0.2)',
                '&.Mui-selected': {
                  bgcolor: 'rgba(255, 255, 255, 0.1)',
                  color: 'white',
                },
              },
            }}
          >
            <ToggleButton value="doughnut">
              <PieChartIcon />
            </ToggleButton>
            <ToggleButton value="bar">
              <BarChartIcon />
            </ToggleButton>
            <ToggleButton value="line">
              <LineChartIcon />
            </ToggleButton>
          </ToggleButtonGroup>
        </Box>

        {/* Summary Stats */}
        <Stack direction="row" spacing={2} sx={{ mb: 3 }}>
          <Chip
            label={`総支出: ${formatCurrency(getTotalExpense(), true)}`}
            variant="outlined"
            sx={{
              color: 'white',
              borderColor: 'rgba(255, 255, 255, 0.3)',
              backgroundColor: 'rgba(250, 112, 154, 0.2)',
            }}
          />
          <Chip
            label={`最大: ${topCategory.name} ${formatCurrency(topCategory.amount, true)}`}
            variant="outlined"
            sx={{
              color: 'white',
              borderColor: 'rgba(255, 255, 255, 0.3)',
              backgroundColor: 'rgba(102, 126, 234, 0.2)',
            }}
          />
          <Chip
            icon={topCategory.trend > 0 ? <TrendingUpIcon /> : <TrendingDownIcon />}
            label={`${topCategory.trend > 0 ? '+' : ''}${formatPercentage(topCategory.trend)}`}
            variant="outlined"
            sx={{
              color: 'white',
              borderColor: 'rgba(255, 255, 255, 0.3)',
              backgroundColor: topCategory.trend > 0 
                ? 'rgba(76, 175, 80, 0.2)' 
                : 'rgba(244, 67, 54, 0.2)',
            }}
          />
        </Stack>

        <Box sx={{ height: chartType === 'doughnut' ? 400 : 350 }}>
          <AnimatePresence mode="wait">
            <motion.div
              key={chartType}
              variants={chartVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
              style={{ height: '100%' }}
            >
              {renderChart()}
            </motion.div>
          </AnimatePresence>
        </Box>

        {/* Category Breakdown for Doughnut Chart */}
        {chartType === 'doughnut' && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="h6" gutterBottom fontWeight="bold">
              カテゴリ別詳細
            </Typography>
            <Stack spacing={1}>
              {categoryData.labels && categoryData.labels.length > 0 ? categoryData.labels.map((label, index) => {
                const amount = categoryData.amounts[index] || 0;
                const trend = categoryData.trends[index] || 0;
                const totalExpense = getTotalExpense();
                const percentage = totalExpense > 0 ? ((amount / totalExpense) * 100).toFixed(1) : '0.0';
                return (
                  <Box
                    key={label}
                    sx={{
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      p: 2,
                      borderRadius: 1,
                      bgcolor: 'rgba(255, 255, 255, 0.05)',
                      border: '1px solid rgba(255, 255, 255, 0.1)',
                    }}
                  >
                    <Stack direction="row" alignItems="center" spacing={2}>
                      <Box
                        sx={{
                          width: 16,
                          height: 16,
                          borderRadius: '50%',
                          bgcolor: colors[index],
                          border: `2px solid ${borderColors[index]}`,
                        }}
                      />
                      <Typography variant="body1" fontWeight="medium">
                        {label}
                      </Typography>
                    </Stack>
                    <Stack direction="row" alignItems="center" spacing={2}>
                      <Typography variant="body1" fontWeight="bold">
                        {formatCurrency(amount, true)}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        ({percentage}%)
                      </Typography>
                      <Chip
                        size="small"
                        label={`${trend > 0 ? '+' : ''}${formatPercentage(trend)}`}
                        color={trend > 0 ? 'error' : 'success'}
                        variant="outlined"
                      />
                    </Stack>
                  </Box>
                );
              }) : (
                <Box sx={{ textAlign: 'center', py: 2 }}>
                  <Typography color="text.secondary">カテゴリデータがありません</Typography>
                </Box>
              )}
            </Stack>
          </Box>
        )}
      </GlassCardContent>
    </GlassCard>
  );
};

export default ExpenseChart;
</file>

<file path="src/components/Analytics/FilterPanel.js">
import React, { useState } from 'react';
import {
  Box,
  Typography,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  Stack,
  TextField,
  Autocomplete,
  Button,
  Divider,
  IconButton,
} from '@mui/material';
import {
  FilterList as FilterIcon,
  DateRange as DateRangeIcon,
  Category as CategoryIcon,
  Person as PersonIcon,
  Business as BusinessIcon,
  Clear as ClearIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Refresh as RefreshIcon,
} from '@mui/icons-material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { motion, AnimatePresence } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';

const FilterPanel = ({ filters, onFiltersChange, data }) => {
  const [expanded, setExpanded] = useState(true);
  const [localFilters, setLocalFilters] = useState({
    dateRange: {
      startDate: filters?.dateRange?.startDate || new Date(2024, 0, 1),
      endDate: filters?.dateRange?.endDate || new Date(),
    },
    period: filters?.period || 'monthly',
    categories: filters?.categories || [],
    users: filters?.users || [],
    departments: filters?.departments || [],
    amountRange: {
      min: filters?.amountRange?.min || '',
      max: filters?.amountRange?.max || '',
    },
    transactionType: filters?.transactionType || 'all',
  });

  // Sample data for filters
  const {
    categories = [
      '家賃', '交通費', '消耗品費', '接待費', '通信費', '設備費', 
      '研修費', '広告宣伝費', '水道光熱費', 'その他'
    ],
    users = [
      '田中太郎', '佐藤花子', '山田次郎', '鈴木一郎', '高橋美咲',
      '松本健一', '木村美紀', '伊藤正男', '渡辺由美', '中村孝'
    ],
    departments = [
      '営業部', 'マーケティング部', '開発部', '管理部', '人事部',
      '経理部', '総務部', '企画部'
    ]
  } = data || {};

  const periodOptions = [
    { value: 'daily', label: '日別' },
    { value: 'weekly', label: '週別' },
    { value: 'monthly', label: '月別' },
    { value: 'quarterly', label: '四半期別' },
    { value: 'yearly', label: '年別' },
  ];

  const transactionTypeOptions = [
    { value: 'all', label: 'すべて' },
    { value: 'expense', label: '支出のみ' },
    { value: 'income', label: '収入のみ' },
  ];

  const handleLocalFilterChange = (key, value) => {
    const newFilters = { ...localFilters, [key]: value };
    setLocalFilters(newFilters);
  };

  const handleApplyFilters = () => {
    onFiltersChange(localFilters);
  };

  const handleClearFilters = () => {
    const clearedFilters = {
      dateRange: {
        startDate: new Date(2024, 0, 1),
        endDate: new Date(),
      },
      period: 'monthly',
      categories: [],
      users: [],
      departments: [],
      amountRange: {
        min: '',
        max: '',
      },
      transactionType: 'all',
    };
    setLocalFilters(clearedFilters);
    onFiltersChange(clearedFilters);
  };

  const getActiveFiltersCount = () => {
    let count = 0;
    if (localFilters.categories.length > 0) count++;
    if (localFilters.users.length > 0) count++;
    if (localFilters.departments.length > 0) count++;
    if (localFilters.amountRange.min || localFilters.amountRange.max) count++;
    if (localFilters.transactionType !== 'all') count++;
    return count;
  };

  const filterVariants = {
    hidden: { opacity: 0, height: 0 },
    visible: {
      opacity: 1,
      height: 'auto',
      transition: {
        duration: 0.3,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  return (
    <GlassCard>
      <GlassCardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
          <Stack direction="row" alignItems="center" spacing={2}>
            <FilterIcon />
            <Typography variant="h6" fontWeight="bold">
              フィルター設定
            </Typography>
            {getActiveFiltersCount() > 0 && (
              <Chip
                label={`${getActiveFiltersCount()}個のフィルター`}
                size="small"
                color="primary"
                variant="outlined"
              />
            )}
          </Stack>
          <Stack direction="row" spacing={1}>
            <Button
              size="small"
              startIcon={<RefreshIcon />}
              onClick={handleApplyFilters}
              variant="contained"
              sx={{
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                color: 'white',
              }}
            >
              適用
            </Button>
            <Button
              size="small"
              startIcon={<ClearIcon />}
              onClick={handleClearFilters}
              variant="outlined"
              sx={{
                borderColor: 'rgba(255, 255, 255, 0.3)',
                color: 'rgba(255, 255, 255, 0.8)',
              }}
            >
              クリア
            </Button>
            <IconButton
              onClick={() => setExpanded(!expanded)}
              sx={{ color: 'rgba(255, 255, 255, 0.7)' }}
            >
              {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
            </IconButton>
          </Stack>
        </Box>

        <AnimatePresence>
          {expanded && (
            <motion.div
              variants={filterVariants}
              initial="hidden"
              animate="visible"
              exit="hidden"
            >
              <Grid container spacing={3}>
                {/* Date Range */}
                <Grid item xs={12} md={6}>
                  <Box sx={{ mb: 2 }}>
                    <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 2 }}>
                      <DateRangeIcon sx={{ color: 'primary.main' }} />
                      <Typography variant="subtitle1" fontWeight="bold">
                        期間設定
                      </Typography>
                    </Stack>
                    <Grid container spacing={2}>
                      <Grid item xs={12} sm={4}>
                        <FormControl fullWidth size="small">
                          <InputLabel>表示期間</InputLabel>
                          <Select
                            value={localFilters.period}
                            onChange={(e) => handleLocalFilterChange('period', e.target.value)}
                            label="表示期間"
                          >
                            {periodOptions.map(option => (
                              <MenuItem key={option.value} value={option.value}>
                                {option.label}
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>
                      <Grid item xs={12} sm={4}>
                        <DatePicker
                          label="開始日"
                          value={localFilters.dateRange.startDate}
                          onChange={(newDate) => 
                            handleLocalFilterChange('dateRange', {
                              ...localFilters.dateRange,
                              startDate: newDate
                            })
                          }
                          slotProps={{
                            textField: {
                              size: 'small',
                              fullWidth: true,
                            },
                          }}
                        />
                      </Grid>
                      <Grid item xs={12} sm={4}>
                        <DatePicker
                          label="終了日"
                          value={localFilters.dateRange.endDate}
                          onChange={(newDate) => 
                            handleLocalFilterChange('dateRange', {
                              ...localFilters.dateRange,
                              endDate: newDate
                            })
                          }
                          slotProps={{
                            textField: {
                              size: 'small',
                              fullWidth: true,
                            },
                          }}
                        />
                      </Grid>
                    </Grid>
                  </Box>
                </Grid>

                {/* Amount Range */}
                <Grid item xs={12} md={6}>
                  <Box sx={{ mb: 2 }}>
                    <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 2 }}>
                      <CategoryIcon sx={{ color: 'warning.main' }} />
                      <Typography variant="subtitle1" fontWeight="bold">
                        金額範囲
                      </Typography>
                    </Stack>
                    <Grid container spacing={2}>
                      <Grid item xs={12} sm={4}>
                        <FormControl fullWidth size="small">
                          <InputLabel>取引種別</InputLabel>
                          <Select
                            value={localFilters.transactionType}
                            onChange={(e) => handleLocalFilterChange('transactionType', e.target.value)}
                            label="取引種別"
                          >
                            {transactionTypeOptions.map(option => (
                              <MenuItem key={option.value} value={option.value}>
                                {option.label}
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>
                      <Grid item xs={12} sm={4}>
                        <TextField
                          label="最小金額"
                          type="number"
                          size="small"
                          fullWidth
                          value={localFilters.amountRange.min}
                          onChange={(e) => 
                            handleLocalFilterChange('amountRange', {
                              ...localFilters.amountRange,
                              min: e.target.value
                            })
                          }
                          InputProps={{
                            startAdornment: '¥',
                          }}
                        />
                      </Grid>
                      <Grid item xs={12} sm={4}>
                        <TextField
                          label="最大金額"
                          type="number"
                          size="small"
                          fullWidth
                          value={localFilters.amountRange.max}
                          onChange={(e) => 
                            handleLocalFilterChange('amountRange', {
                              ...localFilters.amountRange,
                              max: e.target.value
                            })
                          }
                          InputProps={{
                            startAdornment: '¥',
                          }}
                        />
                      </Grid>
                    </Grid>
                  </Box>
                </Grid>

                <Grid item xs={12}>
                  <Divider sx={{ my: 1, bgcolor: 'rgba(255, 255, 255, 0.1)' }} />
                </Grid>

                {/* Categories */}
                <Grid item xs={12} md={4}>
                  <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 2 }}>
                    <CategoryIcon sx={{ color: 'info.main' }} />
                    <Typography variant="subtitle1" fontWeight="bold">
                      カテゴリ
                    </Typography>
                  </Stack>
                  <Autocomplete
                    multiple
                    size="small"
                    options={categories}
                    value={localFilters.categories}
                    onChange={(event, newValue) => handleLocalFilterChange('categories', newValue)}
                    renderTags={(value, getTagProps) =>
                      value.map((option, index) => (
                        <Chip
                          variant="outlined"
                          label={option}
                          size="small"
                          {...getTagProps({ index })}
                          key={option}
                          sx={{
                            color: 'white',
                            borderColor: 'rgba(255, 255, 255, 0.3)',
                            backgroundColor: 'rgba(33, 150, 243, 0.2)',
                          }}
                        />
                      ))
                    }
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        variant="outlined"
                        placeholder="カテゴリを選択"
                      />
                    )}
                  />
                </Grid>

                {/* Users */}
                <Grid item xs={12} md={4}>
                  <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 2 }}>
                    <PersonIcon sx={{ color: 'success.main' }} />
                    <Typography variant="subtitle1" fontWeight="bold">
                      ユーザー
                    </Typography>
                  </Stack>
                  <Autocomplete
                    multiple
                    size="small"
                    options={users}
                    value={localFilters.users}
                    onChange={(event, newValue) => handleLocalFilterChange('users', newValue)}
                    renderTags={(value, getTagProps) =>
                      value.map((option, index) => (
                        <Chip
                          variant="outlined"
                          label={option}
                          size="small"
                          {...getTagProps({ index })}
                          key={option}
                          sx={{
                            color: 'white',
                            borderColor: 'rgba(255, 255, 255, 0.3)',
                            backgroundColor: 'rgba(76, 175, 80, 0.2)',
                          }}
                        />
                      ))
                    }
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        variant="outlined"
                        placeholder="ユーザーを選択"
                      />
                    )}
                  />
                </Grid>

                {/* Departments */}
                <Grid item xs={12} md={4}>
                  <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 2 }}>
                    <BusinessIcon sx={{ color: 'purple' }} />
                    <Typography variant="subtitle1" fontWeight="bold">
                      部門
                    </Typography>
                  </Stack>
                  <Autocomplete
                    multiple
                    size="small"
                    options={departments}
                    value={localFilters.departments}
                    onChange={(event, newValue) => handleLocalFilterChange('departments', newValue)}
                    renderTags={(value, getTagProps) =>
                      value.map((option, index) => (
                        <Chip
                          variant="outlined"
                          label={option}
                          size="small"
                          {...getTagProps({ index })}
                          key={option}
                          sx={{
                            color: 'white',
                            borderColor: 'rgba(255, 255, 255, 0.3)',
                            backgroundColor: 'rgba(156, 39, 176, 0.2)',
                          }}
                        />
                      ))
                    }
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        variant="outlined"
                        placeholder="部門を選択"
                      />
                    )}
                  />
                </Grid>
              </Grid>

              {/* Active Filters Display */}
              {getActiveFiltersCount() > 0 && (
                <Box sx={{ mt: 3, pt: 2, borderTop: '1px solid rgba(255, 255, 255, 0.1)' }}>
                  <Typography variant="subtitle2" gutterBottom color="text.secondary">
                    アクティブなフィルター:
                  </Typography>
                  <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
                    {localFilters.categories.map(category => (
                      <Chip
                        key={`category-${category}`}
                        label={`カテゴリ: ${category}`}
                        size="small"
                        variant="outlined"
                        onDelete={() => 
                          handleLocalFilterChange('categories', 
                            localFilters.categories.filter(c => c !== category)
                          )
                        }
                        sx={{
                          color: 'rgba(255, 255, 255, 0.8)',
                          borderColor: 'rgba(33, 150, 243, 0.5)',
                          backgroundColor: 'rgba(33, 150, 243, 0.1)',
                        }}
                      />
                    ))}
                    {localFilters.users.map(user => (
                      <Chip
                        key={`user-${user}`}
                        label={`ユーザー: ${user}`}
                        size="small"
                        variant="outlined"
                        onDelete={() => 
                          handleLocalFilterChange('users', 
                            localFilters.users.filter(u => u !== user)
                          )
                        }
                        sx={{
                          color: 'rgba(255, 255, 255, 0.8)',
                          borderColor: 'rgba(76, 175, 80, 0.5)',
                          backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        }}
                      />
                    ))}
                    {localFilters.departments.map(dept => (
                      <Chip
                        key={`dept-${dept}`}
                        label={`部門: ${dept}`}
                        size="small"
                        variant="outlined"
                        onDelete={() => 
                          handleLocalFilterChange('departments', 
                            localFilters.departments.filter(d => d !== dept)
                          )
                        }
                        sx={{
                          color: 'rgba(255, 255, 255, 0.8)',
                          borderColor: 'rgba(156, 39, 176, 0.5)',
                          backgroundColor: 'rgba(156, 39, 176, 0.1)',
                        }}
                      />
                    ))}
                    {(localFilters.amountRange.min || localFilters.amountRange.max) && (
                      <Chip
                        label={`金額: ${localFilters.amountRange.min ? `¥${localFilters.amountRange.min}以上` : ''}${
                          localFilters.amountRange.min && localFilters.amountRange.max ? ' - ' : ''
                        }${localFilters.amountRange.max ? `¥${localFilters.amountRange.max}以下` : ''}`}
                        size="small"
                        variant="outlined"
                        onDelete={() => 
                          handleLocalFilterChange('amountRange', { min: '', max: '' })
                        }
                        sx={{
                          color: 'rgba(255, 255, 255, 0.8)',
                          borderColor: 'rgba(255, 193, 7, 0.5)',
                          backgroundColor: 'rgba(255, 193, 7, 0.1)',
                        }}
                      />
                    )}
                    {localFilters.transactionType !== 'all' && (
                      <Chip
                        label={`種別: ${transactionTypeOptions.find(t => t.value === localFilters.transactionType)?.label}`}
                        size="small"
                        variant="outlined"
                        onDelete={() => 
                          handleLocalFilterChange('transactionType', 'all')
                        }
                        sx={{
                          color: 'rgba(255, 255, 255, 0.8)',
                          borderColor: 'rgba(255, 152, 0, 0.5)',
                          backgroundColor: 'rgba(255, 152, 0, 0.1)',
                        }}
                      />
                    )}
                  </Stack>
                </Box>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </GlassCardContent>
    </GlassCard>
  );
};

export default FilterPanel;
</file>

<file path="src/components/Analytics/FinancialSummary.js">
import React from 'react';
import {
  Grid,
  Typography,
  Box,
  Stack,
  Avatar,
  Chip,
  LinearProgress,
} from '@mui/material';
import {
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  Assessment as AssessmentIcon,
  AccountBalance as AccountBalanceIcon,
  Savings as SavingsIcon,
  CompareArrows as CompareArrowsIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';
import { formatCurrency, formatPercentage } from '../../utils/formatters';

const FinancialSummary = ({ data, period = 'monthly' }) => {
  const {
    totalIncome = 5500000,
    totalExpense = 3800000,
    monthlyIncome = 1250000,
    monthlyExpense = 850000,
    quarterlyIncome = 3600000,
    quarterlyExpense = 2400000,
    incomeGrowth = 12.5,
    expenseGrowth = -5.2,
    profitMargin = 30.9,
    averageTransaction = 12450
  } = data || {};

  const profit = totalIncome - totalExpense;
  const monthlyProfit = monthlyIncome - monthlyExpense;
  const quarterlyProfit = quarterlyIncome - quarterlyExpense;

  const currentIncome = period === 'quarterly' ? quarterlyIncome : monthlyIncome;
  const currentExpense = period === 'quarterly' ? quarterlyExpense : monthlyExpense;
  const currentProfit = period === 'quarterly' ? quarterlyProfit : monthlyProfit;

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.6,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  const getSummaryCards = () => {
    return [
      {
        title: `${period === 'quarterly' ? '四半期' : '月間'}収入`,
        value: formatCurrency(currentIncome, true),
        icon: TrendingUpIcon,
        color: 'success.main',
        gradient: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
        trend: incomeGrowth,
        comparison: '前期比',
      },
      {
        title: `${period === 'quarterly' ? '四半期' : '月間'}支出`,
        value: formatCurrency(currentExpense, true),
        icon: TrendingDownIcon,
        color: 'error.main',
        gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
        trend: expenseGrowth,
        comparison: '前期比',
      },
      {
        title: `${period === 'quarterly' ? '四半期' : '月間'}利益`,
        value: formatCurrency(currentProfit, true),
        icon: AssessmentIcon,
        color: 'primary.main',
        gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        trend: incomeGrowth - expenseGrowth,
        comparison: '前期比',
      },
      {
        title: '利益率',
        value: formatPercentage(profitMargin),
        icon: AccountBalanceIcon,
        color: 'info.main',
        gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        trend: 2.3,
        comparison: '前期比',
      },
    ];
  };

  const getDetailCards = () => {
    return [
      {
        title: '年間総収入',
        value: formatCurrency(totalIncome, true),
        icon: SavingsIcon,
        color: 'success.light',
        progress: 75,
        target: '目標達成率',
      },
      {
        title: '年間総支出',
        value: formatCurrency(totalExpense, true),
        icon: CompareArrowsIcon,
        color: 'warning.main',
        progress: 63,
        target: '予算消化率',
      },
      {
        title: '年間純利益',
        value: formatCurrency(profit, true),
        icon: AssessmentIcon,
        color: 'primary.main',
        progress: 85,
        target: '目標達成率',
      },
      {
        title: '平均取引額',
        value: formatCurrency(averageTransaction, true),
        icon: AccountBalanceIcon,
        color: 'info.main',
        progress: 45,
        target: '効率指標',
      },
    ];
  };

  return (
    <Box>
      {/* Main Financial Summary Cards */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        {getSummaryCards().map((card, index) => (
          <Grid item xs={12} sm={6} md={3} key={card.title}>
            <motion.div
              variants={itemVariants}
              initial="hidden"
              animate="visible"
              transition={{ delay: index * 0.1 }}
            >
              <GlassCard
                sx={{
                  height: '100%',
                  minHeight: '160px',
                  background: card.gradient,
                  position: 'relative',
                  overflow: 'hidden',
                  '&::before': {
                    content: '""',
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'rgba(255, 255, 255, 0.1)',
                    backdropFilter: 'blur(10px)',
                    borderRadius: 'inherit',
                  },
                }}
              >
                <GlassCardContent sx={{ position: 'relative', zIndex: 1 }}>
                  <Stack direction="row" alignItems="center" spacing={2}>
                    <Avatar
                      sx={{
                        bgcolor: 'rgba(255, 255, 255, 0.2)',
                        color: 'white',
                        width: 56,
                        height: 56,
                      }}
                    >
                      <card.icon fontSize="large" />
                    </Avatar>
                    <Box flex={1} sx={{ minWidth: 0 }}>
                      <Typography
                        variant="h4"
                        fontWeight="bold"
                        color="white"
                        sx={{ 
                          fontSize: { xs: '1.25rem', sm: '1.5rem', md: '1.75rem' },
                          whiteSpace: 'nowrap',
                          overflow: 'hidden',
                          textOverflow: 'ellipsis'
                        }}
                      >
                        {card.value}
                      </Typography>
                      <Typography 
                        variant="body2" 
                        color="rgba(255, 255, 255, 0.8)"
                        sx={{ 
                          lineHeight: 1.2,
                          minHeight: '2.4em',
                          display: 'flex',
                          alignItems: 'center'
                        }}
                      >
                        {card.title}
                      </Typography>
                      <Stack direction="row" alignItems="center" spacing={1} sx={{ mt: 1 }}>
                        <Chip
                          label={`${card.trend > 0 ? '+' : ''}${formatPercentage(card.trend)}`}
                          size="small"
                          sx={{
                            bgcolor: card.trend > 0 
                              ? 'rgba(76, 175, 80, 0.3)' 
                              : 'rgba(244, 67, 54, 0.3)',
                            color: 'white',
                            fontWeight: 'bold',
                          }}
                        />
                        <Typography variant="caption" color="rgba(255, 255, 255, 0.7)">
                          {card.comparison}
                        </Typography>
                      </Stack>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        ))}
      </Grid>

      {/* Detailed Financial Overview */}
      <Grid container spacing={3}>
        {getDetailCards().map((card, index) => (
          <Grid item xs={12} sm={6} md={3} key={card.title}>
            <motion.div
              variants={itemVariants}
              initial="hidden"
              animate="visible"
              transition={{ delay: (index + 4) * 0.1 }}
            >
              <GlassCard sx={{ height: '100%', minHeight: '180px' }}>
                <GlassCardContent>
                  <Stack spacing={2}>
                    <Stack direction="row" alignItems="center" spacing={2}>
                      <Avatar sx={{ bgcolor: card.color, width: 48, height: 48 }}>
                        <card.icon />
                      </Avatar>
                      <Box flex={1} sx={{ minWidth: 0 }}>
                        <Typography 
                          variant="h5" 
                          fontWeight="bold"
                          sx={{ 
                            fontSize: { xs: '1rem', sm: '1.25rem' },
                            whiteSpace: 'nowrap',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis'
                          }}
                        >
                          {card.value}
                        </Typography>
                        <Typography 
                          variant="body2" 
                          color="text.secondary"
                          sx={{ 
                            lineHeight: 1.2,
                            minHeight: '2.4em',
                            display: 'flex',
                            alignItems: 'center'
                          }}
                        >
                          {card.title}
                        </Typography>
                      </Box>
                    </Stack>
                    
                    <Box>
                      <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 1 }}>
                        <Typography variant="caption" color="text.secondary">
                          {card.target}
                        </Typography>
                        <Typography variant="caption" fontWeight="bold">
                          {card.progress}%
                        </Typography>
                      </Stack>
                      <LinearProgress
                        variant="determinate"
                        value={card.progress}
                        sx={{
                          height: 8,
                          borderRadius: 4,
                          bgcolor: 'rgba(255, 255, 255, 0.1)',
                          '& .MuiLinearProgress-bar': {
                            borderRadius: 4,
                            background: `linear-gradient(90deg, ${card.color} 0%, rgba(255, 255, 255, 0.8) 100%)`,
                          },
                        }}
                      />
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        ))}
      </Grid>

      {/* Income vs Expense Comparison */}
      <Grid container spacing={3} sx={{ mt: 2 }}>
        <Grid item xs={12}>
          <motion.div
            variants={itemVariants}
            initial="hidden"
            animate="visible"
            transition={{ delay: 0.8 }}
          >
            <GlassCard>
              <GlassCardContent>
                <Typography variant="h6" gutterBottom fontWeight="bold">
                  収支バランス分析
                </Typography>
                <Grid container spacing={3}>
                  <Grid item xs={12} md={4}>
                    <Box sx={{ textAlign: 'center', p: 2 }}>
                      <Typography variant="h3" fontWeight="bold" color="success.main">
                        {formatPercentage((currentIncome / (currentIncome + currentExpense)) * 100)}
                      </Typography>
                      <Typography variant="body1" color="text.secondary">
                        収入比率
                      </Typography>
                      <LinearProgress
                        variant="determinate"
                        value={(currentIncome / (currentIncome + currentExpense)) * 100}
                        sx={{
                          mt: 2,
                          height: 8,
                          borderRadius: 4,
                          bgcolor: 'rgba(76, 175, 80, 0.1)',
                          '& .MuiLinearProgress-bar': {
                            bgcolor: 'success.main',
                            borderRadius: 4,
                          },
                        }}
                      />
                    </Box>
                  </Grid>
                  <Grid item xs={12} md={4}>
                    <Box sx={{ textAlign: 'center', p: 2 }}>
                      <Typography variant="h3" fontWeight="bold" color="error.main">
                        {formatPercentage((currentExpense / (currentIncome + currentExpense)) * 100)}
                      </Typography>
                      <Typography variant="body1" color="text.secondary">
                        支出比率
                      </Typography>
                      <LinearProgress
                        variant="determinate"
                        value={(currentExpense / (currentIncome + currentExpense)) * 100}
                        sx={{
                          mt: 2,
                          height: 8,
                          borderRadius: 4,
                          bgcolor: 'rgba(244, 67, 54, 0.1)',
                          '& .MuiLinearProgress-bar': {
                            bgcolor: 'error.main',
                            borderRadius: 4,
                          },
                        }}
                      />
                    </Box>
                  </Grid>
                  <Grid item xs={12} md={4}>
                    <Box sx={{ textAlign: 'center', p: 2 }}>
                      <Typography variant="h3" fontWeight="bold" color="primary.main">
                        {formatPercentage((currentProfit / currentIncome) * 100)}
                      </Typography>
                      <Typography variant="body1" color="text.secondary">
                        利益率
                      </Typography>
                      <LinearProgress
                        variant="determinate"
                        value={(currentProfit / currentIncome) * 100}
                        sx={{
                          mt: 2,
                          height: 8,
                          borderRadius: 4,
                          bgcolor: 'rgba(25, 118, 210, 0.1)',
                          '& .MuiLinearProgress-bar': {
                            bgcolor: 'primary.main',
                            borderRadius: 4,
                          },
                        }}
                      />
                    </Box>
                  </Grid>
                </Grid>
              </GlassCardContent>
            </GlassCard>
          </motion.div>
        </Grid>
      </Grid>
    </Box>
  );
};

export default FinancialSummary;
</file>

<file path="src/components/Analytics/IncomeChart.js">
import React, { useState } from 'react';
import { useTheme } from '@mui/material/styles';
import {
  Box,
  Typography,
  ToggleButton,
  ToggleButtonGroup,
  Stack,
  Chip,
  Grid,
  Avatar,
} from '@mui/material';
import {
  BarChart as BarChartIcon,
  ShowChart as LineChartIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  AccountBalance as AccountBalanceIcon,
  Business as BusinessIcon,
  Work as WorkIcon,
  Savings as SavingsIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import { Bar, Line } from 'react-chartjs-2';
import GlassCard, { GlassCardContent } from '../common/GlassCard';
import { formatCurrency, formatPercentage } from '../../utils/formatters';

const IncomeChart = ({ data, period = 'monthly' }) => {
  const theme = useTheme();
  const [chartType, setChartType] = useState('bar');

  const {
    sourceData = {
      labels: ['基本給', 'ボーナス', '手当', '副業', 'その他'],
      amounts: [800000, 200000, 150000, 80000, 20000],
      trends: [2.5, 15.0, -3.2, 25.8, 10.0]
    },
    monthlyTrends = {
      labels: ['1月', '2月', '3月', '4月', '5月', '6月'],
      data: [1250000, 1100000, 1350000, 1200000, 1250000, 1400000]
    },
    comparisonData = {
      labels: ['1月', '2月', '3月', '4月', '5月', '6月'],
      currentYear: [1250000, 1100000, 1350000, 1200000, 1250000, 1400000],
      previousYear: [1200000, 1050000, 1300000, 1150000, 1200000, 1350000]
    },
    growthMetrics = {
      monthlyGrowth: 12.5,
      yearOverYear: 8.3,
      quarterlyGrowth: 15.2
    }
  } = data || {};

  const colors = [
    'rgba(17, 153, 142, 0.8)',
    'rgba(102, 126, 234, 0.8)',
    'rgba(79, 172, 254, 0.8)',
    'rgba(168, 237, 234, 0.8)',
    'rgba(255, 193, 7, 0.8)',
  ];

  const borderColors = [
    'rgba(17, 153, 142, 1)',
    'rgba(102, 126, 234, 1)',
    'rgba(79, 172, 254, 1)',
    'rgba(168, 237, 234, 1)',
    'rgba(255, 193, 7, 1)',
  ];

  const sourceIcons = [
    AccountBalanceIcon,
    SavingsIcon,
    WorkIcon,
    BusinessIcon,
    AccountBalanceIcon,
  ];

  const barData = {
    labels: monthlyTrends.labels,
    datasets: [{
      label: `${period === 'quarterly' ? '四半期' : '月間'}収入`,
      data: monthlyTrends.data,
      backgroundColor: colors[0],
      borderColor: borderColors[0],
      borderWidth: 2,
      borderRadius: 8,
      borderSkipped: false,
    }],
  };

  const lineData = {
    labels: comparisonData.labels,
    datasets: [
      {
        label: '今年',
        data: comparisonData.currentYear,
        borderColor: borderColors[0],
        backgroundColor: colors[0],
        fill: true,
        tension: 0.4,
        pointRadius: 6,
        pointHoverRadius: 8,
        pointBackgroundColor: borderColors[0],
        pointBorderColor: '#fff',
        pointBorderWidth: 2,
      },
      {
        label: '前年',
        data: comparisonData.previousYear,
        borderColor: borderColors[1],
        backgroundColor: colors[1],
        fill: true,
        tension: 0.4,
        pointRadius: 6,
        pointHoverRadius: 8,
        pointBackgroundColor: borderColors[1],
        pointBorderColor: '#fff',
        pointBorderWidth: 2,
      },
    ],
  };

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top',
        labels: {
          color: theme.palette.text.primary,
          padding: 20,
          usePointStyle: true,
          pointStyle: 'circle',
        },
      },
      tooltip: {
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        titleColor: theme.palette.text.primary,
        bodyColor: theme.palette.text.primary,
        borderColor: theme.palette.divider,
        borderWidth: 1,
        cornerRadius: 12,
        displayColors: true,
        callbacks: {
          label: function(context) {
            const value = context.parsed.y || context.parsed;
            return `${context.dataset.label}: ${formatCurrency(value, true)}`;
          },
        },
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        grid: {
          color: theme.palette.divider,
        },
        ticks: {
          color: theme.palette.text.secondary,
          callback: function(value) {
            return formatCurrency(value, true);
          },
        },
      },
      x: {
        grid: {
          color: theme.palette.divider,
        },
        ticks: {
          color: theme.palette.text.secondary,
        },
      },
    },
    interaction: {
      intersect: false,
      mode: 'index',
    },
    animation: {
      duration: 1500,
      easing: 'easeInOutQuart',
    },
  };

  const chartVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: {
      opacity: 1,
      scale: 1,
      transition: {
        duration: 0.8,
        ease: [0.4, 0, 0.2, 1],
      },
    },
    exit: {
      opacity: 0,
      scale: 0.9,
      transition: {
        duration: 0.3,
      },
    },
  };

  const renderChart = () => {
    switch (chartType) {
      case 'bar':
        return <Bar data={barData} options={chartOptions} />;
      case 'line':
        return <Line data={lineData} options={chartOptions} />;
      default:
        return <Bar data={barData} options={chartOptions} />;
    }
  };

  const getTotalIncome = () => {
    if (!sourceData.amounts || sourceData.amounts.length === 0) return 0;
    return sourceData.amounts.reduce((sum, amount) => sum + (amount || 0), 0);
  };

  const getTopSource = () => {
    if (!sourceData.amounts || sourceData.amounts.length === 0) {
      return { name: 'データなし', amount: 0, trend: 0 };
    }
    const maxIndex = sourceData.amounts.indexOf(Math.max(...sourceData.amounts));
    return {
      name: sourceData.labels[maxIndex] || 'データなし',
      amount: sourceData.amounts[maxIndex] || 0,
      trend: sourceData.trends[maxIndex] || 0
    };
  };

  const topSource = getTopSource();

  return (
    <Box>
      {/* Growth Indicators */}
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} md={4}>
          <GlassCard>
            <GlassCardContent>
              <Stack direction="row" alignItems="center" spacing={2}>
                <Avatar
                  sx={{
                    bgcolor: 'success.main',
                    background: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
                  }}
                >
                  <TrendingUpIcon />
                </Avatar>
                <Box sx={{ minWidth: 0, flex: 1 }}>
                  <Typography variant="h5" fontWeight="bold">
                    +{formatPercentage(growthMetrics.monthlyGrowth)}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    月間成長率
                  </Typography>
                </Box>
              </Stack>
            </GlassCardContent>
          </GlassCard>
        </Grid>
        <Grid item xs={12} md={4}>
          <GlassCard>
            <GlassCardContent>
              <Stack direction="row" alignItems="center" spacing={2}>
                <Avatar
                  sx={{
                    bgcolor: 'primary.main',
                    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  }}
                >
                  <TrendingUpIcon />
                </Avatar>
                <Box sx={{ minWidth: 0, flex: 1 }}>
                  <Typography variant="h5" fontWeight="bold">
                    +{formatPercentage(growthMetrics.yearOverYear)}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    前年同期比
                  </Typography>
                </Box>
              </Stack>
            </GlassCardContent>
          </GlassCard>
        </Grid>
        <Grid item xs={12} md={4}>
          <GlassCard>
            <GlassCardContent>
              <Stack direction="row" alignItems="center" spacing={2}>
                <Avatar
                  sx={{
                    bgcolor: 'info.main',
                    background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                  }}
                >
                  <TrendingUpIcon />
                </Avatar>
                <Box sx={{ minWidth: 0, flex: 1 }}>
                  <Typography variant="h5" fontWeight="bold">
                    +{formatPercentage(growthMetrics.quarterlyGrowth)}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    四半期成長率
                  </Typography>
                </Box>
              </Stack>
            </GlassCardContent>
          </GlassCard>
        </Grid>
      </Grid>

      {/* Main Income Chart */}
      <GlassCard sx={{ mb: 3 }}>
        <GlassCardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
            <Typography variant="h5" fontWeight="bold">
              収入分析
            </Typography>
            <ToggleButtonGroup
              value={chartType}
              exclusive
              onChange={(e, newChartType) => newChartType && setChartType(newChartType)}
              size="small"
              sx={{
                '& .MuiToggleButton-root': {
                  color: 'rgba(255, 255, 255, 0.7)',
                  borderColor: 'rgba(255, 255, 255, 0.2)',
                  '&.Mui-selected': {
                    bgcolor: 'rgba(255, 255, 255, 0.1)',
                    color: 'white',
                  },
                },
              }}
            >
              <ToggleButton value="bar">
                <BarChartIcon />
              </ToggleButton>
              <ToggleButton value="line">
                <LineChartIcon />
              </ToggleButton>
            </ToggleButtonGroup>
          </Box>

          {/* Summary Stats */}
          <Stack direction="row" spacing={2} sx={{ mb: 3 }}>
            <Chip
              label={`総収入: ${formatCurrency(getTotalIncome(), true)}`}
              variant="outlined"
              sx={{
                color: 'white',
                borderColor: 'rgba(255, 255, 255, 0.3)',
                backgroundColor: 'rgba(17, 153, 142, 0.2)',
              }}
            />
            <Chip
              label={`主要: ${topSource.name} ${formatCurrency(topSource.amount, true)}`}
              variant="outlined"
              sx={{
                color: 'white',
                borderColor: 'rgba(255, 255, 255, 0.3)',
                backgroundColor: 'rgba(102, 126, 234, 0.2)',
              }}
            />
            <Chip
              icon={topSource.trend > 0 ? <TrendingUpIcon /> : <TrendingDownIcon />}
              label={`${topSource.trend > 0 ? '+' : ''}${formatPercentage(topSource.trend)}`}
              variant="outlined"
              sx={{
                color: 'white',
                borderColor: 'rgba(255, 255, 255, 0.3)',
                backgroundColor: topSource.trend > 0 
                  ? 'rgba(76, 175, 80, 0.2)' 
                  : 'rgba(244, 67, 54, 0.2)',
              }}
            />
          </Stack>

          <Box sx={{ height: 350 }}>
            <AnimatePresence mode="wait">
              <motion.div
                key={chartType}
                variants={chartVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
                style={{ height: '100%' }}
              >
                {renderChart()}
              </motion.div>
            </AnimatePresence>
          </Box>
        </GlassCardContent>
      </GlassCard>

      {/* Income Source Breakdown */}
      <GlassCard>
        <GlassCardContent>
          <Typography variant="h6" gutterBottom fontWeight="bold">
            収入源別詳細
          </Typography>
          <Grid container spacing={2}>
            {sourceData.labels && sourceData.labels.length > 0 ? sourceData.labels.map((label, index) => {
              const amount = sourceData.amounts[index] || 0;
              const trend = sourceData.trends[index] || 0;
              const totalIncome = getTotalIncome();
              const percentage = totalIncome > 0 ? ((amount / totalIncome) * 100).toFixed(1) : '0.0';
              const IconComponent = sourceIcons[index] || sourceIcons[0];
              
              return (
                <Grid item xs={12} sm={6} lg={4} key={label}>
                  <motion.div
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.1 }}
                  >
                    <Box
                      sx={{
                        p: 3,
                        borderRadius: 2,
                        background: `linear-gradient(135deg, ${colors[index]}, rgba(255, 255, 255, 0.1))`,
                        border: `1px solid ${borderColors[index]}`,
                        height: '100%',
                        display: 'flex',
                        flexDirection: 'column',
                        justifyContent: 'space-between',
                        minHeight: 180,
                      }}
                    >
                      <Stack direction="row" alignItems="flex-start" spacing={2} sx={{ mb: 2 }}>
                        <Avatar
                          sx={{
                            bgcolor: 'rgba(255, 255, 255, 0.2)',
                            color: 'white',
                            flexShrink: 0,
                          }}
                        >
                          <IconComponent />
                        </Avatar>
                        <Box sx={{ minWidth: 0, flex: 1 }}>
                          <Typography 
                            variant="h6" 
                            fontWeight="bold" 
                            color="white"
                            sx={{
                              fontSize: { xs: '1rem', sm: '1.125rem' },
                              whiteSpace: 'nowrap',
                              overflow: 'hidden',
                              textOverflow: 'ellipsis'
                            }}
                          >
                            {label}
                          </Typography>
                          <Typography variant="body2" color="rgba(255, 255, 255, 0.8)">
                            {percentage}% of total
                          </Typography>
                        </Box>
                      </Stack>
                      
                      <Box>
                        <Typography 
                          variant="h5" 
                          fontWeight="bold" 
                          color="white" 
                          sx={{ 
                            mb: 1,
                            fontSize: { xs: '1.25rem', sm: '1.5rem' },
                          }}
                        >
                          {formatCurrency(amount, true)}
                        </Typography>
                        <Stack direction="row" alignItems="center" spacing={1} flexWrap="wrap">
                          <Chip
                            size="small"
                            icon={trend > 0 ? <TrendingUpIcon /> : <TrendingDownIcon />}
                            label={`${trend > 0 ? '+' : ''}${formatPercentage(trend)}`}
                            sx={{
                              bgcolor: trend > 0 
                                ? 'rgba(76, 175, 80, 0.3)' 
                                : 'rgba(244, 67, 54, 0.3)',
                              color: 'white',
                              '& .MuiChip-icon': {
                                color: 'white',
                              },
                            }}
                          />
                          <Typography variant="caption" color="rgba(255, 255, 255, 0.7)">
                            前期比
                          </Typography>
                        </Stack>
                      </Box>
                    </Box>
                  </motion.div>
                </Grid>
              );
            }) : (
              <Grid item xs={12}>
                <Box sx={{ textAlign: 'center', py: 2 }}>
                  <Typography color="text.secondary">収入データがありません</Typography>
                </Box>
              </Grid>
            )}
          </Grid>
        </GlassCardContent>
      </GlassCard>
    </Box>
  );
};

export default IncomeChart;
</file>

<file path="src/components/Analytics/UserRanking.js">
import React, { useState } from 'react';
import {
  Box,
  Typography,
  Avatar,
  Stack,
  Chip,
  Grid,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  ToggleButton,
  ToggleButtonGroup,
  LinearProgress,
} from '@mui/material';
import {
  Person as PersonIcon,
  Business as BusinessIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  EmojiEvents as TrophyIcon,
  Star as StarIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { Bar, Radar } from 'react-chartjs-2';
import GlassCard, { GlassCardContent } from '../common/GlassCard';

const UserRanking = ({ data, period = 'monthly' }) => {
  const [viewType, setViewType] = useState('users');

  const {
    userRankings = [
      { 
        id: 1, 
        name: '田中太郎', 
        avatar: '', 
        department: '営業部',
        amount: 320000, 
        transactions: 45, 
        trend: 12.5,
        efficiency: 85,
        rank: 1,
        badge: 'gold'
      },
      { 
        id: 2, 
        name: '佐藤花子', 
        avatar: '', 
        department: 'マーケティング部',
        amount: 280000, 
        transactions: 38, 
        trend: -5.2,
        efficiency: 92,
        rank: 2,
        badge: 'silver'
      },
      { 
        id: 3, 
        name: '山田次郎', 
        avatar: '', 
        department: '開発部',
        amount: 210000, 
        transactions: 31, 
        trend: 8.7,
        efficiency: 78,
        rank: 3,
        badge: 'bronze'
      },
      { 
        id: 4, 
        name: '鈴木一郎', 
        avatar: '', 
        department: '管理部',
        amount: 180000, 
        transactions: 25, 
        trend: 15.3,
        efficiency: 88,
        rank: 4,
        badge: null
      },
      { 
        id: 5, 
        name: '高橋美咲', 
        avatar: '', 
        department: '営業部',
        amount: 150000, 
        transactions: 22, 
        trend: -2.1,
        efficiency: 95,
        rank: 5,
        badge: null
      },
    ],
    departmentData = [
      { 
        name: '営業部', 
        totalAmount: 470000, 
        userCount: 8, 
        avgAmount: 58750,
        trend: 8.5,
        efficiency: 87
      },
      { 
        name: 'マーケティング部', 
        totalAmount: 380000, 
        userCount: 6, 
        avgAmount: 63333,
        trend: -2.3,
        efficiency: 91
      },
      { 
        name: '開発部', 
        totalAmount: 350000, 
        userCount: 12, 
        avgAmount: 29167,
        trend: 12.1,
        efficiency: 83
      },
      { 
        name: '管理部', 
        totalAmount: 250000, 
        userCount: 4, 
        avgAmount: 62500,
        trend: 5.7,
        efficiency: 89
      },
    ]
  } = data || {};

  const getBadgeColor = (badge) => {
    switch (badge) {
      case 'gold':
        return 'linear-gradient(135deg, #FFD700 0%, #FFA500 100%)';
      case 'silver':
        return 'linear-gradient(135deg, #C0C0C0 0%, #808080 100%)';
      case 'bronze':
        return 'linear-gradient(135deg, #CD7F32 0%, #8B4513 100%)';
      default:
        return 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
    }
  };

  const getBadgeIcon = (badge) => {
    switch (badge) {
      case 'gold':
      case 'silver':
      case 'bronze':
        return <TrophyIcon />;
      default:
        return <StarIcon />;
    }
  };

  // Chart data for user spending patterns
  const userChartData = {
    labels: userRankings.slice(0, 5).map(user => user.name),
    datasets: [{
      label: `${period === 'quarterly' ? '四半期' : '月間'}支出額`,
      data: userRankings.slice(0, 5).map(user => user.amount),
      backgroundColor: [
        'rgba(255, 215, 0, 0.8)',
        'rgba(192, 192, 192, 0.8)',
        'rgba(205, 127, 50, 0.8)',
        'rgba(102, 126, 234, 0.8)',
        'rgba(250, 112, 154, 0.8)',
      ],
      borderColor: [
        'rgba(255, 215, 0, 1)',
        'rgba(192, 192, 192, 1)',
        'rgba(205, 127, 50, 1)',
        'rgba(102, 126, 234, 1)',
        'rgba(250, 112, 154, 1)',
      ],
      borderWidth: 2,
      borderRadius: 8,
    }],
  };

  // Radar chart for department comparison
  const departmentRadarData = {
    labels: ['支出額', '効率性', 'ユーザー数', '平均額', '成長率'],
    datasets: departmentData.slice(0, 4).map((dept, index) => ({
      label: dept.name,
      data: [
        (dept.totalAmount / 500000) * 100,
        dept.efficiency,
        (dept.userCount / 15) * 100,
        (dept.avgAmount / 70000) * 100,
        Math.max(0, dept.trend + 50), // Normalize to positive scale
      ],
      backgroundColor: `rgba(${102 + index * 50}, ${126 + index * 30}, ${234 - index * 40}, 0.2)`,
      borderColor: `rgba(${102 + index * 50}, ${126 + index * 30}, ${234 - index * 40}, 1)`,
      pointBackgroundColor: `rgba(${102 + index * 50}, ${126 + index * 30}, ${234 - index * 40}, 1)`,
    })),
  };

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top',
        labels: {
          color: 'rgba(255, 255, 255, 0.8)',
          padding: 20,
          usePointStyle: true,
        },
      },
      tooltip: {
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        titleColor: 'white',
        bodyColor: 'white',
        borderColor: 'rgba(255, 255, 255, 0.2)',
        borderWidth: 1,
        cornerRadius: 12,
        callbacks: {
          label: function(context) {
            const value = context.parsed.y || context.parsed;
            return `${context.dataset.label}: ¥${value.toLocaleString()}`;
          },
        },
      },
    },
    scales: viewType === 'users' ? {
      y: {
        beginAtZero: true,
        grid: {
          color: 'rgba(255, 255, 255, 0.1)',
        },
        ticks: {
          color: 'rgba(255, 255, 255, 0.7)',
          callback: function(value) {
            return '¥' + value.toLocaleString();
          },
        },
      },
      x: {
        grid: {
          color: 'rgba(255, 255, 255, 0.1)',
        },
        ticks: {
          color: 'rgba(255, 255, 255, 0.7)',
        },
      },
    } : {
      r: {
        beginAtZero: true,
        max: 100,
        grid: {
          color: 'rgba(255, 255, 255, 0.1)',
        },
        angleLines: {
          color: 'rgba(255, 255, 255, 0.1)',
        },
        pointLabels: {
          color: 'rgba(255, 255, 255, 0.7)',
        },
        ticks: {
          color: 'rgba(255, 255, 255, 0.5)',
          backdropColor: 'transparent',
        },
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  return (
    <Box>
      {/* View Toggle */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h5" fontWeight="bold">
          ユーザー・部門分析
        </Typography>
        <ToggleButtonGroup
          value={viewType}
          exclusive
          onChange={(e, newViewType) => newViewType && setViewType(newViewType)}
          size="small"
          sx={{
            '& .MuiToggleButton-root': {
              color: 'rgba(255, 255, 255, 0.7)',
              borderColor: 'rgba(255, 255, 255, 0.2)',
              '&.Mui-selected': {
                bgcolor: 'rgba(255, 255, 255, 0.1)',
                color: 'white',
              },
            },
          }}
        >
          <ToggleButton value="users">
            <PersonIcon sx={{ mr: 1 }} />
            ユーザー
          </ToggleButton>
          <ToggleButton value="departments">
            <BusinessIcon sx={{ mr: 1 }} />
            部門
          </ToggleButton>
        </ToggleButtonGroup>
      </Box>

      <Grid container spacing={3}>
        {/* Rankings/Department List */}
        <Grid item xs={12} md={6}>
          <GlassCard>
            <GlassCardContent>
              <Typography variant="h6" gutterBottom fontWeight="bold">
                {viewType === 'users' ? 'ユーザーランキング' : '部門別支出'}
              </Typography>
              
              {viewType === 'users' ? (
                <Stack spacing={2}>
                  {userRankings.map((user, index) => (
                    <motion.div
                      key={user.id}
                      variants={itemVariants}
                      initial="hidden"
                      animate="visible"
                      transition={{ delay: index * 0.1 }}
                    >
                      <Box
                        sx={{
                          p: 2,
                          borderRadius: 2,
                          background: user.badge 
                            ? getBadgeColor(user.badge)
                            : 'rgba(255, 255, 255, 0.05)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                        }}
                      >
                        <Stack direction="row" alignItems="center" spacing={2}>
                          <Box sx={{ position: 'relative' }}>
                            <Avatar
                              sx={{
                                bgcolor: user.badge ? 'rgba(255, 255, 255, 0.2)' : 'primary.main',
                                color: 'white',
                                width: 48,
                                height: 48,
                              }}
                            >
                              {user.name.charAt(0)}
                            </Avatar>
                            {user.badge && (
                              <Avatar
                                sx={{
                                  position: 'absolute',
                                  top: -8,
                                  right: -8,
                                  width: 24,
                                  height: 24,
                                  bgcolor: getBadgeColor(user.badge),
                                  color: 'white',
                                }}
                              >
                                {getBadgeIcon(user.badge)}
                              </Avatar>
                            )}
                          </Box>
                          <Box>
                            <Typography variant="h6" fontWeight="bold" color="white">
                              {user.rank}. {user.name}
                            </Typography>
                            <Typography variant="body2" color="rgba(255, 255, 255, 0.8)">
                              {user.department} • {user.transactions}件
                            </Typography>
                          </Box>
                        </Stack>
                        
                        <Stack alignItems="flex-end" spacing={1}>
                          <Typography variant="h6" fontWeight="bold" color="white">
                            ¥{user.amount.toLocaleString()}
                          </Typography>
                          <Stack direction="row" alignItems="center" spacing={1}>
                            <Chip
                              size="small"
                              icon={user.trend > 0 ? <TrendingUpIcon /> : <TrendingDownIcon />}
                              label={`${user.trend > 0 ? '+' : ''}${user.trend}%`}
                              sx={{
                                bgcolor: user.trend > 0 
                                  ? 'rgba(76, 175, 80, 0.3)' 
                                  : 'rgba(244, 67, 54, 0.3)',
                                color: 'white',
                                '& .MuiChip-icon': {
                                  color: 'white',
                                },
                              }}
                            />
                            <Typography variant="caption" color="rgba(255, 255, 255, 0.7)">
                              効率: {user.efficiency}%
                            </Typography>
                          </Stack>
                        </Stack>
                      </Box>
                    </motion.div>
                  ))}
                </Stack>
              ) : (
                <Stack spacing={2}>
                  {departmentData.map((dept, index) => (
                    <motion.div
                      key={dept.name}
                      variants={itemVariants}
                      initial="hidden"
                      animate="visible"
                      transition={{ delay: index * 0.1 }}
                    >
                      <Box
                        sx={{
                          p: 3,
                          borderRadius: 2,
                          bgcolor: 'rgba(255, 255, 255, 0.05)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                        }}
                      >
                        <Stack direction="row" alignItems="center" justifyContent="space-between">
                          <Stack direction="row" alignItems="center" spacing={2}>
                            <Avatar sx={{ bgcolor: 'primary.main' }}>
                              <BusinessIcon />
                            </Avatar>
                            <Box>
                              <Typography variant="h6" fontWeight="bold">
                                {dept.name}
                              </Typography>
                              <Typography variant="body2" color="text.secondary">
                                {dept.userCount}名 • 平均¥{dept.avgAmount.toLocaleString()}
                              </Typography>
                            </Box>
                          </Stack>
                          
                          <Stack alignItems="flex-end" spacing={1}>
                            <Typography variant="h6" fontWeight="bold">
                              ¥{dept.totalAmount.toLocaleString()}
                            </Typography>
                            <Stack direction="row" alignItems="center" spacing={1}>
                              <Chip
                                size="small"
                                icon={dept.trend > 0 ? <TrendingUpIcon /> : <TrendingDownIcon />}
                                label={`${dept.trend > 0 ? '+' : ''}${dept.trend}%`}
                                color={dept.trend > 0 ? 'success' : 'error'}
                                variant="outlined"
                              />
                            </Stack>
                          </Stack>
                        </Stack>
                        
                        <Box sx={{ mt: 2 }}>
                          <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 1 }}>
                            <Typography variant="caption" color="text.secondary">
                              効率スコア
                            </Typography>
                            <Typography variant="caption" fontWeight="bold">
                              {dept.efficiency}%
                            </Typography>
                          </Stack>
                          <LinearProgress
                            variant="determinate"
                            value={dept.efficiency}
                            sx={{
                              height: 6,
                              borderRadius: 3,
                              bgcolor: 'rgba(255, 255, 255, 0.1)',
                              '& .MuiLinearProgress-bar': {
                                borderRadius: 3,
                                bgcolor: dept.efficiency > 85 ? 'success.main' : 'warning.main',
                              },
                            }}
                          />
                        </Box>
                      </Box>
                    </motion.div>
                  ))}
                </Stack>
              )}
            </GlassCardContent>
          </GlassCard>
        </Grid>

        {/* Charts */}
        <Grid item xs={12} md={6}>
          <GlassCard>
            <GlassCardContent>
              <Typography variant="h6" gutterBottom fontWeight="bold">
                {viewType === 'users' ? 'ユーザー別支出グラフ' : '部門比較レーダーチャート'}
              </Typography>
              <Box sx={{ height: 350 }}>
                {viewType === 'users' ? (
                  <Bar data={userChartData} options={chartOptions} />
                ) : (
                  <Radar data={departmentRadarData} options={chartOptions} />
                )}
              </Box>
            </GlassCardContent>
          </GlassCard>
        </Grid>

        {/* Detailed Table */}
        <Grid item xs={12}>
          <GlassCard>
            <GlassCardContent>
              <Typography variant="h6" gutterBottom fontWeight="bold">
                {viewType === 'users' ? '詳細ユーザー分析' : '詳細部門分析'}
              </Typography>
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      {viewType === 'users' ? (
                        <>
                          <TableCell>ランク</TableCell>
                          <TableCell>ユーザー</TableCell>
                          <TableCell>部門</TableCell>
                          <TableCell align="right">支出額</TableCell>
                          <TableCell align="right">取引数</TableCell>
                          <TableCell align="right">効率</TableCell>
                          <TableCell align="right">前期比</TableCell>
                        </>
                      ) : (
                        <>
                          <TableCell>部門</TableCell>
                          <TableCell align="right">総支出</TableCell>
                          <TableCell align="right">ユーザー数</TableCell>
                          <TableCell align="right">平均支出</TableCell>
                          <TableCell align="right">効率</TableCell>
                          <TableCell align="right">成長率</TableCell>
                        </>
                      )}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {viewType === 'users' ? (
                      userRankings.map((user) => (
                        <TableRow key={user.id}>
                          <TableCell>
                            <Stack direction="row" alignItems="center" spacing={1}>
                              <Typography fontWeight="bold">#{user.rank}</Typography>
                              {user.badge && getBadgeIcon(user.badge)}
                            </Stack>
                          </TableCell>
                          <TableCell>
                            <Stack direction="row" alignItems="center" spacing={2}>
                              <Avatar sx={{ width: 32, height: 32 }}>
                                {user.name.charAt(0)}
                              </Avatar>
                              <Typography>{user.name}</Typography>
                            </Stack>
                          </TableCell>
                          <TableCell>{user.department}</TableCell>
                          <TableCell align="right">¥{user.amount.toLocaleString()}</TableCell>
                          <TableCell align="right">{user.transactions}</TableCell>
                          <TableCell align="right">{user.efficiency}%</TableCell>
                          <TableCell align="right">
                            <Chip
                              size="small"
                              label={`${user.trend > 0 ? '+' : ''}${user.trend}%`}
                              color={user.trend > 0 ? 'success' : 'error'}
                              variant="outlined"
                            />
                          </TableCell>
                        </TableRow>
                      ))
                    ) : (
                      departmentData.map((dept) => (
                        <TableRow key={dept.name}>
                          <TableCell>
                            <Stack direction="row" alignItems="center" spacing={2}>
                              <Avatar sx={{ width: 32, height: 32 }}>
                                <BusinessIcon />
                              </Avatar>
                              <Typography>{dept.name}</Typography>
                            </Stack>
                          </TableCell>
                          <TableCell align="right">¥{dept.totalAmount.toLocaleString()}</TableCell>
                          <TableCell align="right">{dept.userCount}名</TableCell>
                          <TableCell align="right">¥{dept.avgAmount.toLocaleString()}</TableCell>
                          <TableCell align="right">{dept.efficiency}%</TableCell>
                          <TableCell align="right">
                            <Chip
                              size="small"
                              label={`${dept.trend > 0 ? '+' : ''}${dept.trend}%`}
                              color={dept.trend > 0 ? 'success' : 'error'}
                              variant="outlined"
                            />
                          </TableCell>
                        </TableRow>
                      ))
                    )}
                  </TableBody>
                </Table>
              </TableContainer>
            </GlassCardContent>
          </GlassCard>
        </Grid>
      </Grid>
    </Box>
  );
};

export default UserRanking;
</file>

<file path="src/components/common/FilePreviewDialog.js">
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  IconButton,
  Box,
  Typography,
  Stack,
  CircularProgress,
  Alert,
} from '@mui/material';
import {
  Close as CloseIcon,
  AttachFile as AttachIcon,
} from '@mui/icons-material';
import fileService from '../../services/fileService';

const FilePreviewDialog = ({ open, onClose, fileIds = [] }) => {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    if (open && fileIds.length > 0) {
      loadFiles();
    }
  }, [open, fileIds]);

  const loadFiles = async () => {
    setLoading(true);
    setError('');
    
    try {
      const result = await fileService.getFilesByIds(fileIds);
      if (result.success) {
        setFiles(result.data);
        setCurrentIndex(0);
      } else {
        setError(result.error || 'ファイルの読み込みに失敗しました');
      }
    } catch (error) {
      console.error('Error loading files:', error);
      setError('ファイルの読み込み中にエラーが発生しました');
    } finally {
      setLoading(false);
    }
  };

  const currentFile = files[currentIndex];

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowLeft' && currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    } else if (e.key === 'ArrowRight' && currentIndex < files.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="md"
      fullWidth
      onKeyDown={handleKeyDown}
    >
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Box>
          {currentFile?.originalName || 'ファイルプレビュー'}
          {files.length > 1 && (
            <Typography variant="caption" sx={{ ml: 2 }}>
              ({currentIndex + 1} / {files.length})
            </Typography>
          )}
        </Box>
        <IconButton onClick={onClose}>
          <CloseIcon />
        </IconButton>
      </DialogTitle>
      <DialogContent>
        {loading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
            <CircularProgress />
          </Box>
        )}
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        
        {!loading && !error && currentFile && (
          <Box sx={{ textAlign: 'center' }}>
            {fileService.isImageFile(currentFile.mimeType) ? (
              <img
                src={currentFile.data}
                alt={currentFile.originalName}
                style={{
                  maxWidth: '100%',
                  maxHeight: '70vh',
                  objectFit: 'contain'
                }}
              />
            ) : (
              <Box sx={{ py: 4 }}>
                <AttachIcon sx={{ fontSize: 64, color: 'grey.400', mb: 2 }} />
                <Typography>プレビューできません</Typography>
              </Box>
            )}
            
            <Stack spacing={1} sx={{ mt: 2 }}>
              <Typography variant="body2" color="text.secondary">
                ファイルサイズ: {fileService.formatFileSize(currentFile.size)}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                アップロード日時: {new Date(currentFile.uploadedAt).toLocaleString('ja-JP')}
              </Typography>
              {currentFile.description && (
                <Typography variant="body2">
                  説明: {currentFile.description}
                </Typography>
              )}
            </Stack>
            
            {files.length > 1 && (
              <Stack direction="row" spacing={2} justifyContent="center" sx={{ mt: 2 }}>
                <Typography variant="caption" color="text.secondary">
                  ← → キーで画像を切り替え
                </Typography>
              </Stack>
            )}
          </Box>
        )}
      </DialogContent>
    </Dialog>
  );
};

export default FilePreviewDialog;
</file>

<file path="src/components/common/GlassCard.js">
import React from 'react';
import { Card, CardContent, Box, useTheme, alpha } from '@mui/material';
import { motion } from 'framer-motion';

const GlassCard = ({ 
  children, 
  gradient,
  hover = true,
  blur = 20,
  opacity = 0.25,
  borderOpacity = 0.18,
  shadowColor = 'primary',
  elevation = 1,
  animateOnHover = true,
  initialAnimation = true,
  delay = 0,
  ...props 
}) => {
  const theme = useTheme();
  
  const getGradientBackground = () => {
    if (gradient) {
      return gradient;
    }
    return null;
  };

  const getShadowColor = () => {
    const colorMap = {
      primary: theme.palette.primary.main,
      secondary: theme.palette.secondary.main,
      success: theme.palette.success.main,
      error: theme.palette.error.main,
      warning: theme.palette.warning.main,
    };
    return colorMap[shadowColor] || shadowColor;
  };

  const cardVariants = {
    hidden: { 
      opacity: 0, 
      y: 20,
      scale: 0.95,
    },
    visible: { 
      opacity: 1, 
      y: 0,
      scale: 1,
      transition: {
        delay: delay,
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  const hoverVariants = {
    rest: {
      scale: 1,
      y: 0,
    },
    hover: {
      scale: 1.02,
      y: -4,
      transition: {
        duration: 0.3,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  return (
    <motion.div
      initial={initialAnimation ? "hidden" : false}
      animate="visible"
      variants={cardVariants}
      whileHover={animateOnHover && hover ? "hover" : "rest"}
      {...(animateOnHover && hover ? { variants: hoverVariants } : {})}
    >
      <Card
        {...props}
        sx={{
          position: 'relative',
          background: theme.palette.mode === 'dark' 
            ? alpha(theme.palette.background.paper, opacity)
            : alpha('#ffffff', opacity),
          backdropFilter: `blur(${blur}px)`,
          WebkitBackdropFilter: `blur(${blur}px)`,
          border: `1px solid ${alpha(
            theme.palette.mode === 'dark' ? '#ffffff' : theme.palette.divider, 
            borderOpacity
          )}`,
          borderRadius: 3,
          overflow: 'hidden',
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
          boxShadow: hover 
            ? `0 ${4 * elevation}px ${16 * elevation}px 0 ${alpha(getShadowColor(), 0.1 * elevation)}`
            : theme.shadows[elevation],
          '&::before': gradient ? {
            content: '""',
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: getGradientBackground(),
            opacity: 0.05,
            transition: 'opacity 0.3s ease',
            pointerEvents: 'none',
          } : {},
          '&::after': {
            content: '""',
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            height: '1px',
            background: `linear-gradient(90deg, 
              transparent, 
              ${alpha(theme.palette.common.white, 0.5)}, 
              transparent
            )`,
            opacity: theme.palette.mode === 'dark' ? 0.3 : 0.1,
            pointerEvents: 'none',
          },
          ...(hover && {
            '&:hover': {
              borderColor: alpha(
                theme.palette.mode === 'dark' ? '#ffffff' : theme.palette.primary.main, 
                0.3
              ),
              boxShadow: `0 ${8 * elevation}px ${32 * elevation}px 0 ${alpha(
                getShadowColor(), 
                0.15 * elevation
              )}`,
              '&::before': gradient ? {
                opacity: 0.1,
              } : {},
            },
          }),
          ...props.sx,
        }}
      >
        {/* Animated gradient overlay */}
        {gradient && (
          <Box
            sx={{
              position: 'absolute',
              top: '-50%',
              left: '-50%',
              width: '200%',
              height: '200%',
              background: gradient,
              opacity: 0,
              transform: 'rotate(45deg)',
              transition: 'all 0.6s ease',
              pointerEvents: 'none',
              ...(hover && {
                '&:hover': {
                  opacity: 0.03,
                  transform: 'rotate(45deg) scale(1.5)',
                },
              }),
            }}
          />
        )}
        
        {/* Shine effect */}
        <Box
          className="shine-effect"
          sx={{
            position: 'absolute',
            top: 0,
            left: '-100%',
            width: '100%',
            height: '100%',
            background: `linear-gradient(
              90deg,
              transparent,
              ${alpha(theme.palette.common.white, 0.2)},
              transparent
            )`,
            transform: 'skewX(-20deg)',
            transition: 'left 0.6s ease',
            pointerEvents: 'none',
            ...(hover && {
              '&:hover': {
                left: '100%',
              },
            }),
          }}
        />

        {/* Content wrapper with proper z-index */}
        <Box sx={{ position: 'relative', zIndex: 1 }}>
          {children}
        </Box>
      </Card>
    </motion.div>
  );
};

// Preset variants for common use cases
export const GlassCardPresets = {
  primary: {
    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    shadowColor: 'primary',
  },
  secondary: {
    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
    shadowColor: 'secondary',
  },
  success: {
    gradient: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
    shadowColor: 'success',
  },
  warning: {
    gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
    shadowColor: 'warning',
  },
  info: {
    gradient: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
    shadowColor: 'primary',
  },
  dark: {
    gradient: 'linear-gradient(135deg, #232526 0%, #414345 100%)',
    shadowColor: '#000000',
  },
};

// Utility component for glass card content with padding
export const GlassCardContent = ({ children, noPadding = false, ...props }) => {
  return (
    <CardContent
      {...props}
      sx={{
        padding: noPadding ? 0 : 3,
        '&:last-child': {
          paddingBottom: noPadding ? 0 : 3,
        },
        ...props.sx,
      }}
    >
      {children}
    </CardContent>
  );
};

export default GlassCard;
</file>

<file path="src/components/Layout/Layout.js">
import React, { useState } from 'react';
import { 
  Box, 
  Drawer, 
  AppBar, 
  Toolbar, 
  List, 
  Typography, 
  Divider, 
  IconButton, 
  ListItem, 
  ListItemButton, 
  ListItemIcon, 
  ListItemText,
  useTheme,
  alpha,
  Collapse,
  Avatar,
  Fade,
  Zoom,
} from '@mui/material';
import {
  Menu as MenuIcon,
  Dashboard as DashboardIcon,
  AddCircleOutline as AddIcon,
  Analytics as AnalyticsIcon,
  Settings as SettingsIcon,
  Receipt as ReceiptIcon,
  People as PeopleIcon,
  AttachMoney as MoneyIcon,
  TrendingUp as TrendingUpIcon,
  AccountBalance as AccountBalanceIcon,
  ChevronLeft as ChevronLeftIcon,
  KeyboardArrowDown as KeyboardArrowDownIcon,
  Brightness4 as DarkModeIcon,
  Brightness7 as LightModeIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';

const drawerWidth = 280;
const collapsedWidth = 80;

// Animated list item wrapper
const MotionListItem = motion(ListItem);

const menuItems = [
  { 
    text: 'ダッシュボード', 
    icon: <DashboardIcon />, 
    path: '/dashboard',
    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
  },
  { 
    text: '収支登録', 
    icon: <AddIcon />, 
    path: '/register',
    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
    subItems: [
      { text: '収入登録', icon: <TrendingUpIcon />, path: '/register/income' },
      { text: '支出登録', icon: <MoneyIcon />, path: '/register/expense' },
    ],
  },
  { 
    text: '取引先・ユーザー', 
    icon: <PeopleIcon />, 
    path: '/users',
    gradient: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
  },
  { 
    text: 'レシート管理', 
    icon: <ReceiptIcon />, 
    path: '/receipts',
    gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
  },
  { 
    text: '分析', 
    icon: <AnalyticsIcon />, 
    path: '/analytics',
    gradient: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
  },
  { 
    text: '設定', 
    icon: <SettingsIcon />, 
    path: '/settings',
    gradient: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
  },
];

const Layout = ({ children, themeMode, toggleTheme }) => {
  const theme = useTheme();
  const [open, setOpen] = useState(true);
  const [selectedPath, setSelectedPath] = useState('/dashboard');
  const [expandedItems, setExpandedItems] = useState({});

  const handleDrawerToggle = () => {
    setOpen(!open);
  };

  const handleMenuClick = (path) => {
    setSelectedPath(path);
  };

  const handleExpandClick = (text) => {
    setExpandedItems(prev => ({
      ...prev,
      [text]: !prev[text],
    }));
  };

  const sidebarVariants = {
    open: { width: drawerWidth },
    closed: { width: collapsedWidth },
  };

  const listItemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: (i) => ({
      opacity: 1,
      x: 0,
      transition: {
        delay: i * 0.1,
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    }),
  };

  return (
    <Box sx={{ display: 'flex', minHeight: '100vh' }}>
      {/* App Bar */}
      <AppBar 
        position="fixed" 
        sx={{ 
          zIndex: (theme) => theme.zIndex.drawer + 1,
          backgroundColor: alpha(theme.palette.background.paper, 0.8),
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          borderBottom: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
          boxShadow: 'none',
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="toggle drawer"
            onClick={handleDrawerToggle}
            edge="start"
            sx={{ 
              mr: 2,
              color: theme.palette.text.primary,
              transition: 'all 0.3s ease',
              '&:hover': {
                transform: 'scale(1.1)',
              },
            }}
          >
            {open ? <ChevronLeftIcon /> : <MenuIcon />}
          </IconButton>
          
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ type: "spring", stiffness: 260, damping: 20 }}
            >
              <AccountBalanceIcon 
                sx={{ 
                  fontSize: 32,
                  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                }}
              />
            </motion.div>
            <Typography 
              variant="h6" 
              noWrap 
              component="div"
              sx={{
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                fontWeight: 700,
                letterSpacing: '-0.02em',
              }}
            >
              ExpenceAtture
            </Typography>
          </Box>

          <Box sx={{ flexGrow: 1 }} />

          <IconButton 
            onClick={toggleTheme} 
            color="inherit"
            sx={{
              color: theme.palette.text.primary,
              transition: 'all 0.3s ease',
              '&:hover': {
                transform: 'rotate(180deg)',
              },
            }}
          >
            {themeMode === 'dark' ? <LightModeIcon /> : <DarkModeIcon />}
          </IconButton>

          <Avatar
            sx={{
              ml: 2,
              width: 40,
              height: 40,
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              boxShadow: '0 4px 20px 0 rgba(102, 126, 234, 0.4)',
              cursor: 'pointer',
              transition: 'all 0.3s ease',
              '&:hover': {
                transform: 'scale(1.05)',
                boxShadow: '0 6px 30px 0 rgba(102, 126, 234, 0.6)',
              },
            }}
          >
            A
          </Avatar>
        </Toolbar>
      </AppBar>

      {/* Sidebar Drawer */}
      <motion.div
        initial={false}
        animate={open ? "open" : "closed"}
        variants={sidebarVariants}
        transition={{ duration: 0.3, ease: [0.4, 0, 0.2, 1] }}
      >
        <Drawer
          variant="permanent"
          sx={{
            width: open ? drawerWidth : collapsedWidth,
            flexShrink: 0,
            '& .MuiDrawer-paper': {
              width: open ? drawerWidth : collapsedWidth,
              boxSizing: 'border-box',
              backgroundColor: alpha(theme.palette.background.paper, 0.8),
              backdropFilter: 'blur(20px)',
              WebkitBackdropFilter: 'blur(20px)',
              borderRight: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
              transition: 'width 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
              overflowX: 'hidden',
            },
          }}
        >
          <Toolbar />
          <Box sx={{ overflow: 'auto', mt: 2 }}>
            <List>
              {menuItems.map((item, index) => (
                <Box key={item.text}>
                  <MotionListItem 
                    disablePadding 
                    sx={{ display: 'block' }}
                    custom={index}
                    initial="hidden"
                    animate="visible"
                    variants={listItemVariants}
                  >
                    <ListItemButton
                      selected={selectedPath === item.path}
                      onClick={() => {
                        handleMenuClick(item.path);
                        if (item.subItems) {
                          handleExpandClick(item.text);
                        }
                      }}
                      sx={{
                        minHeight: 56,
                        justifyContent: open ? 'initial' : 'center',
                        px: 2.5,
                        borderRadius: 2,
                        mx: 1,
                        my: 0.5,
                        position: 'relative',
                        overflow: 'hidden',
                        transition: 'all 0.3s ease',
                        '&::before': {
                          content: '""',
                          position: 'absolute',
                          top: 0,
                          left: 0,
                          right: 0,
                          bottom: 0,
                          background: item.gradient,
                          opacity: 0,
                          transition: 'opacity 0.3s ease',
                        },
                        '&.Mui-selected': {
                          backgroundColor: 'transparent',
                          '&::before': {
                            opacity: 0.1,
                          },
                          '& .MuiListItemIcon-root': {
                            color: theme.palette.primary.main,
                            transform: 'scale(1.1)',
                          },
                        },
                        '&:hover': {
                          backgroundColor: 'transparent',
                          '&::before': {
                            opacity: 0.08,
                          },
                          transform: 'translateX(4px)',
                        },
                      }}
                    >
                      <ListItemIcon
                        sx={{
                          minWidth: 0,
                          mr: open ? 3 : 'auto',
                          justifyContent: 'center',
                          color: selectedPath === item.path ? theme.palette.primary.main : theme.palette.text.secondary,
                          transition: 'all 0.3s ease',
                        }}
                      >
                        <motion.div
                          whileHover={{ rotate: 360 }}
                          transition={{ duration: 0.5 }}
                        >
                          {item.icon}
                        </motion.div>
                      </ListItemIcon>
                      <ListItemText 
                        primary={item.text} 
                        sx={{ 
                          opacity: open ? 1 : 0,
                          transition: 'opacity 0.3s ease',
                        }} 
                      />
                      {item.subItems && open && (
                        <KeyboardArrowDownIcon
                          sx={{
                            transform: expandedItems[item.text] ? 'rotate(180deg)' : 'rotate(0deg)',
                            transition: 'transform 0.3s ease',
                          }}
                        />
                      )}
                    </ListItemButton>
                  </MotionListItem>

                  {/* Sub Items */}
                  {item.subItems && (
                    <Collapse in={expandedItems[item.text] && open} timeout="auto" unmountOnExit>
                      <List component="div" disablePadding>
                        {item.subItems.map((subItem) => (
                          <ListItemButton
                            key={subItem.text}
                            selected={selectedPath === subItem.path}
                            onClick={() => handleMenuClick(subItem.path)}
                            sx={{
                              pl: 4,
                              minHeight: 48,
                              borderRadius: 2,
                              mx: 1,
                              my: 0.25,
                              transition: 'all 0.3s ease',
                              '&.Mui-selected': {
                                backgroundColor: alpha(theme.palette.primary.main, 0.08),
                              },
                              '&:hover': {
                                backgroundColor: alpha(theme.palette.primary.main, 0.04),
                                transform: 'translateX(4px)',
                              },
                            }}
                          >
                            <ListItemIcon sx={{ minWidth: 40 }}>
                              {subItem.icon}
                            </ListItemIcon>
                            <ListItemText 
                              primary={subItem.text}
                              primaryTypographyProps={{
                                fontSize: '0.875rem',
                              }}
                            />
                          </ListItemButton>
                        ))}
                      </List>
                    </Collapse>
                  )}
                </Box>
              ))}
            </List>
          </Box>
        </Drawer>
      </motion.div>

      {/* Main Content */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          mt: 8,
          background: theme.palette.mode === 'dark' 
            ? 'linear-gradient(135deg, #1e293b 0%, #334155 100%)'
            : 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
          minHeight: '100vh',
          position: 'relative',
          '&::before': {
            content: '""',
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: `radial-gradient(circle at 20% 80%, ${alpha(theme.palette.primary.main, 0.05)} 0%, transparent 50%)`,
            pointerEvents: 'none',
          },
          '&::after': {
            content: '""',
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: `radial-gradient(circle at 80% 20%, ${alpha(theme.palette.secondary.main, 0.05)} 0%, transparent 50%)`,
            pointerEvents: 'none',
          },
        }}
      >
        <AnimatePresence mode="wait">
          <motion.div
            key={selectedPath}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.3, ease: [0.4, 0, 0.2, 1] }}
          >
            {children}
          </motion.div>
        </AnimatePresence>
      </Box>
    </Box>
  );
};

export default Layout;
</file>

<file path="src/components/Navigation/Sidebar.js">
import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import {
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Collapse,
  IconButton,
  Box,
  Typography,
  Avatar,
  Chip,
  useTheme,
  alpha,
  Tooltip,
} from '@mui/material';
import {
  Dashboard as DashboardIcon,
  Add as AddIcon,
  Analytics as AnalyticsIcon,
  Settings as SettingsIcon,
  People as PeopleIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  KeyboardArrowRight as ExpandLessIcon,
  AccountBalance as AccountBalanceIcon,
  ChevronLeft as ChevronLeftIcon,
  Menu as MenuIcon,
  Brightness4 as DarkModeIcon,
  Brightness7 as LightModeIcon,
  Receipt as TransactionIcon,
  Delete as TrashIcon,
  Receipt as ReceiptIcon,
  Notifications as NotificationsIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';

const drawerWidth = 280;
const collapsedWidth = 80;

// Animated list item wrapper
const MotionListItem = motion(ListItem);
const MotionListItemButton = motion(ListItemButton);

const menuItems = [
  {
    text: 'ダッシュボード',
    icon: <DashboardIcon />,
    path: '/',
    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    description: '収支概要とグラフ',
  },
  {
    text: '収支登録',
    icon: <AddIcon />,
    path: '/registration',
    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
    description: '経費・収入の登録',
    subItems: [
      {
        text: '支出登録',
        icon: <TrendingDownIcon />,
        path: '/registration?tab=expense',
        description: '経費の登録',
      },
      {
        text: '収入登録',
        icon: <TrendingUpIcon />,
        path: '/registration?tab=income',
        description: '収入の登録',
      },
    ],
  },
  {
    text: '取引履歴',
    icon: <TransactionIcon />,
    path: '/transactions',
    gradient: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
    description: '収支の一覧と検索',
  },
  {
    text: 'ユーザー管理',
    icon: <PeopleIcon />,
    path: '/users',
    gradient: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
    description: '関係者の管理',
  },
  {
    text: '分析・レポート',
    icon: <AnalyticsIcon />,
    path: '/analytics',
    gradient: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
    description: 'データ分析と可視化',
  },
  {
    text: '請求書管理',
    icon: <ReceiptIcon />,
    path: '/invoices',
    gradient: 'linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%)',
    description: '請求書の作成・管理',
  },
  {
    text: '通知',
    icon: <NotificationsIcon />,
    path: '/notifications',
    gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
    description: '期日通知とお知らせ',
  },
  {
    text: 'ゴミ箱',
    icon: <TrashIcon />,
    path: '/trash',
    gradient: 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
    description: '削除したデータの管理',
  },
  {
    text: '設定',
    icon: <SettingsIcon />,
    path: '/settings',
    gradient: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
    description: 'アプリケーション設定',
  },
];

const Sidebar = ({ open, onToggle, themeMode, onToggleTheme }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const location = useLocation();
  const [expandedItems, setExpandedItems] = useState({});

  const handleMenuClick = (path, hasSubItems = false, itemText = '') => {
    if (hasSubItems && open) {
      // Only expand/collapse when sidebar is open
      setExpandedItems(prev => ({
        ...prev,
        [itemText]: !prev[itemText],
      }));
    } else {
      navigate(path);
    }
  };

  const isActivePath = (path) => {
    if (path === '/') {
      return location.pathname === '/';
    }
    return location.pathname.startsWith(path);
  };

  const sidebarVariants = {
    open: {
      width: drawerWidth,
      transition: {
        duration: 0.3,
        ease: [0.4, 0, 0.2, 1],
      },
    },
    closed: {
      width: collapsedWidth,
      transition: {
        duration: 0.3,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  const listItemVariants = {
    hidden: {
      opacity: 0,
      x: -20,
    },
    visible: (i) => ({
      opacity: 1,
      x: 0,
      transition: {
        delay: i * 0.1,
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    }),
    hover: {
      x: 8,
      transition: {
        duration: 0.2,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  const iconVariants = {
    rest: { rotate: 0 },
    hover: { rotate: 360, transition: { duration: 0.5 } },
  };

  const expandIconVariants = {
    collapsed: { rotate: 0 },
    expanded: { rotate: 90 },
  };

  return (
    <>
      {/* Backdrop for mobile */}
      {open && (
        <Box
          sx={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: 1200,
            display: { md: 'none' },
          }}
          onClick={onToggle}
        />
      )}

      <motion.div
        initial={false}
        animate={open ? 'open' : 'closed'}
        variants={sidebarVariants}
        style={{ zIndex: 1300 }}
      >
        <Drawer
          variant="permanent"
          sx={{
            width: open ? drawerWidth : collapsedWidth,
            flexShrink: 0,
            '& .MuiDrawer-paper': {
              width: open ? drawerWidth : collapsedWidth,
              boxSizing: 'border-box',
              backgroundColor: alpha(theme.palette.background.paper, 0.9),
              backdropFilter: 'blur(20px)',
              WebkitBackdropFilter: 'blur(20px)',
              borderRight: `1px solid ${alpha(theme.palette.divider, 0.12)}`,
              transition: 'width 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
              overflowX: 'hidden',
              overflowY: 'auto',
              position: 'fixed',
              left: 0,
              top: 0,
              bottom: 0,
              boxShadow: open
                ? '8px 0 32px rgba(0, 0, 0, 0.12)'
                : '4px 0 16px rgba(0, 0, 0, 0.08)',
            },
          }}
        >
          {/* Header */}
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              p: 2,
              minHeight: 64,
              borderBottom: `1px solid ${alpha(theme.palette.divider, 0.12)}`,
            }}
          >
            <AnimatePresence>
              {open && (
                <motion.div
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: -20 }}
                  transition={{ duration: 0.2 }}
                  style={{ display: 'flex', alignItems: 'center', gap: 12 }}
                >
                  <motion.div
                    initial={{ scale: 0 }}
                    animate={{ scale: 1 }}
                    transition={{ type: 'spring', stiffness: 260, damping: 20 }}
                  >
                    <AccountBalanceIcon
                      sx={{
                        fontSize: 32,
                        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                        WebkitBackgroundClip: 'text',
                        WebkitTextFillColor: 'transparent',
                      }}
                    />
                  </motion.div>
                  <Typography
                    variant="h6"
                    noWrap
                    sx={{
                      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                      WebkitBackgroundClip: 'text',
                      WebkitTextFillColor: 'transparent',
                      fontWeight: 700,
                      letterSpacing: '-0.02em',
                    }}
                  >
                    ExpenceAtture
                  </Typography>
                </motion.div>
              )}
            </AnimatePresence>

            <IconButton
              onClick={onToggle}
              sx={{
                color: theme.palette.text.primary,
                transition: 'all 0.3s ease',
                '&:hover': {
                  transform: 'scale(1.1)',
                  backgroundColor: alpha(theme.palette.primary.main, 0.08),
                },
              }}
            >
              {open ? <ChevronLeftIcon /> : <MenuIcon />}
            </IconButton>
          </Box>

          {/* Navigation Items */}
          <Box sx={{ flex: 1, overflow: 'auto', py: 2 }}>
            <List>
              {menuItems.map((item, index) => (
                <Box key={item.text}>
                  <MotionListItem
                    disablePadding
                    sx={{ display: 'block' }}
                    custom={index}
                    initial="hidden"
                    animate="visible"
                    variants={listItemVariants}
                    whileHover="hover"
                  >
                    <Tooltip
                      title={!open ? item.description : ''}
                      placement="right"
                      arrow
                    >
                      <MotionListItemButton
                        selected={isActivePath(item.path)}
                        onClick={() =>
                          handleMenuClick(item.path, !!item.subItems, item.text)
                        }
                        sx={{
                          minHeight: 56,
                          justifyContent: open ? 'initial' : 'center',
                          px: 2.5,
                          borderRadius: 2,
                          mx: 1,
                          my: 0.5,
                          position: 'relative',
                          overflow: 'hidden',
                          transition: 'all 0.3s ease',
                          '&::before': {
                            content: '""',
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            background: item.gradient,
                            opacity: 0,
                            transition: 'opacity 0.3s ease',
                          },
                          '&.Mui-selected': {
                            backgroundColor: 'transparent',
                            '&::before': {
                              opacity: 0.12,
                            },
                            '& .MuiListItemIcon-root': {
                              color: theme.palette.primary.main,
                              transform: 'scale(1.1)',
                            },
                            '& .MuiListItemText-primary': {
                              color: theme.palette.primary.main,
                              fontWeight: 600,
                            },
                          },
                          '&:hover': {
                            backgroundColor: 'transparent',
                            '&::before': {
                              opacity: 0.08,
                            },
                          },
                        }}
                      >
                        <ListItemIcon
                          sx={{
                            minWidth: 0,
                            mr: open ? 3 : 'auto',
                            justifyContent: 'center',
                            color: isActivePath(item.path)
                              ? theme.palette.primary.main
                              : theme.palette.text.secondary,
                            transition: 'all 0.3s ease',
                          }}
                        >
                          <motion.div
                            variants={iconVariants}
                            initial="rest"
                            whileHover="hover"
                          >
                            {item.icon}
                          </motion.div>
                        </ListItemIcon>

                        <ListItemText
                          primary={item.text}
                          secondary={open ? item.description : ''}
                          sx={{
                            opacity: open ? 1 : 0,
                            transition: 'opacity 0.3s ease',
                            '& .MuiListItemText-primary': {
                              fontSize: '0.95rem',
                              fontWeight: isActivePath(item.path) ? 600 : 500,
                            },
                            '& .MuiListItemText-secondary': {
                              fontSize: '0.75rem',
                              opacity: 0.7,
                            },
                          }}
                        />

                        {item.subItems && open && (
                          <motion.div
                            variants={expandIconVariants}
                            animate={
                              expandedItems[item.text] ? 'expanded' : 'collapsed'
                            }
                            transition={{ duration: 0.2 }}
                          >
                            <ExpandLessIcon
                              sx={{
                                color: theme.palette.text.secondary,
                              }}
                            />
                          </motion.div>
                        )}

                        {/* Active indicator */}
                        {isActivePath(item.path) && (
                          <motion.div
                            initial={{ opacity: 0, scale: 0 }}
                            animate={{ opacity: 1, scale: 1 }}
                            style={{
                              position: 'absolute',
                              right: 8,
                              width: 4,
                              height: 32,
                              background: item.gradient,
                              borderRadius: 2,
                            }}
                          />
                        )}
                      </MotionListItemButton>
                    </Tooltip>
                  </MotionListItem>

                  {/* Sub Items */}
                  {item.subItems && (
                    <AnimatePresence>
                      {expandedItems[item.text] && open && (
                        <motion.div
                          initial={{ opacity: 0, height: 0 }}
                          animate={{ opacity: 1, height: 'auto' }}
                          exit={{ opacity: 0, height: 0 }}
                          transition={{ duration: 0.3 }}
                        >
                          <Collapse in={true} timeout="auto" unmountOnExit>
                            <List component="div" disablePadding>
                              {item.subItems.map((subItem, subIndex) => (
                                <motion.div
                                  key={subItem.text}
                                  initial={{ opacity: 0, x: -20 }}
                                  animate={{ opacity: 1, x: 0 }}
                                  transition={{
                                    delay: subIndex * 0.1,
                                    duration: 0.3,
                                  }}
                                >
                                  <ListItemButton
                                    selected={isActivePath(subItem.path)}
                                    onClick={() => handleMenuClick(subItem.path)}
                                    sx={{
                                      pl: 4,
                                      minHeight: 48,
                                      borderRadius: 2,
                                      mx: 1,
                                      my: 0.25,
                                      transition: 'all 0.3s ease',
                                      '&.Mui-selected': {
                                        backgroundColor: alpha(
                                          theme.palette.primary.main,
                                          0.08
                                        ),
                                        '& .MuiListItemIcon-root': {
                                          color: theme.palette.primary.main,
                                        },
                                        '& .MuiListItemText-primary': {
                                          color: theme.palette.primary.main,
                                          fontWeight: 600,
                                        },
                                      },
                                      '&:hover': {
                                        backgroundColor: alpha(
                                          theme.palette.primary.main,
                                          0.04
                                        ),
                                        transform: 'translateX(4px)',
                                      },
                                    }}
                                  >
                                    <ListItemIcon sx={{ minWidth: 40 }}>
                                      <motion.div
                                        whileHover={{ scale: 1.1 }}
                                        transition={{ duration: 0.2 }}
                                      >
                                        {subItem.icon}
                                      </motion.div>
                                    </ListItemIcon>
                                    <ListItemText
                                      primary={subItem.text}
                                      secondary={subItem.description}
                                      primaryTypographyProps={{
                                        fontSize: '0.875rem',
                                      }}
                                      secondaryTypographyProps={{
                                        fontSize: '0.75rem',
                                      }}
                                    />
                                  </ListItemButton>
                                </motion.div>
                              ))}
                            </List>
                          </Collapse>
                        </motion.div>
                      )}
                    </AnimatePresence>
                  )}
                </Box>
              ))}
            </List>
          </Box>

          {/* Footer */}
          <Box
            sx={{
              borderTop: `1px solid ${alpha(theme.palette.divider, 0.12)}`,
              p: 2,
            }}
          >
            {/* Theme Toggle */}
            <Box
              sx={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: open ? 'space-between' : 'center',
                mb: 2,
              }}
            >
              <AnimatePresence>
                {open && (
                  <motion.div
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -20 }}
                    transition={{ duration: 0.2 }}
                  >
                    <Typography variant="body2" color="text.secondary">
                      テーマ
                    </Typography>
                  </motion.div>
                )}
              </AnimatePresence>

              <Tooltip title={`${themeMode === 'dark' ? 'ライト' : 'ダーク'}モードに切替`} placement="top">
                <IconButton
                  onClick={onToggleTheme}
                  sx={{
                    color: theme.palette.text.primary,
                    transition: 'all 0.3s ease',
                    '&:hover': {
                      transform: 'rotate(180deg)',
                      backgroundColor: alpha(theme.palette.primary.main, 0.08),
                    },
                  }}
                >
                  {themeMode === 'dark' ? <LightModeIcon /> : <DarkModeIcon />}
                </IconButton>
              </Tooltip>
            </Box>

            {/* User Profile */}
            <motion.div
              whileHover={{ scale: 1.02 }}
              transition={{ duration: 0.2 }}
            >
              <Box
                sx={{
                  display: 'flex',
                  alignItems: 'center',
                  p: 1.5,
                  borderRadius: 2,
                  background: alpha(theme.palette.primary.main, 0.08),
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                  '&:hover': {
                    background: alpha(theme.palette.primary.main, 0.12),
                  },
                }}
              >
                <Avatar
                  sx={{
                    width: 36,
                    height: 36,
                    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    fontSize: '1rem',
                    fontWeight: 600,
                  }}
                >
                  A
                </Avatar>
                <AnimatePresence>
                  {open && (
                    <motion.div
                      initial={{ opacity: 0, x: -10 }}
                      animate={{ opacity: 1, x: 0 }}
                      exit={{ opacity: 0, x: -10 }}
                      transition={{ duration: 0.2 }}
                      style={{ marginLeft: 12, overflow: 'hidden' }}
                    >
                      <Typography variant="body2" fontWeight={600} noWrap>
                        管理者
                      </Typography>
                      <Chip
                        label="オンライン"
                        size="small"
                        color="success"
                        variant="outlined"
                        sx={{ fontSize: '0.7rem', height: 20 }}
                      />
                    </motion.div>
                  )}
                </AnimatePresence>
              </Box>
            </motion.div>
          </Box>
        </Drawer>
      </motion.div>
    </>
  );
};

export default Sidebar;
</file>

<file path="src/components/Registration/CategorySuggestion.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  Box,
  Typography,
  Button,
  Chip,
  Alert,
  CircularProgress,
  Divider,
} from '@mui/material';
import {
  Psychology as AiIcon,
  AutoAwesome as MagicIcon,
  CheckCircle as CheckIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { suggestCategory } from '../../services/aiService';

const CategorySuggestion = ({ 
  description,
  type = 'expense',
  onCategorySelect,
  availableCategories = []
}) => {
  const [loading, setLoading] = useState(false);
  const [suggestion, setSuggestion] = useState(null);
  const [error, setError] = useState(null);
  const debounceTimerRef = useRef(null);

  const getSuggestion = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await suggestCategory(description, type);
      if (result.success && result.suggestion) {
        // Parse the AI response to extract category information
        const suggestionText = result.suggestion;
        
        // Try to extract category name from the response
        const categoryMatch = suggestionText.match(/推奨カテゴリ[：:]\s*([^\n\r]+)/);
        const reasonMatch = suggestionText.match(/理由[：:]\s*([^\n\r]+)/);
        
        if (categoryMatch) {
          setSuggestion({
            category: categoryMatch[1].trim(),
            reasoning: reasonMatch ? reasonMatch[1].trim() : '',
            confidence: 0.8 // Default confidence
          });
        } else {
          // If pattern matching fails, try to use the raw suggestion as category name
          const cleanSuggestion = suggestionText.replace(/^[^\w\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+/, '').trim();
          if (cleanSuggestion) {
            setSuggestion({
              category: cleanSuggestion.split('\n')[0].trim(),
              reasoning: 'AI提案',
              confidence: 0.6
            });
          } else {
            setError('AI応答の解析に失敗しました');
          }
        }
      } else {
        setError(result.error || 'AI提案の取得に失敗しました');
      }
    } catch (err) {
      console.error('AI suggestion error:', err);
      setError('AI提案の取得に失敗しました');
    } finally {
      setLoading(false);
    }
  }, [description, type]);

  useEffect(() => {
    // Clear any existing timer
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    if (description && description.length > 3) {
      // Set a new timer to wait for 1.5 seconds of no typing
      debounceTimerRef.current = setTimeout(() => {
        getSuggestion();
      }, 1500);
    } else {
      setSuggestion(null);
      setError(null);
    }

    // Cleanup function to clear timer on unmount or dependency change
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, [description, type, getSuggestion]);

  const handleCategorySelect = (categoryId) => {
    onCategorySelect(categoryId);
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.3 }}
      >
        <Alert 
          severity="info" 
          icon={<CircularProgress size={20} />}
          sx={{ mb: 2 }}
        >
          <Typography variant="body2">
            AI がカテゴリを分析中...
          </Typography>
        </Alert>
      </motion.div>
    );
  }

  if (error) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.3 }}
      >
        <Alert severity="warning" sx={{ mb: 2 }}>
          <Typography variant="body2">
            {error}（手動でカテゴリを選択してください）
          </Typography>
        </Alert>
      </motion.div>
    );
  }

  if (!suggestion || !suggestion.category) {
    return null;
  }

  const matchedCategory = availableCategories.find(
    cat => cat.name && suggestion.category && cat.name.toLowerCase() === suggestion.category.toLowerCase()
  );

  return (
    <motion.div
      initial={{ opacity: 0, y: -10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <Alert 
        severity="info" 
        icon={<AiIcon />}
        sx={{ 
          mb: 2,
          background: 'linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%)',
          borderColor: 'primary.main'
        }}
      >
        <Box>
          <Typography variant="body2" fontWeight="medium" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <MagicIcon fontSize="small" />
            AI カテゴリ提案
          </Typography>
          
          <Typography variant="body2" sx={{ mb: 2 }}>
            <strong>"{description}"</strong> に最適なカテゴリ:
          </Typography>

          {matchedCategory ? (
            <Box sx={{ mb: 2 }}>
              <Button
                variant="contained"
                size="small"
                startIcon={<CheckIcon />}
                onClick={() => handleCategorySelect(matchedCategory.id)}
                sx={{
                  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  '&:hover': {
                    background: 'linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%)',
                  },
                  mr: 1
                }}
              >
                {matchedCategory.name}
              </Button>
              <Typography variant="caption" color="text.secondary" sx={{ ml: 1 }}>
                信頼度: {Math.round(suggestion.confidence * 100)}%
              </Typography>
            </Box>
          ) : (
            <Box sx={{ mb: 2 }}>
              <Chip 
                label={`${suggestion.category}（未登録カテゴリ）`}
                color="warning"
                variant="outlined"
                size="small"
              />
              <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mt: 1 }}>
                このカテゴリは未登録です。手動で近いカテゴリを選択してください。
              </Typography>
            </Box>
          )}

          {suggestion.reasoning && (
            <Box>
              <Divider sx={{ my: 1 }} />
              <Typography variant="caption" color="text.secondary">
                <strong>理由:</strong> {suggestion.reasoning}
              </Typography>
            </Box>
          )}
        </Box>
      </Alert>
    </motion.div>
  );
};

export default CategorySuggestion;
</file>

<file path="src/components/Registration/ExpenseForm.js">
import React, { useState, useEffect } from 'react';
import {
  TextField,
  Button,
  Stack,
  Box,
  Typography,
  Chip,
  FormControlLabel,
  Switch,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Divider,
  IconButton,
  InputAdornment,
  CircularProgress,
} from '@mui/material';
import {
  CalendarToday as CalendarIcon,
  AttachMoney as MoneyIcon,
  Category as CategoryIcon,
  Person as PersonIcon,
  Description as DescriptionIcon,
  Add as AddIcon,
  Save as SaveIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import CategorySuggestion from './CategorySuggestion';
import FileUpload from './FileUpload';
import OCRButton from './OCRButton';
import categoryService from '../../services/categoryService';
import userService from '../../services/userService';
import { learnFromSelection } from '../../services/aiService';

const ExpenseForm = ({ onSubmit }) => {
  const [formData, setFormData] = useState({
    date: new Date().toISOString().split('T')[0],
    amount: '',
    description: '',
    categoryId: '',
    userId: '',
    tags: [],
    memo: '',
    isAdvancePayment: false,
    files: [],
  });

  const [errors, setErrors] = useState({});
  const [currentTag, setCurrentTag] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [categories, setCategories] = useState([]);
  const [categoryHierarchy, setCategoryHierarchy] = useState([]);
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [showAiSuggestion, setShowAiSuggestion] = useState(false);

  // Load categories and users on component mount
  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        
        const [categoriesResult, usersResult] = await Promise.all([
          categoryService.getAllCategories(),
          userService.getAllUsers()
        ]);
        
        if (categoriesResult.success) {
          const expenseCategories = categoriesResult.data.filter(cat => cat.type === 'expense');
          setCategories(expenseCategories);
          
          // Organize categories into hierarchy
          const parentCategories = expenseCategories.filter(cat => !cat.parentId);
          const hierarchy = parentCategories.map(parent => ({
            ...parent,
            children: expenseCategories.filter(child => child.parentId === parent.id)
          }));
          setCategoryHierarchy(hierarchy);
        }
        
        if (usersResult.success) {
          setUsers(usersResult.data);
        }
        
      } catch (error) {
        console.error('Failed to load data:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadData();
  }, []);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Clear error for this field
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
    
    // Show AI suggestion when description changes
    if (name === 'description' && value.length > 3) {
      setShowAiSuggestion(true);
    }
  };

  const handleCategorySelect = (categoryId) => {
    setFormData(prev => ({
      ...prev,
      categoryId
    }));
    setShowAiSuggestion(false);
    if (errors.categoryId) {
      setErrors(prev => ({ ...prev, categoryId: '' }));
    }
  };

  const addTag = () => {
    if (currentTag.trim() && !formData.tags.includes(currentTag.trim())) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, currentTag.trim()]
      }));
      setCurrentTag('');
    }
  };

  const removeTag = (tagToRemove) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove)
    }));
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && currentTag.trim()) {
      e.preventDefault();
      addTag();
    }
  };

  // Handle OCR data extraction
  const handleOCRData = (ocrData) => {
    setFormData(prev => ({
      ...prev,
      amount: ocrData.amount ? ocrData.amount.toString() : prev.amount,
      date: ocrData.date || prev.date,
      description: ocrData.vendor || prev.description,
    }));

    // Try to find matching category
    if (ocrData.category) {
      const matchingCategory = categories.find(cat => 
        cat.name.toLowerCase().includes(ocrData.category.toLowerCase())
      );
      if (matchingCategory) {
        setFormData(prev => ({ ...prev, categoryId: matchingCategory.id }));
      }
    }

    // Add items as tags if found
    if (ocrData.items && ocrData.items.length > 0) {
      const itemTags = ocrData.items.slice(0, 3).map(item => item.name);
      setFormData(prev => ({ ...prev, tags: [...prev.tags, ...itemTags] }));
    }

    setErrors({ success: 'レシートのデータを適用しました。内容を確認してください。' });
  };

  const validateForm = () => {
    const newErrors = {};
    
    if (!formData.amount || parseFloat(formData.amount) <= 0) {
      newErrors.amount = '有効な金額を入力してください';
    }
    
    if (!formData.description.trim()) {
      newErrors.description = '説明を入力してください';
    }
    
    if (!formData.categoryId) {
      newErrors.categoryId = 'カテゴリを選択してください';
    }
    
    if (!formData.userId) {
      newErrors.userId = 'ユーザーを選択してください';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    setIsSubmitting(true);
    
    try {
      // Learn from user's category selection
      const selectedCategory = categories.find(cat => cat.id === formData.categoryId);
      if (selectedCategory) {
        learnFromSelection(formData.description, selectedCategory.name, 'expense');
      }

      // Submit the data to parent component
      await onSubmit({
        type: 'expense',
        ...formData,
        amount: parseFloat(formData.amount),
        fileIds: formData.files.map(f => f.id)
      });
      
      // Reset form
      setFormData({
        date: new Date().toISOString().split('T')[0],
        amount: '',
        description: '',
        categoryId: '',
        userId: '',
        tags: [],
        memo: '',
        isAdvancePayment: false,
        files: [],
      });
      
      setShowAiSuggestion(false);
      
    } catch (error) {
      console.error('Error submitting expense:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <Box component="form" onSubmit={handleSubmit}>
        {/* OCR Button Row */}
        <Box sx={{ mb: 3, display: 'flex', justifyContent: 'flex-end' }}>
          <OCRButton onDataExtracted={handleOCRData} />
        </Box>
        
        <Stack spacing={3}>
          {/* Date and Amount Row */}
          <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
            <TextField
              label="日付"
              type="date"
              name="date"
              value={formData.date}
              onChange={handleInputChange}
              fullWidth
              required
              InputLabelProps={{ shrink: true }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <CalendarIcon />
                  </InputAdornment>
                ),
              }}
            />
            
            <TextField
              label="金額"
              type="number"
              name="amount"
              value={formData.amount}
              onChange={handleInputChange}
              fullWidth
              required
              error={!!errors.amount}
              helperText={errors.amount}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <MoneyIcon />
                  </InputAdornment>
                ),
                endAdornment: <InputAdornment position="end">円</InputAdornment>,
              }}
            />
          </Stack>

          {/* Description */}
          <TextField
            label="説明"
            name="description"
            value={formData.description}
            onChange={handleInputChange}
            fullWidth
            required
            multiline
            rows={2}
            error={!!errors.description}
            helperText={errors.description || "4文字以上入力するとAIがカテゴリを提案します"}
            placeholder="支出の詳細を入力してください（例：コンビニで昼食購入）..."
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <DescriptionIcon />
                </InputAdornment>
              ),
            }}
          />

          {/* AI Category Suggestion */}
          <AnimatePresence>
            {showAiSuggestion && formData.description.length > 3 && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.3 }}
              >
                <CategorySuggestion
                  description={formData.description}
                  type="expense"
                  onCategorySelect={handleCategorySelect}
                  availableCategories={categories}
                />
              </motion.div>
            )}
          </AnimatePresence>

          {/* Category and User Selection */}
          <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
            <FormControl fullWidth required error={!!errors.categoryId}>
              <InputLabel>カテゴリ</InputLabel>
              <Select
                name="categoryId"
                value={formData.categoryId}
                label="カテゴリ"
                onChange={handleInputChange}
                startAdornment={
                  <InputAdornment position="start">
                    <CategoryIcon />
                  </InputAdornment>
                }
              >
                {categoryHierarchy.map((parentCategory) => [
                  // Parent category (disabled, just for grouping)
                  <MenuItem key={`parent-${parentCategory.id}`} disabled sx={{ fontWeight: 'bold', backgroundColor: 'rgba(0,0,0,0.05)' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <Box
                        sx={{
                          width: 12,
                          height: 12,
                          borderRadius: '50%',
                          backgroundColor: parentCategory.color || '#6366f1',
                        }}
                      />
                      {parentCategory.name}
                    </Box>
                  </MenuItem>,
                  // Child categories
                  ...(parentCategory.children && parentCategory.children.length > 0 ? 
                    parentCategory.children.map((childCategory) => (
                      <MenuItem key={childCategory.id} value={childCategory.id} sx={{ pl: 4 }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                          <Box
                            sx={{
                              width: 10,
                              height: 10,
                              borderRadius: '50%',
                              backgroundColor: childCategory.color || parentCategory.color || '#6366f1',
                            }}
                          />
                          {childCategory.name}
                        </Box>
                      </MenuItem>
                    )) : 
                    // If parent has no children, make it selectable
                    [<MenuItem key={parentCategory.id} value={parentCategory.id} sx={{ pl: 2 }}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Box
                          sx={{
                            width: 12,
                            height: 12,
                            borderRadius: '50%',
                            backgroundColor: parentCategory.color || '#6366f1',
                          }}
                        />
                        {parentCategory.name}
                      </Box>
                    </MenuItem>]
                  ),
                ]).flat()}
              </Select>
              {errors.categoryId && (
                <Typography variant="caption" color="error" sx={{ mt: 0.5, ml: 2 }}>
                  {errors.categoryId}
                </Typography>
              )}
            </FormControl>

            <FormControl fullWidth required error={!!errors.userId}>
              <InputLabel>ユーザー</InputLabel>
              <Select
                name="userId"
                value={formData.userId}
                label="ユーザー"
                onChange={handleInputChange}
                startAdornment={
                  <InputAdornment position="start">
                    <PersonIcon />
                  </InputAdornment>
                }
              >
                {users.map((user) => (
                  <MenuItem key={user.id} value={user.id}>
                    {user.name}
                  </MenuItem>
                ))}
              </Select>
              {errors.userId && (
                <Typography variant="caption" color="error" sx={{ mt: 0.5, ml: 2 }}>
                  {errors.userId}
                </Typography>
              )}
            </FormControl>
          </Stack>

          {/* Tags */}
          <Box>
            <Typography variant="subtitle2" gutterBottom>
              タグ
            </Typography>
            <Stack direction="row" spacing={1} sx={{ mb: 1, flexWrap: 'wrap' }}>
              {formData.tags.map((tag, index) => (
                <Chip
                  key={index}
                  label={tag}
                  onDelete={() => removeTag(tag)}
                  size="small"
                  color="primary"
                  variant="outlined"
                />
              ))}
            </Stack>
            <Stack direction="row" spacing={1}>
              <TextField
                placeholder="タグを入力..."
                value={currentTag}
                onChange={(e) => setCurrentTag(e.target.value)}
                onKeyPress={handleKeyPress}
                size="small"
                sx={{ flexGrow: 1 }}
              />
              <IconButton
                onClick={addTag}
                disabled={!currentTag.trim()}
                color="primary"
              >
                <AddIcon />
              </IconButton>
            </Stack>
          </Box>

          {/* Memo */}
          <TextField
            label="メモ（任意）"
            name="memo"
            value={formData.memo}
            onChange={handleInputChange}
            fullWidth
            multiline
            rows={2}
            placeholder="追加の情報があれば入力してください..."
          />

          {/* File Upload */}
          <FileUpload
            files={formData.files}
            onFilesChange={(files) => setFormData(prev => ({ ...prev, files }))}
            maxFiles={5}
          />

          <Divider />

          {/* Advanced Payment Toggle */}
          <FormControlLabel
            control={
              <Switch
                name="isAdvancePayment"
                checked={formData.isAdvancePayment}
                onChange={handleInputChange}
              />
            }
            label="立替払い"
          />

          {/* Submit Button */}
          <Button
            type="submit"
            variant="contained"
            size="large"
            disabled={isSubmitting}
            startIcon={isSubmitting ? <CircularProgress size={20} /> : <SaveIcon />}
            sx={{
              background: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
              '&:hover': {
                background: 'linear-gradient(135deg, #ec4899 0%, #f59e0b 100%)',
              },
              py: 1.5,
            }}
          >
            {isSubmitting ? '登録中...' : '支出を登録'}
          </Button>

        </Stack>
      </Box>
    </motion.div>
  );
};

export default ExpenseForm;
</file>

<file path="src/components/Registration/FileUpload.js">
import React, { useState, useCallback } from 'react';
import {
  Box,
  Typography,
  IconButton,
  Grid,
  Card,
  CardMedia,
  CardContent,
  CardActions,
  Stack,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  LinearProgress,
  Alert,
  Tooltip,
} from '@mui/material';
import {
  CloudUpload as UploadIcon,
  Delete as DeleteIcon,
  Visibility as ViewIcon,
  Image as ImageIcon,
  AttachFile as AttachIcon,
  Close as CloseIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import fileService from '../../services/fileService';

const FileUpload = ({ files = [], onFilesChange, maxFiles = 5 }) => {
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState({});
  const [previewDialog, setPreviewDialog] = useState({ open: false, file: null });
  const [error, setError] = useState('');

  // Handle file selection
  const handleFileSelect = useCallback(async (selectedFiles) => {
    if (files.length + selectedFiles.length > maxFiles) {
      setError(`最大${maxFiles}ファイルまでアップロードできます。`);
      return;
    }

    setUploading(true);
    setError('');
    
    const newFiles = [];
    
    for (let i = 0; i < selectedFiles.length; i++) {
      const file = selectedFiles[i];
      
      try {
        // Update progress
        setUploadProgress(prev => ({
          ...prev,
          [file.name]: 0
        }));
        
        // Simulate progress for better UX
        const progressInterval = setInterval(() => {
          setUploadProgress(prev => ({
            ...prev,
            [file.name]: Math.min((prev[file.name] || 0) + 10, 90)
          }));
        }, 100);
        
        // Upload file
        const result = await fileService.uploadFile(file);
        
        clearInterval(progressInterval);
        
        if (result.success) {
          newFiles.push(result.data);
          setUploadProgress(prev => ({
            ...prev,
            [file.name]: 100
          }));
        } else {
          setError(result.error);
        }
        
      } catch (error) {
        console.error('Upload error:', error);
        setError('ファイルのアップロードに失敗しました。');
      }
    }
    
    // Clear progress after delay
    setTimeout(() => {
      setUploadProgress({});
    }, 1000);
    
    setUploading(false);
    onFilesChange([...files, ...newFiles]);
  }, [files, maxFiles, onFilesChange]);

  // Handle drag and drop
  const handleDrop = useCallback((e) => {
    e.preventDefault();
    const droppedFiles = Array.from(e.dataTransfer.files);
    handleFileSelect(droppedFiles);
  }, [handleFileSelect]);

  const handleDragOver = useCallback((e) => {
    e.preventDefault();
  }, []);

  // Handle file input change
  const handleInputChange = useCallback((e) => {
    const selectedFiles = Array.from(e.target.files);
    handleFileSelect(selectedFiles);
    e.target.value = ''; // Reset input
  }, [handleFileSelect]);

  // Remove file
  const handleRemoveFile = useCallback((fileId) => {
    const updatedFiles = files.filter(file => file.id !== fileId);
    onFilesChange(updatedFiles);
  }, [files, onFilesChange]);

  // Preview file
  const handlePreviewFile = useCallback((file) => {
    setPreviewDialog({ open: true, file });
  }, []);

  const itemVariants = {
    hidden: { opacity: 0, scale: 0.8 },
    visible: {
      opacity: 1,
      scale: 1,
      transition: { duration: 0.3 }
    },
    exit: {
      opacity: 0,
      scale: 0.8,
      transition: { duration: 0.2 }
    }
  };

  return (
    <Box>
      <Typography variant="subtitle2" gutterBottom>
        ファイル添付 ({files.length}/{maxFiles})
      </Typography>

      {/* Upload Area */}
      <Box
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        sx={{
          border: '2px dashed',
          borderColor: 'primary.main',
          borderRadius: 2,
          p: 3,
          textAlign: 'center',
          backgroundColor: 'action.hover',
          cursor: 'pointer',
          transition: 'all 0.3s ease',
          '&:hover': {
            backgroundColor: 'action.selected',
            borderColor: 'primary.dark',
          },
          mb: 2
        }}
      >
        <input
          type="file"
          multiple
          accept="image/*"
          onChange={handleInputChange}
          style={{ display: 'none' }}
          id="file-upload-input"
          disabled={uploading || files.length >= maxFiles}
        />
        
        <label htmlFor="file-upload-input" style={{ cursor: 'pointer', display: 'block' }}>
          <Stack spacing={2} alignItems="center">
            <UploadIcon sx={{ fontSize: 48, color: 'primary.main' }} />
            <Typography variant="body1">
              画像をドラッグ&ドロップまたはクリックしてアップロード
            </Typography>
            <Typography variant="caption" color="text.secondary">
              JPEG、PNG、GIF、WebP形式対応（最大10MB）
            </Typography>
            {files.length >= maxFiles && (
              <Typography variant="caption" color="error">
                最大ファイル数に達しています
              </Typography>
            )}
          </Stack>
        </label>
      </Box>

      {/* Error Message */}
      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError('')}>
          {error}
        </Alert>
      )}

      {/* Upload Progress */}
      {Object.keys(uploadProgress).length > 0 && (
        <Box sx={{ mb: 2 }}>
          {Object.entries(uploadProgress).map(([fileName, progress]) => (
            <Box key={fileName} sx={{ mb: 1 }}>
              <Typography variant="caption" color="text.secondary">
                {fileName}
              </Typography>
              <LinearProgress variant="determinate" value={progress} />
            </Box>
          ))}
        </Box>
      )}

      {/* File Grid */}
      <AnimatePresence>
        {files.length > 0 && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
          >
            <Grid container spacing={2}>
              {files.map((file) => (
                <Grid item xs={12} sm={6} md={4} key={file.id}>
                  <motion.div
                    variants={itemVariants}
                    initial="hidden"
                    animate="visible"
                    exit="exit"
                    layout
                  >
                    <Card>
                      {file.thumbnail ? (
                        <CardMedia
                          component="img"
                          height="120"
                          image={file.thumbnail}
                          alt={file.originalName}
                          sx={{ objectFit: 'cover', cursor: 'pointer' }}
                          onClick={() => handlePreviewFile(file)}
                          onError={(e) => {
                            console.error('Thumbnail load error:', e);
                            e.target.style.display = 'none';
                          }}
                        />
                      ) : (
                        <Box
                          sx={{
                            height: 120,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            backgroundColor: 'grey.100',
                            cursor: 'pointer'
                          }}
                          onClick={() => handlePreviewFile(file)}
                        >
                          <AttachIcon sx={{ fontSize: 48, color: 'grey.400' }} />
                        </Box>
                      )}
                      
                      <CardContent sx={{ pb: 1 }}>
                        <Tooltip title={file.originalName}>
                          <Typography variant="body2" noWrap>
                            {file.originalName}
                          </Typography>
                        </Tooltip>
                        <Stack direction="row" spacing={1} sx={{ mt: 1 }}>
                          <Chip
                            label={fileService.formatFileSize(file.size)}
                            size="small"
                            variant="outlined"
                          />
                          {fileService.isImageFile(file.mimeType) && (
                            <Chip
                              icon={<ImageIcon />}
                              label="画像"
                              size="small"
                              color="primary"
                              variant="outlined"
                            />
                          )}
                        </Stack>
                      </CardContent>
                      
                      <CardActions sx={{ pt: 0, justifyContent: 'space-between' }}>
                        <IconButton
                          size="small"
                          onClick={() => handlePreviewFile(file)}
                          color="primary"
                        >
                          <ViewIcon />
                        </IconButton>
                        <IconButton
                          size="small"
                          onClick={() => handleRemoveFile(file.id)}
                          color="error"
                        >
                          <DeleteIcon />
                        </IconButton>
                      </CardActions>
                    </Card>
                  </motion.div>
                </Grid>
              ))}
            </Grid>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Preview Dialog */}
      <Dialog
        open={previewDialog.open}
        onClose={() => setPreviewDialog({ open: false, file: null })}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          {previewDialog.file?.originalName}
          <IconButton onClick={() => setPreviewDialog({ open: false, file: null })}>
            <CloseIcon />
          </IconButton>
        </DialogTitle>
        <DialogContent>
          {previewDialog.file && (
            <Box sx={{ textAlign: 'center' }}>
              {fileService.isImageFile(previewDialog.file.mimeType) && previewDialog.file.data ? (
                <img
                  src={previewDialog.file.data}
                  alt={previewDialog.file.originalName}
                  style={{
                    maxWidth: '100%',
                    maxHeight: '70vh',
                    objectFit: 'contain'
                  }}
                  onError={(e) => {
                    console.error('Image preview error:', e);
                    e.target.style.display = 'none';
                  }}
                />
              ) : (
                <Box sx={{ py: 4 }}>
                  <AttachIcon sx={{ fontSize: 64, color: 'grey.400', mb: 2 }} />
                  <Typography>
                    {!previewDialog.file.data ? 'プレビューデータがありません' : 'プレビューできません'}
                  </Typography>
                </Box>
              )}
              
              <Stack spacing={1} sx={{ mt: 2 }}>
                <Typography variant="body2" color="text.secondary">
                  ファイルサイズ: {fileService.formatFileSize(previewDialog.file.size)}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  アップロード日時: {new Date(previewDialog.file.uploadedAt).toLocaleString('ja-JP')}
                </Typography>
                {previewDialog.file.description && (
                  <Typography variant="body2">
                    説明: {previewDialog.file.description}
                  </Typography>
                )}
              </Stack>
            </Box>
          )}
        </DialogContent>
      </Dialog>
    </Box>
  );
};

export default FileUpload;
</file>

<file path="src/components/Registration/IncomeForm.js">
import React, { useState, useEffect } from 'react';
import {
  TextField,
  Button,
  Stack,
  Box,
  Typography,
  Chip,
  FormControlLabel,
  Switch,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Divider,
  IconButton,
  InputAdornment,
  CircularProgress,
} from '@mui/material';
import {
  CalendarToday as CalendarIcon,
  AttachMoney as MoneyIcon,
  Category as CategoryIcon,
  Person as PersonIcon,
  Description as DescriptionIcon,
  Add as AddIcon,
  Save as SaveIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import CategorySuggestion from './CategorySuggestion';
import FileUpload from './FileUpload';
import OCRButton from './OCRButton';
import categoryService from '../../services/categoryService';
import userService from '../../services/userService';
import { learnFromSelection } from '../../services/aiService';

const IncomeForm = ({ onSubmit }) => {
  const [formData, setFormData] = useState({
    date: new Date().toISOString().split('T')[0],
    amount: '',
    description: '',
    categoryId: '',
    userId: '',
    tags: [],
    memo: '',
    isRecurring: false,
    files: [],
  });

  const [errors, setErrors] = useState({});
  const [currentTag, setCurrentTag] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [categories, setCategories] = useState([]);
  const [categoryHierarchy, setCategoryHierarchy] = useState([]);
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [showAiSuggestion, setShowAiSuggestion] = useState(false);

  // Load categories and users on component mount
  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        
        const [categoriesResult, usersResult] = await Promise.all([
          categoryService.getAllCategories(),
          userService.getAllUsers()
        ]);
        
        if (categoriesResult.success) {
          const incomeCategories = categoriesResult.data.filter(cat => cat.type === 'income');
          setCategories(incomeCategories);
          
          // Organize categories into hierarchy
          const parentCategories = incomeCategories.filter(cat => !cat.parentId);
          const hierarchy = parentCategories.map(parent => ({
            ...parent,
            children: incomeCategories.filter(child => child.parentId === parent.id)
          }));
          setCategoryHierarchy(hierarchy);
        }
        
        if (usersResult.success) {
          setUsers(usersResult.data);
        }
        
      } catch (error) {
        console.error('Failed to load data:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadData();
  }, []);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Clear error for this field
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
    
    // Show AI suggestion when description changes
    if (name === 'description' && value.length > 3) {
      setShowAiSuggestion(true);
    }
  };

  const handleCategorySelect = (categoryId) => {
    setFormData(prev => ({
      ...prev,
      categoryId
    }));
    setShowAiSuggestion(false);
    if (errors.categoryId) {
      setErrors(prev => ({ ...prev, categoryId: '' }));
    }
  };

  const addTag = () => {
    if (currentTag.trim() && !formData.tags.includes(currentTag.trim())) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, currentTag.trim()]
      }));
      setCurrentTag('');
    }
  };

  const removeTag = (tagToRemove) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove)
    }));
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && currentTag.trim()) {
      e.preventDefault();
      addTag();
    }
  };

  // Handle OCR data extraction
  const handleOCRData = (ocrData) => {
    setFormData(prev => ({
      ...prev,
      amount: ocrData.amount ? ocrData.amount.toString() : prev.amount,
      date: ocrData.date || prev.date,
      description: ocrData.vendor || prev.description,
    }));

    // Try to find matching category
    if (ocrData.category) {
      const matchingCategory = categories.find(cat => 
        cat.name.toLowerCase().includes(ocrData.category.toLowerCase())
      );
      if (matchingCategory) {
        setFormData(prev => ({ ...prev, categoryId: matchingCategory.id }));
      }
    }

    // Add items as tags if found
    if (ocrData.items && ocrData.items.length > 0) {
      const itemTags = ocrData.items.slice(0, 3).map(item => item.name);
      setFormData(prev => ({ ...prev, tags: [...prev.tags, ...itemTags] }));
    }

    setErrors({ success: 'レシートのデータを適用しました。内容を確認してください。' });
  };

  const validateForm = () => {
    const newErrors = {};
    
    if (!formData.amount || parseFloat(formData.amount) <= 0) {
      newErrors.amount = '有効な金額を入力してください';
    }
    
    if (!formData.description.trim()) {
      newErrors.description = '説明を入力してください';
    }
    
    if (!formData.categoryId) {
      newErrors.categoryId = 'カテゴリを選択してください';
    }
    
    if (!formData.userId) {
      newErrors.userId = 'ユーザーを選択してください';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    setIsSubmitting(true);
    
    try {
      // Learn from user's category selection
      const selectedCategory = categories.find(cat => cat.id === formData.categoryId);
      if (selectedCategory) {
        learnFromSelection(formData.description, selectedCategory.name, 'income');
      }

      // Submit the data to parent component
      await onSubmit({
        type: 'income',
        ...formData,
        amount: parseFloat(formData.amount),
        fileIds: formData.files.map(f => f.id)
      });
      
      // Reset form
      setFormData({
        date: new Date().toISOString().split('T')[0],
        amount: '',
        description: '',
        categoryId: '',
        userId: '',
        tags: [],
        memo: '',
        isRecurring: false,
        files: [],
      });
      
      setShowAiSuggestion(false);
      
    } catch (error) {
      console.error('Error submitting income:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <Box component="form" onSubmit={handleSubmit}>
        {/* OCR Button Row */}
        <Box sx={{ mb: 3, display: 'flex', justifyContent: 'flex-end' }}>
          <OCRButton onDataExtracted={handleOCRData} />
        </Box>
        
        <Stack spacing={3}>
          {/* Date and Amount Row */}
          <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
            <TextField
              label="日付"
              type="date"
              name="date"
              value={formData.date}
              onChange={handleInputChange}
              fullWidth
              required
              InputLabelProps={{ shrink: true }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <CalendarIcon />
                  </InputAdornment>
                ),
              }}
            />
            
            <TextField
              label="金額"
              type="number"
              name="amount"
              value={formData.amount}
              onChange={handleInputChange}
              fullWidth
              required
              error={!!errors.amount}
              helperText={errors.amount}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <MoneyIcon />
                  </InputAdornment>
                ),
                endAdornment: <InputAdornment position="end">円</InputAdornment>,
              }}
            />
          </Stack>

          {/* Description */}
          <TextField
            label="説明"
            name="description"
            value={formData.description}
            onChange={handleInputChange}
            fullWidth
            required
            multiline
            rows={2}
            error={!!errors.description}
            helperText={errors.description || "4文字以上入力するとAIがカテゴリを提案します"}
            placeholder="収入の詳細を入力してください（例：給与、副業収入、配当金）..."
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <DescriptionIcon />
                </InputAdornment>
              ),
            }}
          />

          {/* AI Category Suggestion */}
          <AnimatePresence>
            {showAiSuggestion && formData.description.length > 3 && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.3 }}
              >
                <CategorySuggestion
                  description={formData.description}
                  type="income"
                  onCategorySelect={handleCategorySelect}
                  availableCategories={categories}
                />
              </motion.div>
            )}
          </AnimatePresence>

          {/* Category and User Selection */}
          <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
            <FormControl fullWidth required error={!!errors.categoryId}>
              <InputLabel>カテゴリ</InputLabel>
              <Select
                name="categoryId"
                value={formData.categoryId}
                label="カテゴリ"
                onChange={handleInputChange}
                startAdornment={
                  <InputAdornment position="start">
                    <CategoryIcon />
                  </InputAdornment>
                }
              >
                {categoryHierarchy.map((parentCategory) => [
                  // Parent category (disabled, just for grouping)
                  <MenuItem key={`parent-${parentCategory.id}`} disabled sx={{ fontWeight: 'bold', backgroundColor: 'rgba(0,0,0,0.05)' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <Box
                        sx={{
                          width: 12,
                          height: 12,
                          borderRadius: '50%',
                          backgroundColor: parentCategory.color || '#10b981',
                        }}
                      />
                      {parentCategory.name}
                    </Box>
                  </MenuItem>,
                  // Child categories
                  ...(parentCategory.children && parentCategory.children.length > 0 ? 
                    parentCategory.children.map((childCategory) => (
                      <MenuItem key={childCategory.id} value={childCategory.id} sx={{ pl: 4 }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                          <Box
                            sx={{
                              width: 10,
                              height: 10,
                              borderRadius: '50%',
                              backgroundColor: childCategory.color || parentCategory.color || '#10b981',
                            }}
                          />
                          {childCategory.name}
                        </Box>
                      </MenuItem>
                    )) : 
                    // If parent has no children, make it selectable
                    [<MenuItem key={parentCategory.id} value={parentCategory.id} sx={{ pl: 2 }}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Box
                          sx={{
                            width: 12,
                            height: 12,
                            borderRadius: '50%',
                            backgroundColor: parentCategory.color || '#10b981',
                          }}
                        />
                        {parentCategory.name}
                      </Box>
                    </MenuItem>]
                  ),
                ]).flat()}
              </Select>
              {errors.categoryId && (
                <Typography variant="caption" color="error" sx={{ mt: 0.5, ml: 2 }}>
                  {errors.categoryId}
                </Typography>
              )}
            </FormControl>

            <FormControl fullWidth required error={!!errors.userId}>
              <InputLabel>ユーザー</InputLabel>
              <Select
                name="userId"
                value={formData.userId}
                label="ユーザー"
                onChange={handleInputChange}
                startAdornment={
                  <InputAdornment position="start">
                    <PersonIcon />
                  </InputAdornment>
                }
              >
                {users.map((user) => (
                  <MenuItem key={user.id} value={user.id}>
                    {user.name}
                  </MenuItem>
                ))}
              </Select>
              {errors.userId && (
                <Typography variant="caption" color="error" sx={{ mt: 0.5, ml: 2 }}>
                  {errors.userId}
                </Typography>
              )}
            </FormControl>
          </Stack>

          {/* Tags */}
          <Box>
            <Typography variant="subtitle2" gutterBottom>
              タグ
            </Typography>
            <Stack direction="row" spacing={1} sx={{ mb: 1, flexWrap: 'wrap' }}>
              {formData.tags.map((tag, index) => (
                <Chip
                  key={index}
                  label={tag}
                  onDelete={() => removeTag(tag)}
                  size="small"
                  color="success"
                  variant="outlined"
                />
              ))}
            </Stack>
            <Stack direction="row" spacing={1}>
              <TextField
                placeholder="タグを入力..."
                value={currentTag}
                onChange={(e) => setCurrentTag(e.target.value)}
                onKeyPress={handleKeyPress}
                size="small"
                sx={{ flexGrow: 1 }}
              />
              <IconButton
                onClick={addTag}
                disabled={!currentTag.trim()}
                color="success"
              >
                <AddIcon />
              </IconButton>
            </Stack>
          </Box>

          {/* Memo */}
          <TextField
            label="メモ（任意）"
            name="memo"
            value={formData.memo}
            onChange={handleInputChange}
            fullWidth
            multiline
            rows={2}
            placeholder="追加の情報があれば入力してください..."
          />

          {/* File Upload */}
          <FileUpload
            files={formData.files}
            onFilesChange={(files) => setFormData(prev => ({ ...prev, files }))}
            maxFiles={5}
          />

          <Divider />

          {/* Recurring Toggle */}
          <FormControlLabel
            control={
              <Switch
                name="isRecurring"
                checked={formData.isRecurring}
                onChange={handleInputChange}
                color="success"
              />
            }
            label="定期収入"
          />

          {/* Submit Button */}
          <Button
            type="submit"
            variant="contained"
            size="large"
            disabled={isSubmitting}
            startIcon={isSubmitting ? <CircularProgress size={20} /> : <SaveIcon />}
            sx={{
              background: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
              '&:hover': {
                background: 'linear-gradient(135deg, #0f766e 0%, #059669 100%)',
              },
              py: 1.5,
            }}
          >
            {isSubmitting ? '登録中...' : '収入を登録'}
          </Button>

        </Stack>
      </Box>
    </motion.div>
  );
};

export default IncomeForm;
</file>

<file path="src/components/Registration/OCRButton.js">
import React, { useState, useRef } from 'react';
import {
  Button,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Box,
  Typography,
  LinearProgress,
  Alert,
  Stack,
  Chip,
} from '@mui/material';
import {
  CameraAlt as CameraIcon,
  Receipt as ReceiptIcon,
  Close as CloseIcon,
  CheckCircle as CheckCircleIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import ocrService from '../../services/ocrServiceNew';
import { formatDate } from '../../utils/formatters';
import useSettings from '../../hooks/useSettings';

const OCRButton = ({ onDataExtracted, variant = 'contained' }) => {
  const { settings } = useSettings();
  const [open, setOpen] = useState(false);
  const [processing, setProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const [result, setResult] = useState(null);
  const [error, setError] = useState('');
  const fileInputRef = useRef(null);

  const handleOpen = () => {
    setOpen(true);
    setError('');
    setResult(null);
    setProgress(0);
  };

  const handleClose = () => {
    setOpen(false);
    setProcessing(false);
    setProgress(0);
    setResult(null);
    setError('');
  };

  const handleFileSelect = async (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // Check if file is an image
    if (!file.type.startsWith('image/')) {
      setError('画像ファイルを選択してください。');
      return;
    }

    setProcessing(true);
    setError('');

    try {
      const ocrResult = await ocrService.processReceipt(file, (progressData) => {
        setProgress(progressData.progress || 0);
      });

      if (ocrResult.success && ocrResult.data) {
        setResult(ocrResult.data);
      } else {
        setError(ocrResult.error || 'レシートの読み取りに失敗しました。');
      }
    } catch (err) {
      console.error('OCR error:', err);
      console.error('OCR error details:', {
        message: err.message,
        stack: err.stack,
        name: err.name
      });
      setError(`レシートの処理中にエラーが発生しました。: ${err.message}`);
    } finally {
      setProcessing(false);
    }
  };

  const handleApplyData = () => {
    if (result && onDataExtracted) {
      onDataExtracted(result);
      handleClose();
    }
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('ja-JP', {
      style: 'currency',
      currency: 'JPY'
    }).format(amount);
  };

  return (
    <>
      {variant === 'contained' ? (
        <Button
          variant="contained"
          startIcon={<CameraIcon />}
          onClick={handleOpen}
          sx={{
            background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            '&:hover': {
              background: 'linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%)',
            },
          }}
        >
          レシート撮影
        </Button>
      ) : (
        <IconButton onClick={handleOpen} color="primary">
          <CameraIcon />
        </IconButton>
      )}

      <Dialog open={open} onClose={handleClose} maxWidth="sm" fullWidth>
        <DialogTitle>
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            <Typography variant="h6">
              <ReceiptIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              レシート読み取り
            </Typography>
            <IconButton onClick={handleClose} size="small">
              <CloseIcon />
            </IconButton>
          </Box>
        </DialogTitle>

        <DialogContent>
          <Stack spacing={3}>
            <Typography variant="body2" color="text.secondary">
              レシートや請求書の写真を選択すると、自動的に金額や日付などの情報を読み取ります。
            </Typography>

            <input
              ref={fileInputRef}
              type="file"
              accept="image/*"
              capture="environment"
              style={{ display: 'none' }}
              onChange={handleFileSelect}
            />

            {!processing && !result && (
              <Box sx={{ textAlign: 'center', py: 4 }}>
                <motion.div
                  initial={{ scale: 0.9 }}
                  animate={{ scale: 1 }}
                  transition={{ duration: 0.3 }}
                >
                  <Button
                    variant="contained"
                    size="large"
                    startIcon={<CameraIcon />}
                    onClick={() => fileInputRef.current?.click()}
                    sx={{
                      background: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
                      '&:hover': {
                        background: 'linear-gradient(135deg, #0f766e 0%, #059669 100%)',
                      },
                      py: 2,
                      px: 4,
                    }}
                  >
                    写真を選択
                  </Button>
                </motion.div>
              </Box>
            )}

            {processing && (
              <Box sx={{ textAlign: 'center', py: 4 }}>
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  {progress < 70 ? 'レシートを読み取っています...' : 'AIで内容を解析しています...'}
                </Typography>
                <LinearProgress variant="determinate" value={progress} sx={{ mt: 2 }} />
                <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                  {progress}%
                </Typography>
                <Typography variant="caption" color="text.secondary" sx={{ mt: 1 }}>
                  {progress < 70 
                    ? '※日本語の認識には時間がかかる場合があります'
                    : '※GPT-4でレシート内容を解析しています'
                  }
                </Typography>
              </Box>
            )}

            {error && (
              <Alert severity="error" onClose={() => setError('')}>
                {error}
              </Alert>
            )}

            {result && (
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5 }}
              >
                <Box sx={{ 
                  p: 2, 
                  bgcolor: 'background.paper', 
                  borderRadius: 2,
                  border: '1px solid',
                  borderColor: 'divider' 
                }}>
                  <Typography variant="h6" gutterBottom>
                    読み取り結果
                  </Typography>

                  <Stack spacing={2}>
                    {result.amount && (
                      <Box>
                        <Typography variant="caption" color="text.secondary">
                          金額
                        </Typography>
                        <Typography variant="h5" color="primary">
                          {formatCurrency(result.amount)}
                        </Typography>
                      </Box>
                    )}

                    {result.date && (
                      <Box>
                        <Typography variant="caption" color="text.secondary">
                          日付
                        </Typography>
                        <Typography>
                          {formatDate(result.date, settings.dateFormat)}
                        </Typography>
                      </Box>
                    )}

                    {result.vendor && (
                      <Box>
                        <Typography variant="caption" color="text.secondary">
                          店舗名
                        </Typography>
                        <Typography>
                          {result.vendor}
                        </Typography>
                      </Box>
                    )}

                    {result.category && (
                      <Box>
                        <Typography variant="caption" color="text.secondary">
                          推定カテゴリ
                        </Typography>
                        <Chip 
                          label={result.category} 
                          color="primary" 
                          size="small" 
                          sx={{ mt: 0.5 }}
                        />
                      </Box>
                    )}

                    {result.items && result.items.length > 0 && (
                      <Box>
                        <Typography variant="caption" color="text.secondary">
                          明細
                        </Typography>
                        <Stack direction="row" spacing={1} flexWrap="wrap" sx={{ mt: 0.5 }}>
                          {result.items.map((item, index) => (
                            <Chip
                              key={index}
                              label={`${item.name} (${formatCurrency(item.price)})`}
                              size="small"
                              variant="outlined"
                            />
                          ))}
                        </Stack>
                      </Box>
                    )}

                    <Box sx={{ mt: 2, p: 1, bgcolor: 'action.hover', borderRadius: 1 }}>
                      <Stack direction="row" spacing={2} alignItems="center">
                        <Typography variant="caption" color="text.secondary">
                          読み取り精度: {Math.round(result.confidence || 0)}%
                        </Typography>
                        {result.enhanced && (
                          <Chip 
                            label="AI解析済み" 
                            size="small" 
                            color="success" 
                            icon={<CheckCircleIcon />}
                          />
                        )}
                      </Stack>
                    </Box>
                    
                    {(!result.amount && !result.date && !result.vendor) && (
                      <Alert severity="warning" sx={{ mt: 2 }}>
                        <Typography variant="body2">
                          レシートの情報を正しく読み取れませんでした。
                        </Typography>
                        <Typography variant="caption" display="block" sx={{ mt: 1 }}>
                          以下をお試しください：
                        </Typography>
                        <ul style={{ margin: '8px 0', paddingLeft: '20px' }}>
                          <li><Typography variant="caption">レシートを明るい場所で撮影する</Typography></li>
                          <li><Typography variant="caption">文字がはっきり見えるように撮影する</Typography></li>
                          <li><Typography variant="caption">レシート全体が画像に収まるようにする</Typography></li>
                          {!result.enhanced && (
                            <li>
                              <Typography variant="caption">
                                設定画面でOpenAI APIキーを設定すると、AIによる高精度な解析が可能になります
                              </Typography>
                            </li>
                          )}
                        </ul>
                      </Alert>
                    )}
                  </Stack>
                </Box>
              </motion.div>
            )}
          </Stack>
        </DialogContent>

        <DialogActions>
          <Button onClick={handleClose}>キャンセル</Button>
          {result && (
            <Button
              variant="contained"
              onClick={handleApplyData}
              sx={{
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              }}
            >
              データを適用
            </Button>
          )}
        </DialogActions>
      </Dialog>
    </>
  );
};

export default OCRButton;
</file>

<file path="src/components/Settings/ApiSettings.js">
import React, { useState, useCallback } from 'react';
import {
  Box,
  Typography,
  TextField,
  Button,
  Stack,
  Alert,
  Card,
  CardContent,
  Switch,
  FormControlLabel,
  Divider,
  InputAdornment,
  IconButton,
  LinearProgress,
  Chip,
} from '@mui/material';
import {
  Psychology as AiIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon,
  Check as CheckIcon,
  Error as ErrorIcon,
  Save as SaveIcon,
  Refresh as RefreshIcon,
  Help as HelpIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';

const ApiSettings = ({ settings, updateSetting, hasChanges, saveSettings, testApiConnection }) => {
  const [showApiKey, setShowApiKey] = useState(false);
  const [testing, setTesting] = useState(false);
  const [testResult, setTestResult] = useState(null);
  const [saving, setSaving] = useState(false);

  // Handle API key visibility toggle
  const toggleApiKeyVisibility = useCallback(() => {
    setShowApiKey(prev => !prev);
  }, []);

  // Handle test connection
  const handleTestConnection = useCallback(async () => {
    setTesting(true);
    setTestResult(null);
    
    try {
      const result = await testApiConnection();
      setTestResult(result);
    } catch (error) {
      setTestResult({
        success: false,
        error: error.message
      });
    } finally {
      setTesting(false);
    }
  }, [testApiConnection]);

  // Handle save settings
  const handleSaveSettings = useCallback(async () => {
    setSaving(true);
    try {
      await saveSettings();
      setTestResult(null); // Clear test result after saving
    } catch (error) {
      console.error('Failed to save settings:', error);
    } finally {
      setSaving(false);
    }
  }, [saveSettings]);

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  return (
    <GlassCard>
      <GlassCardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" fontWeight="bold">
            <AiIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
            AI設定
          </Typography>
          <Stack direction="row" spacing={1}>
            {hasChanges && (
              <Button
                variant="contained"
                size="small"
                startIcon={<SaveIcon />}
                onClick={handleSaveSettings}
                disabled={saving}
              >
                {saving ? '保存中...' : '保存'}
              </Button>
            )}
          </Stack>
        </Box>

        <Stack spacing={3}>
          {/* AI Features Toggle */}
          <motion.div variants={itemVariants}>
            <Card>
              <CardContent>
                <FormControlLabel
                  control={
                    <Switch
                      checked={settings.aiSuggestions || false}
                      onChange={(e) => updateSetting('aiSuggestions', e.target.checked)}
                    />
                  }
                  label={
                    <Box>
                      <Typography variant="body1" fontWeight="medium">
                        AI機能を有効にする
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        カテゴリ提案や経費分析などのAI機能を使用します
                      </Typography>
                    </Box>
                  }
                />
              </CardContent>
            </Card>
          </motion.div>

          {settings.aiSuggestions && (
            <>
              {/* API Configuration */}
              <motion.div variants={itemVariants}>
                <Typography variant="h6" gutterBottom>
                  OpenAI API設定
                </Typography>
                
                <Stack spacing={2}>
                  <TextField
                    label="APIキー"
                    type={showApiKey ? 'text' : 'password'}
                    value={settings.openaiApiKey || ''}
                    onChange={(e) => updateSetting('openaiApiKey', e.target.value)}
                    fullWidth
                    placeholder="sk-..."
                    helperText="OpenAIのAPIキーを入力してください。取得は https://platform.openai.com で行えます。"
                    InputProps={{
                      endAdornment: (
                        <InputAdornment position="end">
                          <IconButton onClick={toggleApiKeyVisibility} edge="end">
                            {showApiKey ? <VisibilityOffIcon /> : <VisibilityIcon />}
                          </IconButton>
                        </InputAdornment>
                      ),
                    }}
                  />

                  <TextField
                    label="APIエンドポイント"
                    value={settings.apiEndpoint || 'https://api.openai.com/v1/chat/completions'}
                    onChange={(e) => updateSetting('apiEndpoint', e.target.value)}
                    fullWidth
                    helperText="通常は変更不要です。カスタムエンドポイントを使用する場合のみ変更してください。"
                  />

                  <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                    <Button
                      variant="outlined"
                      startIcon={<RefreshIcon />}
                      onClick={handleTestConnection}
                      disabled={testing || !settings.openaiApiKey}
                    >
                      {testing ? '接続テスト中...' : '接続テスト'}
                    </Button>

                    {testResult && (
                      <Chip
                        icon={testResult.success ? <CheckIcon /> : <ErrorIcon />}
                        label={testResult.success ? '接続成功' : '接続失敗'}
                        color={testResult.success ? 'success' : 'error'}
                        variant="outlined"
                      />
                    )}
                  </Box>

                  {testing && (
                    <LinearProgress />
                  )}

                  {testResult && !testResult.success && (
                    <Alert severity="error">
                      <Typography variant="body2">
                        {testResult.error}
                      </Typography>
                    </Alert>
                  )}

                  {testResult && testResult.success && (
                    <Alert severity="success">
                      <Typography variant="body2">
                        {testResult.message}
                      </Typography>
                    </Alert>
                  )}
                </Stack>
              </motion.div>

              <Divider />

              {/* Advanced Settings */}
              <motion.div variants={itemVariants}>
                <Typography variant="h6" gutterBottom>
                  詳細設定
                </Typography>
                
                <Stack spacing={2}>
                  <TextField
                    label="最大リトライ回数"
                    type="number"
                    value={settings.maxRetries || 3}
                    onChange={(e) => updateSetting('maxRetries', parseInt(e.target.value))}
                    inputProps={{ min: 1, max: 10 }}
                    helperText="API呼び出しが失敗した際の最大リトライ回数"
                  />

                  <TextField
                    label="リクエストタイムアウト（ミリ秒）"
                    type="number"
                    value={settings.requestTimeout || 30000}
                    onChange={(e) => updateSetting('requestTimeout', parseInt(e.target.value))}
                    inputProps={{ min: 5000, max: 120000 }}
                    helperText="APIリクエストのタイムアウト時間（5秒〜2分）"
                  />
                </Stack>
              </motion.div>

              <Divider />

              {/* Usage Information */}
              <motion.div variants={itemVariants}>
                <Alert severity="info" icon={<HelpIcon />}>
                  <Typography variant="body2" fontWeight="medium" gutterBottom>
                    AI機能について
                  </Typography>
                  <Typography variant="body2" component="div">
                    • <strong>カテゴリ提案</strong>: 支出・収入の説明から適切なカテゴリを提案<br/>
                    • <strong>経費分析</strong>: 税務上の扱いや必要書類についてアドバイス<br/>
                    • <strong>月次レポート</strong>: 収支データの分析と改善提案<br/>
                    • <strong>学習機能</strong>: ユーザーの選択から学習して精度向上
                  </Typography>
                </Alert>
              </motion.div>

              {/* Privacy Notice */}
              <motion.div variants={itemVariants}>
                <Alert severity="warning">
                  <Typography variant="body2" fontWeight="medium" gutterBottom>
                    プライバシーについて
                  </Typography>
                  <Typography variant="body2">
                    AI機能は入力された説明文や金額をOpenAIのAPIに送信します。
                    機密性の高い情報を含む場合は、AI機能を無効にすることをお勧めします。
                  </Typography>
                </Alert>
              </motion.div>
            </>
          )}
        </Stack>
      </GlassCardContent>
    </GlassCard>
  );
};

export default ApiSettings;
</file>

<file path="src/components/Settings/CategorySettings.js">
import React, { useState, useCallback, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemSecondaryAction,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Chip,
  Stack,
  Grid,
  Alert,
  Divider,
  Card,
  CardContent,
  Menu,
  MenuList,
  MenuItem as MenuItemComponent,
  Tooltip,
} from '@mui/material';
import {
  Category as CategoryIcon,
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  MoreVert as MoreVertIcon,
  Download as DownloadIcon,
  Upload as UploadIcon,
  Folder as FolderIcon,
  FolderOpen as FolderOpenIcon,
  Save as SaveIcon,
  Cancel as CancelIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';
import categoryService from '../../services/categoryService';

const CategorySettings = ({ settings, updateSetting, hasChanges, isModified }) => {
  const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(true);
  const [openDialog, setOpenDialog] = useState('');
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryForm, setCategoryForm] = useState({
    name: '',
    type: 'expense',
    color: '#6366f1',
    icon: 'category',
    parentId: null,
    isActive: true
  });
  const [menuAnchor, setMenuAnchor] = useState(null);
  const [expandedCategories, setExpandedCategories] = useState(new Set());
  const [error, setError] = useState(null);

  // Available icons for categories
  const availableIcons = [
    { name: 'category', icon: '📁', label: 'フォルダ' },
    { name: 'transport', icon: '🚗', label: '交通' },
    { name: 'food', icon: '🍽️', label: '食事' },
    { name: 'shopping', icon: '🛒', label: '買い物' },
    { name: 'entertainment', icon: '🎬', label: '娯楽' },
    { name: 'utilities', icon: '⚡', label: '光熱費' },
    { name: 'health', icon: '🏥', label: '医療' },
    { name: 'education', icon: '📚', label: '教育' },
    { name: 'work', icon: '💼', label: '仕事' },
    { name: 'home', icon: '🏠', label: '住居' },
    { name: 'travel', icon: '✈️', label: '旅行' },
    { name: 'gift', icon: '🎁', label: 'ギフト' },
    { name: 'investment', icon: '📈', label: '投資' },
    { name: 'salary', icon: '💰', label: '給与' },
    { name: 'bonus', icon: '🎉', label: 'ボーナス' },
    { name: 'freelance', icon: '💻', label: 'フリーランス' }
  ];

  // Category presets for import
  const categoryPresets = {
    taxAccounting: {
      name: '税務会計カテゴリ',
      categories: [
        // Income categories
        { name: '売上高', type: 'income', color: '#4CAF50', icon: 'salary', parentId: null },
        { name: '受取手数料', type: 'income', color: '#2196F3', icon: 'work', parentId: null },
        { name: '受取利息', type: 'income', color: '#00BCD4', icon: 'investment', parentId: null },
        { name: '雑収入', type: 'income', color: '#795548', icon: 'category', parentId: null },
        
        // Expense parent categories and their children
        { name: '人件費', type: 'expense', color: '#F44336', icon: 'category', parentId: null },
        { name: '給与手当', type: 'expense', color: '#F44336', icon: 'salary', parentId: '人件費' },
        { name: '法定福利費', type: 'expense', color: '#F44336', icon: 'health', parentId: '人件費' },
        
        { name: '売上原価', type: 'expense', color: '#E91E63', icon: 'category', parentId: null },
        { name: '仕入高', type: 'expense', color: '#E91E63', icon: 'shopping', parentId: '売上原価' },
        { name: '外注費', type: 'expense', color: '#E91E63', icon: 'work', parentId: '売上原価' },
        
        { name: '一般管理費', type: 'expense', color: '#3F51B5', icon: 'category', parentId: null },
        { name: '通信費', type: 'expense', color: '#3F51B5', icon: 'utilities', parentId: '一般管理費' },
        { name: '旅費交通費', type: 'expense', color: '#3F51B5', icon: 'transport', parentId: '一般管理費' },
        { name: '会議費', type: 'expense', color: '#3F51B5', icon: 'work', parentId: '一般管理費' },
        { name: '消耗品費', type: 'expense', color: '#3F51B5', icon: 'shopping', parentId: '一般管理費' }
      ]
    },
    personal: {
      name: '個人用',
      categories: [
        { name: '食費', type: 'expense', color: '#f59e0b', icon: 'food' },
        { name: '交通費', type: 'expense', color: '#3b82f6', icon: 'transport' },
        { name: '娯楽費', type: 'expense', color: '#ec4899', icon: 'entertainment' },
        { name: '光熱費', type: 'expense', color: '#eab308', icon: 'utilities' },
        { name: '医療費', type: 'expense', color: '#ef4444', icon: 'health' },
        { name: '教育費', type: 'expense', color: '#8b5cf6', icon: 'education' },
        { name: '給与', type: 'income', color: '#22c55e', icon: 'salary' },
        { name: 'ボーナス', type: 'income', color: '#10b981', icon: 'bonus' }
      ]
    }
  };

  // Load categories from database
  const loadCategories = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await categoryService.getAllCategories();
      const categoriesData = result.success ? result.data : [];
      setCategories(Array.isArray(categoriesData) ? categoriesData : []);
    } catch (err) {
      console.error('Failed to load categories:', err);
      setError('カテゴリの読み込みに失敗しました');
      setCategories([]);
    } finally {
      setLoading(false);
    }
  }, []);

  // Save category
  const saveCategory = useCallback(async () => {
    try {
      if (!categoryForm.name.trim()) {
        setError('カテゴリ名を入力してください');
        return;
      }

      if (selectedCategory) {
        // Update existing category
        await categoryService.updateCategory(selectedCategory.id, categoryForm);
      } else {
        // Create new category
        await categoryService.createCategory(categoryForm);
      }

      await loadCategories();
      setOpenDialog('');
      setSelectedCategory(null);
      setCategoryForm({
        name: '',
        type: 'expense',
        color: '#6366f1',
        icon: 'category',
        parentId: null,
        isActive: true
      });
      setError(null);
    } catch (err) {
      console.error('Failed to save category:', err);
      setError('カテゴリの保存に失敗しました');
    }
  }, [categoryForm, selectedCategory, loadCategories]);

  // Delete category
  const deleteCategory = useCallback(async (categoryId) => {
    try {
      await categoryService.deleteCategory(categoryId);
      await loadCategories();
      setError(null);
    } catch (err) {
      console.error('Failed to delete category:', err);
      setError('カテゴリの削除に失敗しました');
    }
  }, [loadCategories]);

  // Open edit dialog
  const openEditDialog = useCallback((category) => {
    setSelectedCategory(category);
    setCategoryForm({
      name: category.name,
      type: category.type,
      color: category.color,
      icon: category.icon || 'category',
      parentId: category.parentId || null,
      isActive: category.isActive !== false
    });
    setOpenDialog('edit');
  }, []);

  // Open add dialog
  const openAddDialog = useCallback((parentId = null) => {
    setSelectedCategory(null);
    setCategoryForm({
      name: '',
      type: 'expense',
      color: '#6366f1',
      icon: 'category',
      parentId,
      isActive: true
    });
    setOpenDialog('add');
  }, []);

  // Toggle category expansion
  const toggleCategoryExpansion = useCallback((categoryId) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      if (newSet.has(categoryId)) {
        newSet.delete(categoryId);
      } else {
        newSet.add(categoryId);
      }
      return newSet;
    });
  }, []);

  // Export categories
  const exportCategories = useCallback(() => {
    const exportData = {
      exported_at: new Date().toISOString(),
      version: '1.0',
      categories: categories
    };
    
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `categories_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }, [categories]);

  // Import categories
  const importCategories = useCallback((file) => {
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const importData = JSON.parse(e.target.result);
        
        if (!importData.categories || !Array.isArray(importData.categories)) {
          throw new Error('Invalid file format');
        }

        for (const category of importData.categories) {
          const { id, createdAt, updatedAt, ...categoryData } = category;
          await categoryService.createCategory(categoryData);
        }

        await loadCategories();
        setError(null);
        alert('カテゴリのインポートが完了しました');
      } catch (err) {
        console.error('Failed to import categories:', err);
        setError('カテゴリのインポートに失敗しました');
      }
    };
    reader.readAsText(file);
  }, [loadCategories]);

  // Import preset categories
  const importPreset = useCallback(async (presetKey) => {
    try {
      const preset = categoryPresets[presetKey];
      const parentIdMap = {}; // Map parent names to their IDs
      
      // First, create all parent categories
      for (const category of preset.categories) {
        if (!category.parentId) {
          const result = await categoryService.createCategory(category);
          if (result.success) {
            parentIdMap[category.name] = result.data.id;
          }
        }
      }
      
      // Then, create child categories with correct parent IDs
      for (const category of preset.categories) {
        if (category.parentId) {
          const parentId = parentIdMap[category.parentId];
          if (parentId) {
            await categoryService.createCategory({
              ...category,
              parentId: parentId
            });
          }
        }
      }

      await loadCategories();
      setMenuAnchor(null);
      setError(null);
      alert(`${preset.name}カテゴリをインポートしました`);
    } catch (err) {
      console.error('Failed to import preset:', err);
      setError('プリセットのインポートに失敗しました');
    }
  }, [loadCategories]);

  // Get icon for category
  const getIconForCategory = useCallback((iconName) => {
    const iconData = availableIcons.find(icon => icon.name === iconName);
    return iconData ? iconData.icon : '📁';
  }, []);

  // Organize categories into hierarchy
  const organizeCategories = useCallback((categoriesList) => {
    if (!Array.isArray(categoriesList)) {
      return [];
    }
    const parentCategories = categoriesList.filter(cat => !cat.parentId);
    const childCategories = categoriesList.filter(cat => cat.parentId);
    
    return parentCategories.map(parent => ({
      ...parent,
      children: childCategories.filter(child => child.parentId === parent.id)
    }));
  }, []);

  // Render category item
  const renderCategoryItem = useCallback((category, level = 0) => {
    const hasChildren = category.children && category.children.length > 0;
    const isExpanded = expandedCategories.has(category.id);
    
    return (
      <motion.div
        key={category.id}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: -20 }}
      >
        <ListItem
          sx={{
            pl: 2 + level * 2,
            borderRadius: 1,
            mb: 0.5,
            '&:hover': {
              backgroundColor: 'rgba(255, 255, 255, 0.05)',
            },
          }}
        >
          <ListItemIcon sx={{ minWidth: 40 }}>
            <Stack direction="row" alignItems="center" spacing={1}>
              {hasChildren && (
                <IconButton
                  size="small"
                  onClick={() => toggleCategoryExpansion(category.id)}
                >
                  {isExpanded ? <FolderOpenIcon /> : <FolderIcon />}
                </IconButton>
              )}
              <Box sx={{ fontSize: '1.2rem' }}>
                {getIconForCategory(category.icon)}
              </Box>
            </Stack>
          </ListItemIcon>
          
          <ListItemText
            primary={
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <Typography variant="body1">{category.name}</Typography>
                <Chip
                  size="small"
                  label={category.type === 'income' ? '収入' : '支出'}
                  sx={{
                    backgroundColor: category.color,
                    color: 'white',
                    minWidth: 60
                  }}
                />
                {!category.isActive && (
                  <Chip
                    size="small"
                    label="無効"
                    color="default"
                    variant="outlined"
                  />
                )}
              </Box>
            }
            secondary={hasChildren ? `${category.children.length}個のサブカテゴリ` : null}
          />
          
          <ListItemSecondaryAction>
            <Stack direction="row" spacing={0.5}>
              <Tooltip title="サブカテゴリを追加">
                <IconButton
                  size="small"
                  onClick={() => openAddDialog(category.id)}
                >
                  <AddIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="編集">
                <IconButton
                  size="small"
                  onClick={() => openEditDialog(category)}
                >
                  <EditIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="削除">
                <IconButton
                  size="small"
                  onClick={() => deleteCategory(category.id)}
                  color="error"
                >
                  <DeleteIcon />
                </IconButton>
              </Tooltip>
            </Stack>
          </ListItemSecondaryAction>
        </ListItem>
        
        {/* Render children */}
        {hasChildren && isExpanded && (
          <AnimatePresence>
            {category.children.map(child => renderCategoryItem(child, level + 1))}
          </AnimatePresence>
        )}
      </motion.div>
    );
  }, [expandedCategories, openAddDialog, openEditDialog, deleteCategory, toggleCategoryExpansion, getIconForCategory]);

  // Initialize
  useEffect(() => {
    loadCategories();
  }, [loadCategories]);

  const organizedCategories = organizeCategories(categories);

  return (
    <GlassCard>
      <GlassCardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" fontWeight="bold">
            <CategoryIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
            カテゴリ管理
          </Typography>
          <Stack direction="row" spacing={1}>
            <Button
              variant="outlined"
              size="small"
              startIcon={<RefreshIcon />}
              onClick={loadCategories}
            >
              更新
            </Button>
            <Button
              variant="outlined"
              size="small"
              startIcon={<DownloadIcon />}
              onClick={exportCategories}
            >
              エクスポート
            </Button>
            <Button
              variant="outlined"
              size="small"
              startIcon={<MoreVertIcon />}
              onClick={(e) => setMenuAnchor(e.currentTarget)}
            >
              インポート
            </Button>
            <Button
              variant="contained"
              size="small"
              startIcon={<AddIcon />}
              onClick={() => openAddDialog()}
            >
              追加
            </Button>
          </Stack>
        </Box>

        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        {/* Category Statistics */}
        <Grid container spacing={2} sx={{ mb: 3 }}>
          <Grid item xs={6} md={3}>
            <Card>
              <CardContent sx={{ textAlign: 'center', py: 2 }}>
                <Typography variant="h4" color="primary">
                  {categories.length}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  総カテゴリ数
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={6} md={3}>
            <Card>
              <CardContent sx={{ textAlign: 'center', py: 2 }}>
                <Typography variant="h4" color="error">
                  {categories.filter(cat => cat.type === 'expense').length}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  支出カテゴリ
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={6} md={3}>
            <Card>
              <CardContent sx={{ textAlign: 'center', py: 2 }}>
                <Typography variant="h4" color="success">
                  {categories.filter(cat => cat.type === 'income').length}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  収入カテゴリ
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={6} md={3}>
            <Card>
              <CardContent sx={{ textAlign: 'center', py: 2 }}>
                <Typography variant="h4" color="warning">
                  {categories.filter(cat => cat.parentId).length}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  サブカテゴリ
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        <Divider sx={{ my: 2 }} />

        {/* Categories List */}
        {loading ? (
          <Typography>読み込み中...</Typography>
        ) : (
          <List dense>
            <AnimatePresence>
              {organizedCategories.map(category => renderCategoryItem(category))}
            </AnimatePresence>
          </List>
        )}

        {/* Import Menu */}
        <Menu
          anchorEl={menuAnchor}
          open={Boolean(menuAnchor)}
          onClose={() => setMenuAnchor(null)}
        >
          <MenuList dense>
            <MenuItemComponent>
              <input
                type="file"
                accept=".json"
                style={{ display: 'none' }}
                id="import-file"
                onChange={(e) => {
                  if (e.target.files[0]) {
                    importCategories(e.target.files[0]);
                    setMenuAnchor(null);
                  }
                }}
              />
              <label htmlFor="import-file" style={{ cursor: 'pointer', width: '100%' }}>
                <UploadIcon sx={{ mr: 1 }} />
                ファイルからインポート
              </label>
            </MenuItemComponent>
            <Divider />
            {Object.entries(categoryPresets).map(([key, preset]) => (
              <MenuItemComponent key={key} onClick={() => importPreset(key)}>
                <CategoryIcon sx={{ mr: 1 }} />
                {preset.name}
              </MenuItemComponent>
            ))}
          </MenuList>
        </Menu>

        {/* Add/Edit Category Dialog */}
        <Dialog 
          open={openDialog === 'add' || openDialog === 'edit'} 
          onClose={() => setOpenDialog('')}
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle>
            {openDialog === 'edit' ? 'カテゴリを編集' : 'カテゴリを追加'}
          </DialogTitle>
          <DialogContent>
            <Stack spacing={3} sx={{ mt: 1 }}>
              <TextField
                label="カテゴリ名"
                value={categoryForm.name}
                onChange={(e) => setCategoryForm(prev => ({ ...prev, name: e.target.value }))}
                fullWidth
                required
              />
              
              <FormControl fullWidth>
                <InputLabel>タイプ</InputLabel>
                <Select
                  value={categoryForm.type}
                  onChange={(e) => setCategoryForm(prev => ({ ...prev, type: e.target.value }))}
                  label="タイプ"
                >
                  <MenuItem value="expense">支出</MenuItem>
                  <MenuItem value="income">収入</MenuItem>
                </Select>
              </FormControl>

              <FormControl fullWidth>
                <InputLabel>親カテゴリ</InputLabel>
                <Select
                  value={categoryForm.parentId || ''}
                  onChange={(e) => setCategoryForm(prev => ({ ...prev, parentId: e.target.value || null }))}
                  label="親カテゴリ"
                >
                  <MenuItem value="">なし（ルートカテゴリ）</MenuItem>
                  {categories
                    .filter(cat => !cat.parentId && cat.id !== selectedCategory?.id)
                    .map(cat => (
                      <MenuItem key={cat.id} value={cat.id}>
                        {cat.name}
                      </MenuItem>
                    ))}
                </Select>
              </FormControl>

              <TextField
                label="カラー"
                type="color"
                value={categoryForm.color}
                onChange={(e) => setCategoryForm(prev => ({ ...prev, color: e.target.value }))}
                fullWidth
              />

              <FormControl fullWidth>
                <InputLabel>アイコン</InputLabel>
                <Select
                  value={categoryForm.icon}
                  onChange={(e) => setCategoryForm(prev => ({ ...prev, icon: e.target.value }))}
                  label="アイコン"
                  renderValue={(value) => (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <span style={{ fontSize: '1.2rem' }}>
                        {getIconForCategory(value)}
                      </span>
                      {availableIcons.find(icon => icon.name === value)?.label}
                    </Box>
                  )}
                >
                  {availableIcons.map(icon => (
                    <MenuItem key={icon.name} value={icon.name}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <span style={{ fontSize: '1.2rem' }}>{icon.icon}</span>
                        {icon.label}
                      </Box>
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Stack>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setOpenDialog('')} startIcon={<CancelIcon />}>
              キャンセル
            </Button>
            <Button onClick={saveCategory} variant="contained" startIcon={<SaveIcon />}>
              {openDialog === 'edit' ? '更新' : '追加'}
            </Button>
          </DialogActions>
        </Dialog>
      </GlassCardContent>
    </GlassCard>
  );
};

export default CategorySettings;
</file>

<file path="src/components/Settings/DataManagement.js">
import React, { useState, useCallback, useRef } from 'react';
import {
  Box,
  Typography,
  Button,
  Stack,
  Grid,
  Card,
  CardContent,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  LinearProgress,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Chip,
  Divider,
  FormControlLabel,
  Checkbox,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow
} from '@mui/material';
import {
  Storage as StorageIcon,
  Download as DownloadIcon,
  Upload as UploadIcon,
  DeleteForever as DeleteIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Warning as WarningIcon,
  Visibility as VisibilityIcon,
  GetApp as GetAppIcon,
  Publish as PublishIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';
import storage from '../../services/storage';
import settingsService from '../../services/settingsService';

const DataManagement = ({ settings, updateSetting, exportSettingsData, importSettingsData }) => {
  const [exportDialog, setExportDialog] = useState(false);
  const [importDialog, setImportDialog] = useState(false);
  const [clearDataDialog, setClearDataDialog] = useState(false);
  const [integrityDialog, setIntegrityDialog] = useState(false);
  const [progress, setProgress] = useState(0);
  const [processing, setProcessing] = useState(false);
  const [exportOptions, setExportOptions] = useState({
    expenses: true,
    income: true,
    users: true,
    categories: true,
    settings: true,
    format: 'json',
    includeFiles: false
  });
  const [importResult, setImportResult] = useState(null);
  const [integrityResult, setIntegrityResult] = useState(null);
  const [storageInfo, setStorageInfo] = useState(null);
  const fileInputRef = useRef(null);

  // Export formats
  const exportFormats = [
    { value: 'json', label: 'JSON', description: '構造化データ（推奨）' },
    { value: 'csv', label: 'CSV', description: 'スプレッドシート用' }
  ];

  // Get storage information
  const getStorageInfo = useCallback(async () => {
    try {
      // Get storage statistics
      const expenses = (storage.get('expenses') || []).length;
      const income = (storage.get('income') || []).length;
      const users = (storage.get('users') || []).length;
      const categories = (storage.get('categories') || []).length;
      const settingsCount = 1; // Settings is a single object
      
      // Estimate storage usage
      const estimatedSize = (expenses + income) * 500 + users * 200 + categories * 100 + settingsCount * 50; // bytes
      
      setStorageInfo({
        expenses,
        income,
        users,
        categories,
        settings: settingsCount,
        estimatedSize
      });
    } catch (error) {
      console.error('Failed to get storage info:', error);
    }
  }, []);

  // Export all data
  const handleExportData = useCallback(async () => {
    setProcessing(true);
    setProgress(0);
    
    try {
      const exportData = {
        exportedAt: new Date().toISOString(),
        version: '1.0',
        format: exportOptions.format,
        data: {}
      };

      // Export expenses
      if (exportOptions.expenses) {
        setProgress(20);
        exportData.data.expenses = storage.get('expenses') || [];
      }

      // Export income
      if (exportOptions.income) {
        setProgress(40);
        exportData.data.income = storage.get('income') || [];
      }

      // Export users
      if (exportOptions.users) {
        setProgress(60);
        exportData.data.users = storage.get('users') || [];
      }

      // Export categories
      if (exportOptions.categories) {
        setProgress(80);
        exportData.data.categories = storage.get('categories') || [];
      }

      // Export settings
      if (exportOptions.settings) {
        setProgress(90);
        const result = await settingsService.exportSettings();
        exportData.data.settings = result.success ? result.data : {};
      }

      setProgress(100);

      // Create and download file
      const filename = `atture_export_${new Date().toISOString().split('T')[0]}.${exportOptions.format}`;
      let content, mimeType;

      switch (exportOptions.format) {
        case 'json':
          content = JSON.stringify(exportData, null, 2);
          mimeType = 'application/json';
          break;
        case 'csv':
          // Convert to CSV format (simplified)
          content = convertToCSV(exportData);
          mimeType = 'text/csv';
          break;
        case 'xlsx':
          // Would need a library like SheetJS for Excel export
          content = JSON.stringify(exportData, null, 2);
          mimeType = 'application/json';
          break;
        default:
          content = JSON.stringify(exportData, null, 2);
          mimeType = 'application/json';
      }

      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      setExportDialog(false);
      alert('データのエクスポートが完了しました');
    } catch (error) {
      console.error('Export failed:', error);
      alert('エクスポートに失敗しました: ' + error.message);
    } finally {
      setProcessing(false);
      setProgress(0);
    }
  }, [exportOptions, exportSettingsData]);

  // Import data
  const handleImportData = useCallback(async (file) => {
    setProcessing(true);
    setProgress(0);
    
    try {
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const importData = JSON.parse(e.target.result);
          
          if (!importData.data) {
            throw new Error('Invalid import file format');
          }

          const results = {
            expenses: 0,
            income: 0,
            users: 0,
            categories: 0,
            settings: 0,
            errors: []
          };

          // Import expenses
          if (importData.data.expenses) {
            setProgress(20);
            for (const expense of importData.data.expenses) {
              try {
                const { id, createdAt, updatedAt, ...expenseData } = expense;
                storage.addItem('expenses', { ...expenseData, createdAt, updatedAt });
                results.expenses++;
              } catch (error) {
                results.errors.push(`Expense import error: ${error.message}`);
              }
            }
          }

          // Import income
          if (importData.data.income) {
            setProgress(40);
            for (const incomeItem of importData.data.income) {
              try {
                const { id, createdAt, updatedAt, ...incomeData } = incomeItem;
                storage.addItem('income', { ...incomeData, createdAt, updatedAt });
                results.income++;
              } catch (error) {
                results.errors.push(`Income import error: ${error.message}`);
              }
            }
          }

          // Import users
          if (importData.data.users) {
            setProgress(60);
            for (const user of importData.data.users) {
              try {
                const { id, createdAt, updatedAt, ...userData } = user;
                storage.addItem('users', { ...userData, createdAt, updatedAt });
                results.users++;
                // Already added above
              } catch (error) {
                results.errors.push(`User import error: ${error.message}`);
              }
            }
          }

          // Import categories
          if (importData.data.categories) {
            setProgress(80);
            for (const category of importData.data.categories) {
              try {
                const { id, createdAt, updatedAt, ...categoryData } = category;
                storage.addItem('categories', { ...categoryData, createdAt, updatedAt });
                results.categories++;
              } catch (error) {
                results.errors.push(`Category import error: ${error.message}`);
              }
            }
          }

          // Import settings
          if (importData.data.settings) {
            setProgress(90);
            try {
              const settingsResult = await settingsService.importSettings(importData.data);
              results.settings = settingsResult.success ? 1 : 0;
            } catch (error) {
              results.errors.push(`Settings import error: ${error.message}`);
            }
          }

          setProgress(100);
          setImportResult(results);
          setImportDialog(false);
          
        } catch (error) {
          console.error('Import failed:', error);
          alert('インポートに失敗しました: ' + error.message);
        } finally {
          setProcessing(false);
          setProgress(0);
        }
      };
      
      reader.readAsText(file);
    } catch (error) {
      console.error('Import failed:', error);
      alert('インポートに失敗しました: ' + error.message);
      setProcessing(false);
      setProgress(0);
    }
  }, [importSettingsData]);


  // Clear all data
  const handleClearData = useCallback(async () => {
    try {
      setProcessing(true);
      
      storage.set('expenses', []);
      storage.set('income', []);
      storage.set('users', []);
      storage.set('categories', []);
      // Settings are preserved unless explicitly requested
      
      await getStorageInfo();
      setClearDataDialog(false);
      alert('すべてのデータが削除されました');
    } catch (error) {
      console.error('Clear data failed:', error);
      alert('データの削除に失敗しました: ' + error.message);
    } finally {
      setProcessing(false);
    }
  }, [getStorageInfo]);
  
  // Reset to default data with new tax accounting categories
  const handleResetToDefaults = useCallback(async () => {
    try {
      setProcessing(true);
      
      // Clear all data first
      storage.clear();
      
      // Force reinitialization with new default categories
      storage.set('initialized', false);
      storage.initializeDefaultData();
      
      await getStorageInfo();
      setClearDataDialog(false);
      alert('デフォルトの税務会計カテゴリでデータが初期化されました');
      
      // Reload the page to ensure all components pick up the new data
      window.location.reload();
    } catch (error) {
      console.error('Reset to defaults failed:', error);
      alert('デフォルトへのリセットに失敗しました: ' + error.message);
    } finally {
      setProcessing(false);
    }
  }, [getStorageInfo]);

  // Data integrity check
  const handleIntegrityCheck = useCallback(async () => {
    setProcessing(true);
    
    try {
      const issues = [];
      const stats = {
        expenses: 0,
        income: 0,
        users: 0,
        categories: 0,
        orphanedRecords: 0
      };

      // Check expenses
      const expenses = storage.get('expenses') || [];
      stats.expenses = expenses.length;
      
      for (const expense of expenses) {
        if (!expense.categoryId || !expense.userId) {
          issues.push(`Expense ${expense.id}: Missing required fields`);
        }
        // Check if referenced user exists
        const user = storage.findById('users', expense.userId);
        if (!user) {
          issues.push(`Expense ${expense.id}: Referenced user ${expense.userId} not found`);
          stats.orphanedRecords++;
        }
        // Check if referenced category exists
        const category = storage.findById('categories', expense.categoryId);
        if (!category) {
          issues.push(`Expense ${expense.id}: Referenced category ${expense.categoryId} not found`);
          stats.orphanedRecords++;
        }
      }

      // Check income
      const income = storage.get('income') || [];
      stats.income = income.length;
      
      for (const incomeItem of income) {
        if (!incomeItem.categoryId || !incomeItem.userId) {
          issues.push(`Income ${incomeItem.id}: Missing required fields`);
        }
        // Similar checks for income
        const user = storage.findById('users', incomeItem.userId);
        if (!user) {
          issues.push(`Income ${incomeItem.id}: Referenced user ${incomeItem.userId} not found`);
          stats.orphanedRecords++;
        }
      }

      // Check users and categories
      stats.users = (storage.get('users') || []).length;
      stats.categories = (storage.get('categories') || []).length;

      setIntegrityResult({
        stats,
        issues,
        checkedAt: new Date().toISOString()
      });
      setIntegrityDialog(true);
    } catch (error) {
      console.error('Integrity check failed:', error);
      alert('整合性チェックに失敗しました: ' + error.message);
    } finally {
      setProcessing(false);
    }
  }, []);

  // Convert to CSV format (simplified)
  const convertToCSV = useCallback((data) => {
    let csv = '';
    
    // Export expenses to CSV
    if (data.data.expenses && data.data.expenses.length > 0) {
      csv += 'Expenses\n';
      const headers = Object.keys(data.data.expenses[0]);
      csv += headers.join(',') + '\n';
      
      for (const expense of data.data.expenses) {
        const row = headers.map(header => {
          const value = expense[header];
          return typeof value === 'string' ? `"${value.replace(/"/g, '""')}"` : value;
        });
        csv += row.join(',') + '\n';
      }
      csv += '\n';
    }
    
    return csv;
  }, []);

  // Format file size
  const formatFileSize = useCallback((bytes) => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }, []);

  // Initialize
  React.useEffect(() => {
    getStorageInfo();
  }, [getStorageInfo]);

  return (
    <GlassCard>
      <GlassCardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" fontWeight="bold">
            <StorageIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
            データ管理
          </Typography>
          <Button
            variant="outlined"
            size="small"
            startIcon={<VisibilityIcon />}
            onClick={handleIntegrityCheck}
            disabled={processing}
          >
            整合性チェック
          </Button>
        </Box>

        {/* Storage Information */}
        {storageInfo && (
          <Grid container spacing={2} sx={{ mb: 3 }}>
            <Grid item xs={6} md={3}>
              <Card>
                <CardContent sx={{ textAlign: 'center', py: 2 }}>
                  <Typography variant="h4" color="error">
                    {storageInfo.expenses}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    支出記録
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={6} md={3}>
              <Card>
                <CardContent sx={{ textAlign: 'center', py: 2 }}>
                  <Typography variant="h4" color="success">
                    {storageInfo.income}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    収入記録
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={6} md={3}>
              <Card>
                <CardContent sx={{ textAlign: 'center', py: 2 }}>
                  <Typography variant="h4" color="primary">
                    {storageInfo.users}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    ユーザー
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={6} md={3}>
              <Card>
                <CardContent sx={{ textAlign: 'center', py: 2 }}>
                  <Typography variant="h4" color="warning">
                    {formatFileSize(storageInfo.estimatedSize)}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    推定サイズ
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        )}

        <Grid container spacing={3}>
          {/* Export Section */}
          <Grid item xs={12} md={6}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <DownloadIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              データエクスポート
            </Typography>
            
            <Stack spacing={2}>
              <Button
                variant="contained"
                startIcon={<GetAppIcon />}
                onClick={() => setExportDialog(true)}
                fullWidth
                disabled={processing}
              >
                データをエクスポート
              </Button>
              
              <Alert severity="info">
                データを外部ファイルとして保存できます。他のシステムへの移行やバックアップに使用してください。
              </Alert>
            </Stack>
          </Grid>

          {/* Import Section */}
          <Grid item xs={12} md={6}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <UploadIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              データインポート
            </Typography>
            
            <Stack spacing={2}>
              <input
                type="file"
                ref={fileInputRef}
                style={{ display: 'none' }}
                accept=".json,.csv"
                onChange={(e) => {
                  if (e.target.files[0]) {
                    handleImportData(e.target.files[0]);
                  }
                }}
              />
              <Button
                variant="outlined"
                startIcon={<PublishIcon />}
                onClick={() => fileInputRef.current?.click()}
                fullWidth
                disabled={processing}
              >
                ファイルを選択してインポート
              </Button>
              
              <Alert severity="warning">
                インポートは既存のデータに追加されます。重複するデータがある場合は注意してください。
              </Alert>
            </Stack>
          </Grid>


          {/* Clear Data Section */}
          <Grid item xs={12} md={6}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <DeleteIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              データクリア
            </Typography>
            
            <Stack spacing={2}>
              <Button
                variant="outlined"
                startIcon={<DeleteIcon />}
                onClick={() => setClearDataDialog(true)}
                fullWidth
                disabled={processing}
                color="error"
              >
                すべてのデータを削除
              </Button>
              
              <Button
                variant="contained"
                startIcon={<RefreshIcon />}
                onClick={handleResetToDefaults}
                fullWidth
                disabled={processing}
                color="warning"
              >
                税務会計カテゴリで初期化
              </Button>
              
              <Alert severity="error">
                この操作は元に戻せません。実行前に必ずバックアップを作成してください。
              </Alert>
            </Stack>
          </Grid>
        </Grid>

        {/* Processing Progress */}
        {processing && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="body2" gutterBottom>
              処理中... {progress}%
            </Typography>
            <LinearProgress variant="determinate" value={progress} />
          </Box>
        )}

        {/* Export Dialog */}
        <Dialog open={exportDialog} onClose={() => setExportDialog(false)} maxWidth="md" fullWidth>
          <DialogTitle>データエクスポート設定</DialogTitle>
          <DialogContent>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle2" gutterBottom>
                  エクスポートするデータ
                </Typography>
                <Stack spacing={1}>
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={exportOptions.expenses}
                        onChange={(e) => setExportOptions(prev => ({ ...prev, expenses: e.target.checked }))}
                      />
                    }
                    label="支出データ"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={exportOptions.income}
                        onChange={(e) => setExportOptions(prev => ({ ...prev, income: e.target.checked }))}
                      />
                    }
                    label="収入データ"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={exportOptions.users}
                        onChange={(e) => setExportOptions(prev => ({ ...prev, users: e.target.checked }))}
                      />
                    }
                    label="ユーザーデータ"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={exportOptions.categories}
                        onChange={(e) => setExportOptions(prev => ({ ...prev, categories: e.target.checked }))}
                      />
                    }
                    label="カテゴリデータ"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={exportOptions.settings}
                        onChange={(e) => setExportOptions(prev => ({ ...prev, settings: e.target.checked }))}
                      />
                    }
                    label="設定データ"
                  />
                </Stack>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControl fullWidth sx={{ mb: 2 }}>
                  <InputLabel>エクスポート形式</InputLabel>
                  <Select
                    value={exportOptions.format}
                    onChange={(e) => setExportOptions(prev => ({ ...prev, format: e.target.value }))}
                    label="エクスポート形式"
                  >
                    {exportFormats.map((format) => (
                      <MenuItem key={format.value} value={format.value}>
                        <Box>
                          <Typography variant="body2">{format.label}</Typography>
                          <Typography variant="caption" color="text.secondary">
                            {format.description}
                          </Typography>
                        </Box>
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
                
                <Stack spacing={1}>
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={exportOptions.includeFiles}
                        onChange={(e) => setExportOptions(prev => ({ ...prev, includeFiles: e.target.checked }))}
                      />
                    }
                    label="添付ファイルを含める"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={exportOptions.encrypt}
                        onChange={(e) => setExportOptions(prev => ({ ...prev, encrypt: e.target.checked }))}
                      />
                    }
                    label="ファイルを暗号化"
                  />
                </Stack>
              </Grid>
            </Grid>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setExportDialog(false)}>
              キャンセル
            </Button>
            <Button onClick={handleExportData} variant="contained" disabled={processing}>
              エクスポート実行
            </Button>
          </DialogActions>
        </Dialog>

        {/* Clear Data Confirmation Dialog */}
        <Dialog open={clearDataDialog} onClose={() => setClearDataDialog(false)}>
          <DialogTitle>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <WarningIcon color="error" />
              データ削除の確認
            </Box>
          </DialogTitle>
          <DialogContent>
            <Typography gutterBottom>
              すべてのデータを完全に削除しますか？
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              削除されるデータ:
            </Typography>
            <List dense>
              <ListItem>
                <ListItemIcon>
                  <ErrorIcon color="error" />
                </ListItemIcon>
                <ListItemText primary={`支出データ ${storageInfo?.expenses || 0}件`} />
              </ListItem>
              <ListItem>
                <ListItemIcon>
                  <ErrorIcon color="error" />
                </ListItemIcon>
                <ListItemText primary={`収入データ ${storageInfo?.income || 0}件`} />
              </ListItem>
              <ListItem>
                <ListItemIcon>
                  <ErrorIcon color="error" />
                </ListItemIcon>
                <ListItemText primary={`ユーザーデータ ${storageInfo?.users || 0}件`} />
              </ListItem>
              <ListItem>
                <ListItemIcon>
                  <ErrorIcon color="error" />
                </ListItemIcon>
                <ListItemText primary={`カテゴリデータ ${storageInfo?.categories || 0}件`} />
              </ListItem>
            </List>
            <Alert severity="error" sx={{ mt: 2 }}>
              この操作は元に戻せません。必要に応じて事前にバックアップを作成してください。
            </Alert>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setClearDataDialog(false)}>
              キャンセル
            </Button>
            <Button onClick={handleClearData} variant="contained" color="error" disabled={processing}>
              削除実行
            </Button>
          </DialogActions>
        </Dialog>

        {/* Integrity Check Results Dialog */}
        <Dialog open={integrityDialog} onClose={() => setIntegrityDialog(false)} maxWidth="md" fullWidth>
          <DialogTitle>データ整合性チェック結果</DialogTitle>
          <DialogContent>
            {integrityResult && (
              <Box>
                <Typography variant="h6" gutterBottom>
                  統計情報
                </Typography>
                <TableContainer component={Paper} sx={{ mb: 3 }}>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell>データ種別</TableCell>
                        <TableCell align="right">件数</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      <TableRow>
                        <TableCell>支出</TableCell>
                        <TableCell align="right">{integrityResult.stats.expenses}</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell>収入</TableCell>
                        <TableCell align="right">{integrityResult.stats.income}</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell>ユーザー</TableCell>
                        <TableCell align="right">{integrityResult.stats.users}</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell>カテゴリ</TableCell>
                        <TableCell align="right">{integrityResult.stats.categories}</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell>孤立したレコード</TableCell>
                        <TableCell align="right" sx={{ color: integrityResult.stats.orphanedRecords > 0 ? 'error.main' : 'success.main' }}>
                          {integrityResult.stats.orphanedRecords}
                        </TableCell>
                      </TableRow>
                    </TableBody>
                  </Table>
                </TableContainer>

                {integrityResult.issues.length > 0 ? (
                  <Box>
                    <Typography variant="h6" gutterBottom color="error">
                      発見された問題 ({integrityResult.issues.length}件)
                    </Typography>
                    <List dense>
                      {integrityResult.issues.slice(0, 10).map((issue, index) => (
                        <ListItem key={index}>
                          <ListItemIcon>
                            <ErrorIcon color="error" />
                          </ListItemIcon>
                          <ListItemText primary={issue} />
                        </ListItem>
                      ))}
                      {integrityResult.issues.length > 10 && (
                        <ListItem>
                          <ListItemText 
                            primary={`その他 ${integrityResult.issues.length - 10}件の問題があります`}
                            sx={{ fontStyle: 'italic' }}
                          />
                        </ListItem>
                      )}
                    </List>
                  </Box>
                ) : (
                  <Alert severity="success">
                    データに問題は見つかりませんでした。
                  </Alert>
                )}

                <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
                  チェック実行日時: {new Date(integrityResult.checkedAt).toLocaleString()}
                </Typography>
              </Box>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setIntegrityDialog(false)}>
              閉じる
            </Button>
          </DialogActions>
        </Dialog>

        {/* Import Result Dialog */}
        {importResult && (
          <Dialog open={Boolean(importResult)} onClose={() => setImportResult(null)} maxWidth="sm" fullWidth>
            <DialogTitle>インポート結果</DialogTitle>
            <DialogContent>
              <Typography variant="h6" gutterBottom>
                インポート完了
              </Typography>
              <List dense>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon color="success" />
                  </ListItemIcon>
                  <ListItemText primary={`支出: ${importResult.expenses}件`} />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon color="success" />
                  </ListItemIcon>
                  <ListItemText primary={`収入: ${importResult.income}件`} />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon color="success" />
                  </ListItemIcon>
                  <ListItemText primary={`ユーザー: ${importResult.users}件`} />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon color="success" />
                  </ListItemIcon>
                  <ListItemText primary={`カテゴリ: ${importResult.categories}件`} />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon color="success" />
                  </ListItemIcon>
                  <ListItemText primary={`設定: ${importResult.settings}件`} />
                </ListItem>
              </List>
              
              {importResult.errors.length > 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography variant="subtitle2" color="error" gutterBottom>
                    エラー ({importResult.errors.length}件)
                  </Typography>
                  <List dense>
                    {importResult.errors.slice(0, 5).map((error, index) => (
                      <ListItem key={index}>
                        <ListItemIcon>
                          <ErrorIcon color="error" />
                        </ListItemIcon>
                        <ListItemText 
                          primary={error}
                          primaryTypographyProps={{ variant: 'body2' }}
                        />
                      </ListItem>
                    ))}
                    {importResult.errors.length > 5 && (
                      <Typography variant="body2" color="text.secondary">
                        その他 {importResult.errors.length - 5}件のエラー
                      </Typography>
                    )}
                  </List>
                </Box>
              )}
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setImportResult(null)}>
                閉じる
              </Button>
            </DialogActions>
          </Dialog>
        )}
      </GlassCardContent>
    </GlassCard>
  );
};

export default DataManagement;
</file>

<file path="src/components/Settings/GeneralSettings.js">
import React, { useState, useCallback } from 'react';
import {
  Box,
  Typography,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Switch,
  FormControlLabel,
  Stack,
  Grid,
  Card,
  CardContent,
  Slider,
  Alert,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Chip
} from '@mui/material';
import {
  Schedule as ScheduleIcon,
  Notifications as NotificationsIcon,
  Storage as StorageIcon,
  DisplaySettings as DisplayIcon,
  Accessibility as AccessibilityIcon,
  VolumeUp as VolumeIcon,
  Cancel as CancelIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import GlassCard, { GlassCardContent } from '../common/GlassCard';

const GeneralSettings = ({ settings, updateSetting, hasChanges, isModified }) => {
  const [notificationTestOpen, setNotificationTestOpen] = useState(false);
  const [resetDialogOpen, setResetDialogOpen] = useState(false);


  // Date format options
  const dateFormatOptions = [
    { value: 'YYYY-MM-DD', label: '2024-01-15 (ISO)', example: '2024-01-15' },
    { value: 'MM/DD/YYYY', label: '01/15/2024 (US)', example: '01/15/2024' },
    { value: 'DD/MM/YYYY', label: '15/01/2024 (EU)', example: '15/01/2024' },
    { value: 'YYYY年MM月DD日', label: '2024年01月15日 (JP)', example: '2024年01月15日' },
    { value: 'MM月DD日, YYYY年', label: '01月15日, 2024年 (JP)', example: '01月15日, 2024年' }
  ];


  // Default view options
  const defaultViewOptions = [
    { value: 'dashboard', label: 'ダッシュボード', icon: '📊' },
    { value: 'registration', label: '登録', icon: '📝' },
    { value: 'analytics', label: '分析', icon: '📈' },
    { value: 'users', label: 'ユーザー', icon: '👥' }
  ];

  // Items per page options
  const itemsPerPageOptions = [
    { value: 10, label: '10件' },
    { value: 25, label: '25件' },
    { value: 50, label: '50件' },
    { value: 100, label: '100件' }
  ];

  // Handle notification test
  const handleNotificationTest = useCallback(() => {
    if ('Notification' in window) {
      if (Notification.permission === 'granted') {
        new Notification('AttureExpense', {
          body: 'テスト通知です。通知が正常に動作しています。',
          icon: '/favicon.ico'
        });
        setNotificationTestOpen(false);
      } else if (Notification.permission !== 'denied') {
        Notification.requestPermission().then(permission => {
          if (permission === 'granted') {
            new Notification('AttureExpense', {
              body: 'テスト通知です。通知が正常に動作しています。',
              icon: '/favicon.ico'
            });
          }
          setNotificationTestOpen(false);
        });
      } else {
        alert('通知が無効になっています。ブラウザの設定で通知を有効にしてください。');
        setNotificationTestOpen(false);
      }
    } else {
      alert('このブラウザは通知をサポートしていません。');
      setNotificationTestOpen(false);
    }
  }, []);

  // Handle reset to defaults
  const handleResetToDefaults = useCallback(() => {
    updateSetting('dateFormat', 'YYYY-MM-DD');
    updateSetting('notifications', true);
    updateSetting('soundEnabled', true);
    updateSetting('notificationVolume', 50);
    updateSetting('autoSave', true);
    updateSetting('autoSaveInterval', 30);
    updateSetting('defaultView', 'dashboard');
    updateSetting('itemsPerPage', 25);
    updateSetting('showAnimations', true);
    updateSetting('compactMode', false);
    setResetDialogOpen(false);
  }, [updateSetting]);

  // Get current date example
  const getCurrentExample = useCallback(() => {
    const now = new Date();
    const dateFormat = settings.dateFormat || 'YYYY-MM-DD';
    
    let dateExample = '';
    
    switch (dateFormat) {
      case 'YYYY-MM-DD':
        dateExample = now.toISOString().split('T')[0];
        break;
      case 'MM/DD/YYYY':
        dateExample = `${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getDate().toString().padStart(2, '0')}/${now.getFullYear()}`;
        break;
      case 'DD/MM/YYYY':
        dateExample = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getFullYear()}`;
        break;
      case 'YYYY年MM月DD日':
        dateExample = `${now.getFullYear()}年${(now.getMonth() + 1).toString().padStart(2, '0')}月${now.getDate().toString().padStart(2, '0')}日`;
        break;
      case 'MM月DD日, YYYY年':
        dateExample = `${(now.getMonth() + 1).toString().padStart(2, '0')}月${now.getDate().toString().padStart(2, '0')}日, ${now.getFullYear()}年`;
        break;
      default:
        dateExample = now.toLocaleDateString();
    }
    
    return { dateExample };
  }, [settings.dateFormat]);

  const { dateExample } = getCurrentExample();

  return (
    <GlassCard>
      <GlassCardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" fontWeight="bold">
            <DisplayIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
            一般設定
          </Typography>
          <Button
            variant="outlined"
            size="small"
            startIcon={<RefreshIcon />}
            onClick={() => setResetDialogOpen(true)}
            color="warning"
          >
            デフォルトに戻す
          </Button>
        </Box>

        <Grid container spacing={3}>
          {/* Date Format Settings */}
          <Grid item xs={12}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <ScheduleIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              日付表示設定
            </Typography>
            
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <InputLabel>日付形式</InputLabel>
                  <Select
                    value={settings.dateFormat || 'YYYY-MM-DD'}
                    onChange={(e) => updateSetting('dateFormat', e.target.value)}
                    label="日付形式"
                  >
                    {dateFormatOptions.map((format) => (
                      <MenuItem key={format.value} value={format.value}>
                        <Box>
                          <Typography variant="body2">{format.label}</Typography>
                          <Typography variant="caption" color="text.secondary">
                            例: {format.example}
                          </Typography>
                        </Box>
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>

              <Grid item xs={12} md={6}>
                <Alert severity="info">
                  <Typography variant="body2">
                    現在の設定での表示例: <strong>{dateExample}</strong>
                  </Typography>
                </Alert>
              </Grid>
            </Grid>
          </Grid>

          {/* Notification Settings */}
          <Grid item xs={12}>
            <Divider sx={{ my: 2 }} />
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <NotificationsIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              通知設定
            </Typography>
            
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <Stack spacing={2}>
                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.notifications !== false}
                        onChange={(e) => updateSetting('notifications', e.target.checked)}
                      />
                    }
                    label="デスクトップ通知"
                  />
                  
                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.soundEnabled !== false}
                        onChange={(e) => updateSetting('soundEnabled', e.target.checked)}
                      />
                    }
                    label="音声通知"
                  />
                  
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={() => setNotificationTestOpen(true)}
                    disabled={!settings.notifications}
                  >
                    通知テスト
                  </Button>
                </Stack>
              </Grid>

              <Grid item xs={12} md={6}>
                <Box>
                  <Typography variant="body2" gutterBottom>
                    <VolumeIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
                    通知音量: {settings.notificationVolume || 50}%
                  </Typography>
                  <Slider
                    value={settings.notificationVolume || 50}
                    onChange={(e, value) => updateSetting('notificationVolume', value)}
                    min={0}
                    max={100}
                    step={5}
                    valueLabelDisplay="auto"
                    valueLabelFormat={(value) => `${value}%`}
                    disabled={!settings.soundEnabled}
                    marks={[
                      { value: 0, label: '0%' },
                      { value: 50, label: '50%' },
                      { value: 100, label: '100%' }
                    ]}
                  />
                </Box>
              </Grid>
            </Grid>
          </Grid>

          {/* Auto-save Settings */}
          <Grid item xs={12}>
            <Divider sx={{ my: 2 }} />
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <StorageIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              データ管理
            </Typography>
            
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <FormControlLabel
                  control={
                    <Switch
                      checked={settings.autoSave !== false}
                      onChange={(e) => updateSetting('autoSave', e.target.checked)}
                    />
                  }
                  label="自動保存を有効にする"
                />
              </Grid>

              <Grid item xs={12} md={6}>
                <Box>
                  <Typography variant="body2" gutterBottom>
                    自動保存間隔: {settings.autoSaveInterval || 30}秒
                  </Typography>
                  <Slider
                    value={settings.autoSaveInterval || 30}
                    onChange={(e, value) => updateSetting('autoSaveInterval', value)}
                    min={10}
                    max={300}
                    step={10}
                    valueLabelDisplay="auto"
                    valueLabelFormat={(value) => `${value}s`}
                    disabled={!settings.autoSave}
                    marks={[
                      { value: 10, label: '10s' },
                      { value: 30, label: '30s' },
                      { value: 60, label: '60s' },
                      { value: 300, label: '5m' }
                    ]}
                  />
                </Box>
              </Grid>
            </Grid>
          </Grid>

          {/* UI Preferences */}
          <Grid item xs={12}>
            <Divider sx={{ my: 2 }} />
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <AccessibilityIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              UI設定
            </Typography>
            
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <InputLabel>デフォルトページ</InputLabel>
                  <Select
                    value={settings.defaultView || 'dashboard'}
                    onChange={(e) => updateSetting('defaultView', e.target.value)}
                    label="デフォルトページ"
                    renderValue={(value) => {
                      const view = defaultViewOptions.find(v => v.value === value);
                      return (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                          <span>{view?.icon}</span>
                          {view?.label}
                        </Box>
                      );
                    }}
                  >
                    {defaultViewOptions.map((view) => (
                      <MenuItem key={view.value} value={view.value}>
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                          <span>{view.icon}</span>
                          {view.label}
                        </Box>
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>

              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <InputLabel>表示件数</InputLabel>
                  <Select
                    value={settings.itemsPerPage || 25}
                    onChange={(e) => updateSetting('itemsPerPage', e.target.value)}
                    label="表示件数"
                  >
                    {itemsPerPageOptions.map((option) => (
                      <MenuItem key={option.value} value={option.value}>
                        {option.label}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>

              <Grid item xs={12}>
                <Stack direction="row" spacing={3}>
                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.showAnimations !== false}
                        onChange={(e) => updateSetting('showAnimations', e.target.checked)}
                      />
                    }
                    label="アニメーションを有効にする"
                  />
                  
                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.compactMode || false}
                        onChange={(e) => updateSetting('compactMode', e.target.checked)}
                      />
                    }
                    label="コンパクトモード"
                  />
                  
                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.showTutorials !== false}
                        onChange={(e) => updateSetting('showTutorials', e.target.checked)}
                      />
                    }
                    label="チュートリアルを表示"
                  />
                </Stack>
              </Grid>
            </Grid>
          </Grid>
        </Grid>

        {/* Modified indicator */}
        {hasChanges && (
          <Alert severity="info" sx={{ mt: 2 }}>
            一般設定が変更されています。保存してください。
          </Alert>
        )}

        {/* Notification Test Dialog */}
        <Dialog open={notificationTestOpen} onClose={() => setNotificationTestOpen(false)}>
          <DialogTitle>通知テスト</DialogTitle>
          <DialogContent>
            <Typography>
              テスト通知を送信します。ブラウザの通知許可が必要な場合があります。
            </Typography>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setNotificationTestOpen(false)}>
              キャンセル
            </Button>
            <Button onClick={handleNotificationTest} variant="contained">
              テスト実行
            </Button>
          </DialogActions>
        </Dialog>

        {/* Reset Confirmation Dialog */}
        <Dialog open={resetDialogOpen} onClose={() => setResetDialogOpen(false)}>
          <DialogTitle>設定をリセット</DialogTitle>
          <DialogContent>
            <Typography gutterBottom>
              すべての一般設定をデフォルト値に戻しますか？
            </Typography>
            <Typography variant="body2" color="text.secondary">
              この操作は元に戻せません。
            </Typography>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setResetDialogOpen(false)} startIcon={<CancelIcon />}>
              キャンセル
            </Button>
            <Button onClick={handleResetToDefaults} variant="contained" color="warning" startIcon={<RefreshIcon />}>
              リセット実行
            </Button>
          </DialogActions>
        </Dialog>
      </GlassCardContent>
    </GlassCard>
  );
};

export default GeneralSettings;
</file>

<file path="src/components/Settings/ThemeSettings.js">
import React, { useState, useCallback } from 'react';
import {
  Box,
  Typography,
  Switch,
  FormControlLabel,
  Slider,
  Grid,
  Card,
  CardContent,
  Button,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Stack,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Alert,
  Paper,
  Divider
} from '@mui/material';
import {
  Palette as PaletteIcon,
  Brightness4 as DarkModeIcon,
  Brightness7 as LightModeIcon,
  AutoAwesome as AutoIcon,
  FormatSize as FontSizeIcon,
  BlurOn as BlurIcon,
  ColorLens as ColorLensIcon,
  Preview as PreviewIcon,
  Undo as UndoIcon
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';

const ThemeSettings = ({ settings, updateSetting, hasChanges, isModified }) => {
  const [previewMode, setPreviewMode] = useState(false);
  const [colorPickerOpen, setColorPickerOpen] = useState(false);
  const [selectedColorType, setSelectedColorType] = useState('primary');
  const [customColor, setCustomColor] = useState('#6366f1');

  // Color scheme presets
  const colorSchemes = {
    default: {
      name: 'デフォルト',
      colors: {
        primary: '#6366f1',
        secondary: '#ec4899',
        success: '#10b981',
        warning: '#f59e0b',
        error: '#ef4444'
      }
    },
    blue: {
      name: 'ブルー',
      colors: {
        primary: '#3b82f6',
        secondary: '#06b6d4',
        success: '#10b981',
        warning: '#f59e0b',
        error: '#ef4444'
      }
    },
    purple: {
      name: 'パープル',
      colors: {
        primary: '#8b5cf6',
        secondary: '#a855f7',
        success: '#10b981',
        warning: '#f59e0b',
        error: '#ef4444'
      }
    },
    green: {
      name: 'グリーン',
      colors: {
        primary: '#059669',
        secondary: '#10b981',
        success: '#22c55e',
        warning: '#f59e0b',
        error: '#ef4444'
      }
    },
    custom: {
      name: 'カスタム',
      colors: settings.customColors || {}
    }
  };

  // Font size presets
  const fontSizeOptions = [
    { value: 12, label: '小 (12px)' },
    { value: 14, label: '標準 (14px)' },
    { value: 16, label: '大 (16px)' },
    { value: 18, label: '特大 (18px)' },
    { value: 20, label: '巨大 (20px)' }
  ];

  // Handle theme mode change
  const handleThemeChange = useCallback((mode) => {
    updateSetting('theme', mode);
  }, [updateSetting]);

  // Handle color scheme change
  const handleColorSchemeChange = useCallback((scheme) => {
    updateSetting('colorScheme', scheme);
    if (scheme !== 'custom') {
      updateSetting('customColors', colorSchemes[scheme].colors);
    }
  }, [updateSetting]);

  // Handle font size change
  const handleFontSizeChange = useCallback((event, value) => {
    updateSetting('fontSize', value);
  }, [updateSetting]);

  // Handle glass intensity change
  const handleGlassIntensityChange = useCallback((event, value) => {
    updateSetting('glassIntensity', value);
  }, [updateSetting]);

  // Handle custom color change
  const handleCustomColorChange = useCallback((colorType, color) => {
    const currentColors = settings.customColors || colorSchemes.default.colors;
    const newColors = {
      ...currentColors,
      [colorType]: color
    };
    updateSetting('customColors', newColors);
    if (settings.colorScheme !== 'custom') {
      updateSetting('colorScheme', 'custom');
    }
  }, [settings, updateSetting]);

  // Open color picker
  const openColorPicker = useCallback((colorType) => {
    setSelectedColorType(colorType);
    const currentColors = settings.customColors || colorSchemes.default.colors;
    setCustomColor(currentColors[colorType] || '#6366f1');
    setColorPickerOpen(true);
  }, [settings]);

  // Save custom color
  const saveCustomColor = useCallback(() => {
    handleCustomColorChange(selectedColorType, customColor);
    setColorPickerOpen(false);
  }, [selectedColorType, customColor, handleCustomColorChange]);

  // Reset to default theme
  const resetToDefault = useCallback(() => {
    updateSetting('theme', 'light');
    updateSetting('colorScheme', 'default');
    updateSetting('fontSize', 14);
    updateSetting('glassIntensity', 0.25);
    updateSetting('customColors', colorSchemes.default.colors);
  }, [updateSetting]);

  // Get current colors
  const getCurrentColors = useCallback(() => {
    const scheme = settings.colorScheme || 'default';
    if (scheme === 'custom') {
      return settings.customColors || colorSchemes.default.colors;
    }
    return colorSchemes[scheme]?.colors || colorSchemes.default.colors;
  }, [settings]);

  // Preview component
  const ThemePreview = () => {
    const currentColors = getCurrentColors();
    const currentTheme = settings.theme || 'light';
    const currentFontSize = settings.fontSize || 14;
    const currentGlassIntensity = settings.glassIntensity || 0.25;

    return (
      <Paper
        sx={{
          p: 3,
          background: currentTheme === 'dark' 
            ? 'linear-gradient(135deg, #1e293b 0%, #334155 100%)'
            : 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
          color: currentTheme === 'dark' ? '#f1f5f9' : '#1e293b',
          borderRadius: 2,
          position: 'relative',
          overflow: 'hidden'
        }}
      >
        <Box
          sx={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: currentTheme === 'dark'
              ? `rgba(17, 25, 40, ${currentGlassIntensity})`
              : `rgba(255, 255, 255, ${currentGlassIntensity})`,
            backdropFilter: `blur(${currentGlassIntensity * 40}px)`,
            border: currentTheme === 'dark'
              ? `1px solid rgba(255, 255, 255, ${currentGlassIntensity * 0.5})`
              : `1px solid rgba(255, 255, 255, ${currentGlassIntensity * 0.7})`,
            borderRadius: 2
          }}
        />
        <Box sx={{ position: 'relative', zIndex: 1 }}>
          <Typography 
            variant="h6" 
            gutterBottom
            sx={{ fontSize: currentFontSize + 2 }}
          >
            テーマプレビュー
          </Typography>
          <Typography 
            variant="body1" 
            sx={{ fontSize: currentFontSize, mb: 2 }}
          >
            選択したテーマ設定のプレビューです。
          </Typography>
          
          <Stack direction="row" spacing={1} mb={2}>
            {Object.entries(currentColors).map(([colorType, color]) => (
              <Chip
                key={colorType}
                label={colorType}
                sx={{
                  backgroundColor: color,
                  color: 'white',
                  fontSize: currentFontSize - 2
                }}
              />
            ))}
          </Stack>
          
          <Button
            variant="contained"
            sx={{
              background: `linear-gradient(135deg, ${currentColors.primary} 0%, ${currentColors.secondary} 100%)`,
              fontSize: currentFontSize - 2
            }}
          >
            サンプルボタン
          </Button>
        </Box>
      </Paper>
    );
  };

  return (
    <GlassCard>
      <GlassCardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" fontWeight="bold">
            <PaletteIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
            テーマ設定
          </Typography>
          <Stack direction="row" spacing={1}>
            <Button
              variant="outlined"
              size="small"
              startIcon={<PreviewIcon />}
              onClick={() => setPreviewMode(!previewMode)}
            >
              プレビュー
            </Button>
            {hasChanges && (
              <Button
                variant="outlined"
                size="small"
                startIcon={<UndoIcon />}
                onClick={resetToDefault}
                color="warning"
              >
                リセット
              </Button>
            )}
          </Stack>
        </Box>

        <Grid container spacing={3}>
          {/* Theme Mode */}
          <Grid item xs={12}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <DarkModeIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              テーマモード
            </Typography>
            <Grid container spacing={1}>
              {[
                { value: 'light', label: 'ライト', icon: <LightModeIcon /> },
                { value: 'dark', label: 'ダーク', icon: <DarkModeIcon /> },
                { value: 'auto', label: '自動', icon: <AutoIcon /> }
              ].map((mode) => (
                <Grid item xs={4} key={mode.value}>
                  <Card
                    sx={{
                      cursor: 'pointer',
                      border: settings.theme === mode.value ? 2 : 1,
                      borderColor: settings.theme === mode.value ? 'primary.main' : 'divider',
                      transition: 'all 0.3s ease'
                    }}
                    onClick={() => handleThemeChange(mode.value)}
                  >
                    <CardContent sx={{ textAlign: 'center', py: 2 }}>
                      {mode.icon}
                      <Typography variant="body2" sx={{ mt: 1 }}>
                        {mode.label}
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
              ))}
            </Grid>
          </Grid>

          {/* Color Scheme */}
          <Grid item xs={12}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <ColorLensIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              カラースキーム
            </Typography>
            <Grid container spacing={1}>
              {Object.entries(colorSchemes).map(([key, scheme]) => (
                <Grid item xs={6} md={4} key={key}>
                  <Card
                    sx={{
                      cursor: 'pointer',
                      border: settings.colorScheme === key ? 2 : 1,
                      borderColor: settings.colorScheme === key ? 'primary.main' : 'divider',
                      transition: 'all 0.3s ease'
                    }}
                    onClick={() => handleColorSchemeChange(key)}
                  >
                    <CardContent sx={{ py: 2 }}>
                      <Typography variant="body2" fontWeight="bold" gutterBottom>
                        {scheme.name}
                      </Typography>
                      <Stack direction="row" spacing={0.5}>
                        {Object.values(scheme.colors).slice(0, 3).map((color, index) => (
                          <Box
                            key={index}
                            sx={{
                              width: 20,
                              height: 20,
                              backgroundColor: color,
                              borderRadius: 1,
                              border: '1px solid',
                              borderColor: 'divider'
                            }}
                          />
                        ))}
                      </Stack>
                    </CardContent>
                  </Card>
                </Grid>
              ))}
            </Grid>
          </Grid>

          {/* Custom Colors */}
          {settings.colorScheme === 'custom' && (
            <Grid item xs={12}>
              <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
                カスタムカラー
              </Typography>
              <Grid container spacing={2}>
                {Object.entries(getCurrentColors()).map(([colorType, color]) => (
                  <Grid item xs={6} md={4} key={colorType}>
                    <Card
                      sx={{
                        cursor: 'pointer',
                        '&:hover': { transform: 'translateY(-2px)' },
                        transition: 'all 0.3s ease'
                      }}
                      onClick={() => openColorPicker(colorType)}
                    >
                      <CardContent sx={{ textAlign: 'center', py: 2 }}>
                        <Box
                          sx={{
                            width: 40,
                            height: 40,
                            backgroundColor: color,
                            borderRadius: 2,
                            margin: '0 auto 8px',
                            border: '2px solid',
                            borderColor: 'divider'
                          }}
                        />
                        <Typography variant="body2" fontWeight="bold">
                          {colorType}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {color}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            </Grid>
          )}

          {/* Font Size */}
          <Grid item xs={12} md={6}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <FontSizeIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              フォントサイズ
            </Typography>
            <FormControl fullWidth>
              <Select
                value={settings.fontSize || 14}
                onChange={(e) => updateSetting('fontSize', e.target.value)}
              >
                {fontSizeOptions.map((option) => (
                  <MenuItem key={option.value} value={option.value}>
                    {option.label}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          {/* Glass Intensity */}
          <Grid item xs={12} md={6}>
            <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
              <BlurIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              ガラス効果の強度
            </Typography>
            <Box sx={{ px: 1 }}>
              <Slider
                value={settings.glassIntensity || 0.25}
                onChange={handleGlassIntensityChange}
                min={0}
                max={1}
                step={0.05}
                valueLabelDisplay="auto"
                valueLabelFormat={(value) => `${Math.round(value * 100)}%`}
                marks={[
                  { value: 0, label: '0%' },
                  { value: 0.25, label: '25%' },
                  { value: 0.5, label: '50%' },
                  { value: 0.75, label: '75%' },
                  { value: 1, label: '100%' }
                ]}
              />
            </Box>
          </Grid>

          {/* Preview */}
          {previewMode && (
            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <ThemePreview />
            </Grid>
          )}
        </Grid>

        {/* Modified indicator */}
        {(isModified('theme') || isModified('colorScheme') || isModified('fontSize') || isModified('glassIntensity')) && (
          <Alert severity="info" sx={{ mt: 2 }}>
            テーマ設定が変更されています。保存してください。
          </Alert>
        )}

        {/* Color Picker Dialog */}
        <Dialog open={colorPickerOpen} onClose={() => setColorPickerOpen(false)}>
          <DialogTitle>
            カラーを選択 - {selectedColorType}
          </DialogTitle>
          <DialogContent>
            <Box sx={{ pt: 2 }}>
              <TextField
                label="カラーコード"
                type="color"
                value={customColor}
                onChange={(e) => setCustomColor(e.target.value)}
                fullWidth
                sx={{ mb: 2 }}
              />
              <TextField
                label="16進数カラーコード"
                value={customColor}
                onChange={(e) => setCustomColor(e.target.value)}
                fullWidth
                placeholder="#000000"
              />
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setColorPickerOpen(false)}>
              キャンセル
            </Button>
            <Button onClick={saveCustomColor} variant="contained">
              適用
            </Button>
          </DialogActions>
        </Dialog>
      </GlassCardContent>
    </GlassCard>
  );
};

export default ThemeSettings;
</file>

<file path="src/components/UserManagement/UserCard.js">
import React, { useState } from 'react';
import {
  Box,
  Typography,
  Avatar,
  Chip,
  IconButton,
  Stack,
  Tooltip,
  Badge,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
  Divider,
  LinearProgress,
  useTheme,
  alpha,
} from '@mui/material';
import {
  Star as StarIcon,
  StarBorder as StarBorderIcon,
  MoreVert as MoreVertIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Visibility as VisibilityIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Business as BusinessIcon,
  Work as WorkIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  Receipt as ReceiptIcon,
  PersonOff as PersonOffIcon,
  Person as PersonIcon,
  Schedule as ScheduleIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';

const UserCard = ({
  user,
  onEdit,
  onDelete,
  onView,
  onToggleStarred,
  onToggleActive,
  showActions = true,
  compact = false,
  animationDelay = 0,
}) => {
  const theme = useTheme();
  const [anchorEl, setAnchorEl] = useState(null);
  const open = Boolean(anchorEl);

  const handleMenuClick = (event) => {
    event.stopPropagation();
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleCardClick = () => {
    if (onView) {
      onView(user);
    }
  };

  // Helper functions
  const getRoleColor = (role) => {
    const colors = {
      '代表取締役': 'error',
      'マネージャー': 'warning',
      'スタッフ': 'primary',
      'インターン': 'info',
      '契約社員': 'secondary',
      'パートタイム': 'success',
    };
    return colors[role] || 'default';
  };

  const getActivityStatus = (lastActivity) => {
    if (!lastActivity) return { label: '未活動', color: 'default' };
    
    const today = new Date();
    const activityDate = new Date(lastActivity);
    const diffDays = Math.floor((today - activityDate) / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) return { label: '今日', color: 'success' };
    if (diffDays <= 3) return { label: `${diffDays}日前`, color: 'info' };
    if (diffDays <= 7) return { label: `${diffDays}日前`, color: 'warning' };
    return { label: `${diffDays}日前`, color: 'error' };
  };

  const calculateEngagementScore = () => {
    if (!user.transactionCount) return 0;
    const maxTransactions = 100; // Assume max for normalization
    return Math.min((user.transactionCount / maxTransactions) * 100, 100);
  };

  const activityStatus = getActivityStatus(user.lastActivity);
  const engagementScore = calculateEngagementScore();

  // Animation variants
  const cardVariants = {
    hidden: { 
      opacity: 0, 
      y: 20,
      scale: 0.95,
    },
    visible: { 
      opacity: 1, 
      y: 0,
      scale: 1,
      transition: {
        delay: animationDelay,
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
    hover: {
      y: -4,
      scale: 1.02,
      transition: {
        duration: 0.3,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  const avatarVariants = {
    hover: {
      scale: 1.1,
      rotate: 5,
      transition: { duration: 0.3 },
    },
  };

  return (
    <motion.div
      variants={cardVariants}
      initial="hidden"
      animate="visible"
      whileHover="hover"
    >
      <GlassCard
        hover
        gradient={user.isStarred ? 'linear-gradient(135deg, #ffd700 0%, #ffed4a 100%)' : null}
        onClick={handleCardClick}
        sx={{
          cursor: onView ? 'pointer' : 'default',
          opacity: user.isActive ? 1 : 0.7,
          transition: 'all 0.3s ease',
          height: compact ? 'auto' : 'auto',
          minHeight: compact ? 'auto' : 380,
        }}
      >
        <GlassCardContent>
          {/* Header with Avatar and Actions */}
          <Box sx={{ display: 'flex', alignItems: 'flex-start', mb: 2 }}>
            <Badge
              overlap="circular"
              anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
              badgeContent={
                user.isStarred ? (
                  <StarIcon sx={{ color: 'warning.main', fontSize: 16 }} />
                ) : null
              }
            >
              <motion.div variants={avatarVariants}>
                <Avatar
                  src={user.avatar}
                  sx={{ 
                    width: compact ? 48 : 64, 
                    height: compact ? 48 : 64,
                    border: `2px solid ${alpha(theme.palette.primary.main, 0.3)}`,
                  }}
                >
                  {user.name.charAt(0)}
                </Avatar>
              </motion.div>
            </Badge>
            
            <Box sx={{ ml: 2, flex: 1 }}>
              <Tooltip title={user.name}>
                <Typography 
                  variant={compact ? "body1" : "h6"} 
                  fontWeight="bold" 
                  sx={{ 
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    maxWidth: '200px'
                  }}
                >
                  {user.name}
                </Typography>
              </Tooltip>
              <Tooltip title={user.email}>
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ 
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    maxWidth: '200px'
                  }}
                >
                  {user.email}
                </Typography>
              </Tooltip>
            </Box>

            {showActions && (
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                <Tooltip title={user.isStarred ? 'お気に入りから削除' : 'お気に入りに追加'}>
                  <IconButton
                    size="small"
                    onClick={(e) => {
                      e.stopPropagation();
                      onToggleStarred(user.id);
                    }}
                    color={user.isStarred ? 'warning' : 'default'}
                  >
                    {user.isStarred ? <StarIcon /> : <StarBorderIcon />}
                  </IconButton>
                </Tooltip>
                
                <IconButton
                  size="small"
                  onClick={handleMenuClick}
                >
                  <MoreVertIcon />
                </IconButton>
              </Box>
            )}
          </Box>

          {/* Role and Department */}
          <Stack direction="row" spacing={1} sx={{ mb: 2 }}>
            <Chip
              label={user.role}
              color={getRoleColor(user.role)}
              size="small"
              variant="outlined"
              icon={<WorkIcon />}
            />
            <Chip
              label={user.department}
              size="small"
              variant="outlined"
              icon={<BusinessIcon />}
            />
          </Stack>

          {/* Status and Activity */}
          <Stack direction="row" spacing={1} sx={{ mb: 2 }}>
            <Chip
              label={user.isActive ? 'アクティブ' : '非アクティブ'}
              color={user.isActive ? 'success' : 'default'}
              size="small"
              icon={user.isActive ? <PersonIcon /> : <PersonOffIcon />}
            />
            <Chip
              label={activityStatus.label}
              color={activityStatus.color}
              size="small"
              variant="outlined"
              icon={<ScheduleIcon />}
            />
          </Stack>

          {!compact && (
            <>
              {/* Contact Information */}
              <Box sx={{ mb: 2 }}>
                <Stack spacing={1}>
                  {user.phone && (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <PhoneIcon sx={{ fontSize: 16, color: 'text.secondary' }} />
                      <Typography variant="caption" color="text.secondary">
                        {user.phone}
                      </Typography>
                    </Box>
                  )}
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <EmailIcon sx={{ fontSize: 16, color: 'text.secondary' }} />
                    <Tooltip title={user.email}>
                      <Typography 
                        variant="caption" 
                        color="text.secondary"
                        sx={{ 
                          overflow: 'hidden',
                          textOverflow: 'ellipsis',
                          whiteSpace: 'nowrap',
                          maxWidth: '200px'
                        }}
                      >
                        {user.email}
                      </Typography>
                    </Tooltip>
                  </Box>
                </Stack>
              </Box>

              {/* Financial Summary */}
              <Box sx={{ mb: 2 }}>
                <Typography variant="caption" color="text.secondary" gutterBottom>
                  取引サマリー
                </Typography>
                <Stack spacing={1}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                      <TrendingDownIcon sx={{ fontSize: 16, color: 'error.main' }} />
                      <Typography variant="caption">支出</Typography>
                    </Box>
                    <Typography variant="caption" color="error.main" fontWeight="bold">
                      ¥{(user.totalExpenses || 0).toLocaleString()}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                      <TrendingUpIcon sx={{ fontSize: 16, color: 'success.main' }} />
                      <Typography variant="caption">収入</Typography>
                    </Box>
                    <Typography variant="caption" color="success.main" fontWeight="bold">
                      ¥{(user.totalIncome || 0).toLocaleString()}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                      <ReceiptIcon sx={{ fontSize: 16, color: 'info.main' }} />
                      <Typography variant="caption">取引数</Typography>
                    </Box>
                    <Typography variant="caption" fontWeight="bold">
                      {user.transactionCount || 0}
                    </Typography>
                  </Box>
                </Stack>
              </Box>

              {/* Engagement Score */}
              <Box>
                <Typography variant="caption" color="text.secondary" gutterBottom>
                  活動レベル
                </Typography>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <LinearProgress
                    variant="determinate"
                    value={engagementScore}
                    sx={{
                      flex: 1,
                      height: 6,
                      borderRadius: 3,
                      backgroundColor: alpha(theme.palette.primary.main, 0.1),
                      '& .MuiLinearProgress-bar': {
                        borderRadius: 3,
                        background: `linear-gradient(90deg, 
                          ${theme.palette.primary.main} 0%, 
                          ${theme.palette.secondary.main} 100%
                        )`,
                      },
                    }}
                  />
                  <Typography variant="caption" fontWeight="bold">
                    {Math.round(engagementScore)}%
                  </Typography>
                </Box>
              </Box>
            </>
          )}

          {/* Notes Preview (if not compact) */}
          {!compact && user.notes && (
            <Box sx={{ mt: 2, pt: 2, borderTop: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Tooltip title={user.notes}>
                <Typography 
                  variant="caption" 
                  color="text.secondary"
                  sx={{ 
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap',
                    display: 'block'
                  }}
                >
                  {user.notes}
                </Typography>
              </Tooltip>
            </Box>
          )}
        </GlassCardContent>
      </GlassCard>

      {/* Action Menu */}
      <Menu
        anchorEl={anchorEl}
        open={open}
        onClose={handleMenuClose}
        PaperProps={{
          sx: {
            background: alpha(theme.palette.background.paper, 0.9),
            backdropFilter: 'blur(20px)',
            border: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
          },
        }}
      >
        <MenuItem onClick={() => { handleMenuClose(); onView(user); }}>
          <ListItemIcon>
            <VisibilityIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>詳細を表示</ListItemText>
        </MenuItem>
        
        <MenuItem onClick={() => { handleMenuClose(); onEdit(user); }}>
          <ListItemIcon>
            <EditIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>編集</ListItemText>
        </MenuItem>
        
        <MenuItem 
          onClick={() => { 
            handleMenuClose(); 
            onToggleActive(user.id); 
          }}
        >
          <ListItemIcon>
            {user.isActive ? <PersonOffIcon fontSize="small" /> : <PersonIcon fontSize="small" />}
          </ListItemIcon>
          <ListItemText>
            {user.isActive ? '非アクティブ化' : 'アクティブ化'}
          </ListItemText>
        </MenuItem>
        
        <Divider />
        
        <MenuItem 
          onClick={() => { handleMenuClose(); onDelete(user.id); }}
          sx={{ color: 'error.main' }}
        >
          <ListItemIcon>
            <DeleteIcon fontSize="small" color="error" />
          </ListItemIcon>
          <ListItemText>削除</ListItemText>
        </MenuItem>
      </Menu>
    </motion.div>
  );
};

export default UserCard;
</file>

<file path="src/components/UserManagement/UserDialog.js">
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Stack,
  Avatar,
  Chip,
  Grid,
  Divider,
  IconButton,
  Slide,
  useTheme,
  alpha,
  Alert,
  Tabs,
  Tab,
  LinearProgress,
} from '@mui/material';
import {
  Close as CloseIcon,
  Edit as EditIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Business as BusinessIcon,
  Work as WorkIcon,
  Person as PersonIcon,
  PersonOff as PersonOffIcon,
  Star as StarIcon,
  StarBorder as StarBorderIcon,
  Schedule as ScheduleIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  Receipt as ReceiptIcon,
  Analytics as AnalyticsIcon,
  History as HistoryIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';
import UserForm from './UserForm';

const Transition = React.forwardRef(function Transition(props, ref) {
  return <Slide direction="up" ref={ref} {...props} />;
});

const UserDialog = ({
  open = false,
  user = null,
  mode = 'view', // 'view', 'edit', 'create', 'delete'
  onClose,
  onSave,
  onDelete,
  onEdit,
  onToggleStarred,
  onToggleActive,
  loading = false,
}) => {
  const theme = useTheme();
  const [tabValue, setTabValue] = useState(0);
  const [formLoading, setFormLoading] = useState(false);

  // Handle form submission
  const handleFormSubmit = async (formData) => {
    setFormLoading(true);
    try {
      await onSave(formData);
      onClose();
    } catch (error) {
      console.error('Error saving user:', error);
    } finally {
      setFormLoading(false);
    }
  };

  // Handle delete confirmation
  const handleDelete = async () => {
    if (onDelete && user) {
      try {
        await onDelete(user.id);
        onClose();
      } catch (error) {
        console.error('Error deleting user:', error);
      }
    }
  };

  // Get role color
  const getRoleColor = (role) => {
    const colors = {
      '代表取締役': 'error',
      'マネージャー': 'warning',
      'スタッフ': 'primary',
      'インターン': 'info',
      '契約社員': 'secondary',
      'パートタイム': 'success',
    };
    return colors[role] || 'default';
  };

  // Get activity status
  const getActivityStatus = (lastActivity) => {
    if (!lastActivity) return { label: '未活動', color: 'default' };
    
    const today = new Date();
    const activityDate = new Date(lastActivity);
    const diffDays = Math.floor((today - activityDate) / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) return { label: '今日', color: 'success' };
    if (diffDays <= 3) return { label: `${diffDays}日前`, color: 'info' };
    if (diffDays <= 7) return { label: `${diffDays}日前`, color: 'warning' };
    return { label: `${diffDays}日前`, color: 'error' };
  };

  // Calculate engagement score
  const calculateEngagementScore = () => {
    if (!user?.transactionCount) return 0;
    const maxTransactions = 100;
    return Math.min((user.transactionCount / maxTransactions) * 100, 100);
  };

  const activityStatus = user ? getActivityStatus(user.lastActivity) : null;
  const engagementScore = calculateEngagementScore();

  // Animation variants
  const contentVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: {
      opacity: 1,
      x: 0,
      transition: { duration: 0.3 },
    },
  };

  // Render different modes
  const renderContent = () => {
    switch (mode) {
      case 'create':
      case 'edit':
        return (
          <UserForm
            user={mode === 'edit' ? user : null}
            mode={mode}
            onSubmit={handleFormSubmit}
            onCancel={onClose}
            isLoading={formLoading}
          />
        );

      case 'delete':
        return (
          <motion.div
            variants={contentVariants}
            initial="hidden"
            animate="visible"
          >
            <Box sx={{ textAlign: 'center', py: 3 }}>
              <Avatar
                sx={{ 
                  width: 80, 
                  height: 80, 
                  mx: 'auto', 
                  mb: 2,
                  backgroundColor: 'error.main',
                }}
              >
                <PersonOffIcon sx={{ fontSize: 40 }} />
              </Avatar>
              
              <Typography variant="h5" gutterBottom>
                ユーザーを削除しますか？
              </Typography>
              
              <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
                <strong>{user?.name}</strong> を削除すると、関連するデータも失われる可能性があります。
                この操作は取り消せません。
              </Typography>

              <Alert severity="warning" sx={{ mb: 3 }}>
                このユーザーに関連する経費や収入記録がある場合、削除の代わりに非アクティブ化することをお勧めします。
              </Alert>

              <Stack direction="row" spacing={2} justifyContent="center">
                <Button variant="outlined" onClick={onClose}>
                  キャンセル
                </Button>
                <Button
                  variant="contained"
                  color="error"
                  onClick={handleDelete}
                  disabled={loading}
                >
                  {loading ? '削除中...' : '削除する'}
                </Button>
              </Stack>
            </Box>
          </motion.div>
        );

      case 'view':
      default:
        return (
          <motion.div
            variants={contentVariants}
            initial="hidden"
            animate="visible"
          >
            {/* User Header */}
            <motion.div variants={itemVariants}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <Avatar
                  src={user?.avatar}
                  sx={{ 
                    width: 80, 
                    height: 80, 
                    mr: 3,
                    border: `3px solid ${alpha(theme.palette.primary.main, 0.3)}`,
                  }}
                >
                  {user?.name?.charAt(0)}
                </Avatar>
                
                <Box sx={{ flex: 1 }}>
                  <Typography variant="h4" fontWeight="bold" gutterBottom>
                    {user?.name}
                  </Typography>
                  <Stack direction="row" spacing={1} sx={{ mb: 1 }}>
                    <Chip
                      label={user?.role}
                      color={getRoleColor(user?.role)}
                      variant="outlined"
                      icon={<WorkIcon />}
                    />
                    <Chip
                      label={user?.department}
                      variant="outlined"
                      icon={<BusinessIcon />}
                    />
                  </Stack>
                  <Stack direction="row" spacing={1}>
                    <Chip
                      label={user?.isActive ? 'アクティブ' : '非アクティブ'}
                      color={user?.isActive ? 'success' : 'default'}
                      size="small"
                      icon={user?.isActive ? <PersonIcon /> : <PersonOffIcon />}
                    />
                    {activityStatus && (
                      <Chip
                        label={activityStatus.label}
                        color={activityStatus.color}
                        size="small"
                        variant="outlined"
                        icon={<ScheduleIcon />}
                      />
                    )}
                    {user?.isStarred && (
                      <Chip
                        label="お気に入り"
                        color="warning"
                        size="small"
                        icon={<StarIcon />}
                      />
                    )}
                  </Stack>
                </Box>

                {/* Action Buttons */}
                <Stack direction="row" spacing={1}>
                  <IconButton
                    onClick={() => onToggleStarred(user?.id)}
                    color={user?.isStarred ? 'warning' : 'default'}
                  >
                    {user?.isStarred ? <StarIcon /> : <StarBorderIcon />}
                  </IconButton>
                  <IconButton onClick={() => onEdit(user)} color="primary">
                    <EditIcon />
                  </IconButton>
                </Stack>
              </Box>
            </motion.div>

            {/* Tabs */}
            <motion.div variants={itemVariants}>
              <Tabs
                value={tabValue}
                onChange={(e, newValue) => setTabValue(newValue)}
                sx={{ mb: 3 }}
              >
                <Tab label="基本情報" icon={<PersonIcon />} />
                <Tab label="統計" icon={<AnalyticsIcon />} />
                <Tab label="活動履歴" icon={<HistoryIcon />} />
              </Tabs>
            </motion.div>

            {/* Tab Content */}
            <AnimatePresence mode="wait">
              {tabValue === 0 && (
                <motion.div
                  key="basic"
                  variants={itemVariants}
                  initial="hidden"
                  animate="visible"
                  exit="hidden"
                >
                  <Grid container spacing={3}>
                    {/* Contact Information */}
                    <Grid item xs={12} md={6}>
                      <GlassCard>
                        <GlassCardContent>
                          <Typography variant="h6" gutterBottom>
                            連絡先情報
                          </Typography>
                          <Stack spacing={2}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                              <EmailIcon color="primary" />
                              <Box>
                                <Typography variant="body2" color="text.secondary">
                                  メールアドレス
                                </Typography>
                                <Typography variant="body1">
                                  {user?.email}
                                </Typography>
                              </Box>
                            </Box>
                            {user?.phone && (
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                                <PhoneIcon color="primary" />
                                <Box>
                                  <Typography variant="body2" color="text.secondary">
                                    電話番号
                                  </Typography>
                                  <Typography variant="body1">
                                    {user.phone}
                                  </Typography>
                                </Box>
                              </Box>
                            )}
                          </Stack>
                        </GlassCardContent>
                      </GlassCard>
                    </Grid>

                    {/* Work Information */}
                    <Grid item xs={12} md={6}>
                      <GlassCard>
                        <GlassCardContent>
                          <Typography variant="h6" gutterBottom>
                            勤務情報
                          </Typography>
                          <Stack spacing={2}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                              <BusinessIcon color="primary" />
                              <Box>
                                <Typography variant="body2" color="text.secondary">
                                  部署
                                </Typography>
                                <Typography variant="body1">
                                  {user?.department}
                                </Typography>
                              </Box>
                            </Box>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                              <WorkIcon color="primary" />
                              <Box>
                                <Typography variant="body2" color="text.secondary">
                                  役割
                                </Typography>
                                <Typography variant="body1">
                                  {user?.role}
                                </Typography>
                              </Box>
                            </Box>
                            {user?.joinDate && (
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                                <ScheduleIcon color="primary" />
                                <Box>
                                  <Typography variant="body2" color="text.secondary">
                                    入社日
                                  </Typography>
                                  <Typography variant="body1">
                                    {user.joinDate}
                                  </Typography>
                                </Box>
                              </Box>
                            )}
                          </Stack>
                        </GlassCardContent>
                      </GlassCard>
                    </Grid>

                    {/* Notes */}
                    {user?.notes && (
                      <Grid item xs={12}>
                        <GlassCard>
                          <GlassCardContent>
                            <Typography variant="h6" gutterBottom>
                              備考
                            </Typography>
                            <Typography variant="body1">
                              {user.notes}
                            </Typography>
                          </GlassCardContent>
                        </GlassCard>
                      </Grid>
                    )}
                  </Grid>
                </motion.div>
              )}

              {tabValue === 1 && (
                <motion.div
                  key="stats"
                  variants={itemVariants}
                  initial="hidden"
                  animate="visible"
                  exit="hidden"
                >
                  <Grid container spacing={3}>
                    {/* Financial Summary */}
                    <Grid item xs={12} md={6}>
                      <GlassCard>
                        <GlassCardContent>
                          <Typography variant="h6" gutterBottom>
                            取引サマリー
                          </Typography>
                          <Stack spacing={3}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                <TrendingDownIcon color="error" />
                                <Typography variant="body1">総支出</Typography>
                              </Box>
                              <Typography variant="h6" color="error.main" fontWeight="bold">
                                ¥{(user?.totalExpenses || 0).toLocaleString()}
                              </Typography>
                            </Box>
                            
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                <TrendingUpIcon color="success" />
                                <Typography variant="body1">総収入</Typography>
                              </Box>
                              <Typography variant="h6" color="success.main" fontWeight="bold">
                                ¥{(user?.totalIncome || 0).toLocaleString()}
                              </Typography>
                            </Box>
                            
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                <ReceiptIcon color="info" />
                                <Typography variant="body1">取引数</Typography>
                              </Box>
                              <Typography variant="h6" fontWeight="bold">
                                {user?.transactionCount || 0}
                              </Typography>
                            </Box>

                            <Divider />

                            <Box>
                              <Typography variant="body2" color="text.secondary" gutterBottom>
                                差額 (収入 - 支出)
                              </Typography>
                              <Typography 
                                variant="h5" 
                                fontWeight="bold"
                                color={
                                  (user?.totalIncome || 0) - (user?.totalExpenses || 0) >= 0 
                                    ? 'success.main' 
                                    : 'error.main'
                                }
                              >
                                ¥{((user?.totalIncome || 0) - (user?.totalExpenses || 0)).toLocaleString()}
                              </Typography>
                            </Box>
                          </Stack>
                        </GlassCardContent>
                      </GlassCard>
                    </Grid>

                    {/* Engagement Score */}
                    <Grid item xs={12} md={6}>
                      <GlassCard>
                        <GlassCardContent>
                          <Typography variant="h6" gutterBottom>
                            活動レベル
                          </Typography>
                          <Box sx={{ textAlign: 'center', py: 2 }}>
                            <Typography variant="h3" fontWeight="bold" color="primary.main">
                              {Math.round(engagementScore)}%
                            </Typography>
                            <Typography variant="body2" color="text.secondary" gutterBottom>
                              エンゲージメントスコア
                            </Typography>
                            <LinearProgress
                              variant="determinate"
                              value={engagementScore}
                              sx={{
                                height: 8,
                                borderRadius: 4,
                                backgroundColor: alpha(theme.palette.primary.main, 0.1),
                                '& .MuiLinearProgress-bar': {
                                  borderRadius: 4,
                                  background: `linear-gradient(90deg, 
                                    ${theme.palette.primary.main} 0%, 
                                    ${theme.palette.secondary.main} 100%
                                  )`,
                                },
                              }}
                            />
                            <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                              取引数と最終活動日に基づいて計算
                            </Typography>
                          </Box>
                        </GlassCardContent>
                      </GlassCard>
                    </Grid>
                  </Grid>
                </motion.div>
              )}

              {tabValue === 2 && (
                <motion.div
                  key="history"
                  variants={itemVariants}
                  initial="hidden"
                  animate="visible"
                  exit="hidden"
                >
                  <GlassCard>
                    <GlassCardContent>
                      <Typography variant="h6" gutterBottom>
                        活動履歴
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        詳細な活動履歴は今後のアップデートで追加予定です。
                      </Typography>
                    </GlassCardContent>
                  </GlassCard>
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        );
    }
  };

  const getDialogTitle = () => {
    switch (mode) {
      case 'create':
        return '新しいユーザーを追加';
      case 'edit':
        return 'ユーザー情報を編集';
      case 'delete':
        return 'ユーザーを削除';
      case 'view':
      default:
        return 'ユーザー詳細';
    }
  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      TransitionComponent={Transition}
      maxWidth={mode === 'view' ? 'lg' : 'md'}
      fullWidth
      PaperProps={{
        sx: {
          background: alpha(theme.palette.background.paper, 0.9),
          backdropFilter: 'blur(20px)',
          border: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
        },
      }}
    >
      {mode !== 'create' && mode !== 'edit' && (
        <DialogTitle>
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            <Typography variant="h5" fontWeight="bold">
              {getDialogTitle()}
            </Typography>
            <IconButton onClick={onClose}>
              <CloseIcon />
            </IconButton>
          </Box>
        </DialogTitle>
      )}

      <DialogContent sx={{ p: mode === 'create' || mode === 'edit' ? 0 : 3 }}>
        {renderContent()}
      </DialogContent>

      {mode === 'view' && (
        <DialogActions>
          <Button onClick={onClose}>閉じる</Button>
          <Button
            variant="outlined"
            onClick={() => onToggleActive(user?.id)}
            startIcon={user?.isActive ? <PersonOffIcon /> : <PersonIcon />}
          >
            {user?.isActive ? '非アクティブ化' : 'アクティブ化'}
          </Button>
          <Button
            variant="contained"
            onClick={() => onEdit(user)}
            startIcon={<EditIcon />}
            sx={{
              background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
            }}
          >
            編集
          </Button>
        </DialogActions>
      )}
    </Dialog>
  );
};

export default UserDialog;
</file>

<file path="src/components/UserManagement/UserForm.js">
import React, { useState, useEffect } from 'react';
import {
  Box,
  TextField,
  Button,
  Stack,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Grid,
  Avatar,
  IconButton,
  Alert,
  Chip,
  FormHelperText,
  Autocomplete,
  Switch,
  FormControlLabel,
} from '@mui/material';
import {
  Person as PersonIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Business as BusinessIcon,
  Work as WorkIcon,
  PhotoCamera as PhotoCameraIcon,
  Close as CloseIcon,
  Save as SaveIcon,
  Clear as ClearIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';

const ROLES = [
  '代表取締役',
  'マネージャー',
  'スタッフ',
  'インターン',
  '契約社員',
  'パートタイム',
];

const DEPARTMENTS = [
  '経営',
  '営業',
  '開発',
  '経理',
  'マーケティング',
  '人事',
  '総務',
  'サポート',
];

const UserForm = ({
  user = null,
  onSubmit,
  onCancel,
  isLoading = false,
  mode = 'create', // 'create' or 'edit'
}) => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    phone: '',
    role: 'スタッフ',
    department: '',
    notes: '',
    isActive: true,
    avatar: null,
  });

  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [avatarPreview, setAvatarPreview] = useState(null);

  // Initialize form data when user prop changes
  useEffect(() => {
    if (user && mode === 'edit') {
      setFormData({
        name: user.name || '',
        email: user.email || '',
        phone: user.phone || '',
        role: user.role || 'スタッフ',
        department: user.department || '',
        notes: user.notes || '',
        isActive: user.isActive !== false,
        avatar: user.avatar || null,
      });
      if (user.avatar) {
        setAvatarPreview(user.avatar);
      }
    }
  }, [user, mode]);

  // Validation rules
  const validateField = (name, value) => {
    const newErrors = { ...errors };

    switch (name) {
      case 'name':
        if (!value.trim()) {
          newErrors.name = '名前は必須です';
        } else if (value.trim().length < 2) {
          newErrors.name = '名前は2文字以上である必要があります';
        } else {
          delete newErrors.name;
        }
        break;

      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!value.trim()) {
          newErrors.email = 'メールアドレスは必須です';
        } else if (!emailRegex.test(value)) {
          newErrors.email = '有効なメールアドレスを入力してください';
        } else {
          delete newErrors.email;
        }
        break;

      case 'phone':
        if (value && value.trim()) {
          const phoneRegex = /^[\d\-+()\\s]+$/;
          if (!phoneRegex.test(value)) {
            newErrors.phone = '有効な電話番号を入力してください';
          } else {
            delete newErrors.phone;
          }
        } else {
          delete newErrors.phone;
        }
        break;

      case 'department':
        if (!value.trim()) {
          newErrors.department = '部署は必須です';
        } else {
          delete newErrors.department;
        }
        break;

      case 'role':
        if (!value.trim()) {
          newErrors.role = '役割は必須です';
        } else {
          delete newErrors.role;
        }
        break;

      default:
        break;
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle input change
  const handleChange = (name, value) => {
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Mark field as touched
    setTouched(prev => ({ ...prev, [name]: true }));
    
    // Validate field
    validateField(name, value);
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Mark all fields as touched
    const allTouched = Object.keys(formData).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);

    // Validate all fields
    let isValid = true;
    Object.keys(formData).forEach(key => {
      if (!validateField(key, formData[key])) {
        isValid = false;
      }
    });

    if (isValid) {
      try {
        await onSubmit(formData);
      } catch (error) {
        console.error('Error submitting form:', error);
      }
    }
  };

  // Handle avatar upload
  const handleAvatarChange = (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const result = e.target.result;
        setAvatarPreview(result);
        handleChange('avatar', result);
      };
      reader.readAsDataURL(file);
    }
  };

  // Clear avatar
  const clearAvatar = () => {
    setAvatarPreview(null);
    handleChange('avatar', null);
  };

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: {
      opacity: 1,
      x: 0,
      transition: { duration: 0.3 },
    },
  };

  return (
    <motion.div
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <GlassCard>
        <GlassCardContent>
          <Typography
            variant="h5"
            gutterBottom
            sx={{
              background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 700,
              mb: 3,
            }}
          >
            {mode === 'edit' ? 'ユーザー情報を編集' : '新しいユーザーを追加'}
          </Typography>

          <Box component="form" onSubmit={handleSubmit}>
            <Grid container spacing={3}>
              {/* Avatar Section */}
              <Grid item xs={12}>
                <motion.div variants={itemVariants}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
                    <Avatar
                      src={avatarPreview}
                      sx={{ width: 80, height: 80 }}
                    >
                      {formData.name.charAt(0)}
                    </Avatar>
                    <Box>
                      <input
                        accept="image/*"
                        style={{ display: 'none' }}
                        id="avatar-upload"
                        type="file"
                        onChange={handleAvatarChange}
                      />
                      <label htmlFor="avatar-upload">
                        <Button
                          variant="outlined"
                          component="span"
                          startIcon={<PhotoCameraIcon />}
                          size="small"
                        >
                          写真を選択
                        </Button>
                      </label>
                      {avatarPreview && (
                        <IconButton
                          size="small"
                          onClick={clearAvatar}
                          sx={{ ml: 1 }}
                        >
                          <CloseIcon />
                        </IconButton>
                      )}
                    </Box>
                  </Box>
                </motion.div>
              </Grid>

              {/* Basic Information */}
              <Grid item xs={12} md={6}>
                <motion.div variants={itemVariants}>
                  <TextField
                    fullWidth
                    label="名前"
                    value={formData.name}
                    onChange={(e) => handleChange('name', e.target.value)}
                    error={touched.name && !!errors.name}
                    helperText={touched.name && errors.name}
                    required
                    InputProps={{
                      startAdornment: <PersonIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                    }}
                  />
                </motion.div>
              </Grid>

              <Grid item xs={12} md={6}>
                <motion.div variants={itemVariants}>
                  <TextField
                    fullWidth
                    label="メールアドレス"
                    type="email"
                    value={formData.email}
                    onChange={(e) => handleChange('email', e.target.value)}
                    error={touched.email && !!errors.email}
                    helperText={touched.email && errors.email}
                    required
                    InputProps={{
                      startAdornment: <EmailIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                    }}
                  />
                </motion.div>
              </Grid>

              <Grid item xs={12} md={6}>
                <motion.div variants={itemVariants}>
                  <TextField
                    fullWidth
                    label="電話番号"
                    value={formData.phone}
                    onChange={(e) => handleChange('phone', e.target.value)}
                    error={touched.phone && !!errors.phone}
                    helperText={touched.phone && errors.phone}
                    placeholder="090-1234-5678"
                    InputProps={{
                      startAdornment: <PhoneIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                    }}
                  />
                </motion.div>
              </Grid>

              {/* Role and Department */}
              <Grid item xs={12} md={6}>
                <motion.div variants={itemVariants}>
                  <FormControl
                    fullWidth
                    error={touched.role && !!errors.role}
                  >
                    <InputLabel>役割 *</InputLabel>
                    <Select
                      value={formData.role}
                      onChange={(e) => handleChange('role', e.target.value)}
                      label="役割 *"
                      startAdornment={<WorkIcon sx={{ mr: 1, color: 'text.secondary' }} />}
                    >
                      {ROLES.map((role) => (
                        <MenuItem key={role} value={role}>
                          {role}
                        </MenuItem>
                      ))}
                    </Select>
                    {touched.role && errors.role && (
                      <FormHelperText>{errors.role}</FormHelperText>
                    )}
                  </FormControl>
                </motion.div>
              </Grid>

              <Grid item xs={12} md={6}>
                <motion.div variants={itemVariants}>
                  <Autocomplete
                    freeSolo
                    options={DEPARTMENTS}
                    value={formData.department}
                    onChange={(e, newValue) => handleChange('department', newValue || '')}
                    onInputChange={(e, newInputValue) => handleChange('department', newInputValue)}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        label="部署"
                        required
                        error={touched.department && !!errors.department}
                        helperText={touched.department && errors.department}
                        InputProps={{
                          ...params.InputProps,
                          startAdornment: (
                            <>
                              <BusinessIcon sx={{ mr: 1, color: 'text.secondary' }} />
                              {params.InputProps.startAdornment}
                            </>
                          ),
                        }}
                      />
                    )}
                  />
                </motion.div>
              </Grid>

              {/* Status */}
              <Grid item xs={12}>
                <motion.div variants={itemVariants}>
                  <GlassCard opacity={0.1}>
                    <GlassCardContent>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={formData.isActive}
                            onChange={(e) => handleChange('isActive', e.target.checked)}
                            color="primary"
                          />
                        }
                        label={
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            <Typography variant="body1">アクティブユーザー</Typography>
                            <Chip
                              label={formData.isActive ? 'アクティブ' : '非アクティブ'}
                              color={formData.isActive ? 'success' : 'default'}
                              size="small"
                            />
                          </Box>
                        }
                      />
                      <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mt: 1 }}>
                        非アクティブにすると、このユーザーは新規取引で選択できなくなります
                      </Typography>
                    </GlassCardContent>
                  </GlassCard>
                </motion.div>
              </Grid>

              {/* Notes */}
              <Grid item xs={12}>
                <motion.div variants={itemVariants}>
                  <TextField
                    fullWidth
                    label="備考"
                    multiline
                    rows={4}
                    value={formData.notes}
                    onChange={(e) => handleChange('notes', e.target.value)}
                    placeholder="追加情報やメモを入力してください..."
                  />
                </motion.div>
              </Grid>

              {/* Error Display */}
              {Object.keys(errors).length > 0 && (
                <Grid item xs={12}>
                  <motion.div variants={itemVariants}>
                    <Alert severity="error">
                      入力内容を確認してください。必須項目が未入力または無効な値が入力されています。
                    </Alert>
                  </motion.div>
                </Grid>
              )}

              {/* Action Buttons */}
              <Grid item xs={12}>
                <motion.div variants={itemVariants}>
                  <Stack direction="row" spacing={2} justifyContent="flex-end">
                    <Button
                      variant="outlined"
                      onClick={onCancel}
                      startIcon={<ClearIcon />}
                      disabled={isLoading}
                    >
                      キャンセル
                    </Button>
                    <Button
                      type="submit"
                      variant="contained"
                      startIcon={<SaveIcon />}
                      disabled={isLoading || Object.keys(errors).length > 0}
                      sx={{
                        background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                        '&:hover': {
                          opacity: 0.9,
                        },
                      }}
                    >
                      {isLoading ? '保存中...' : (mode === 'edit' ? '更新' : '追加')}
                    </Button>
                  </Stack>
                </motion.div>
              </Grid>
            </Grid>
          </Box>
        </GlassCardContent>
      </GlassCard>
    </motion.div>
  );
};

export default UserForm;
</file>

<file path="src/components/UserManagement/UserList.js">
import React, { useState, useMemo } from 'react';
import {
  Box,
  Grid,
  Typography,
  TextField,
  Button,
  Stack,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  ToggleButton,
  ToggleButtonGroup,
  Checkbox,
  FormControlLabel,
  Tooltip,
  Divider,
  Menu,
  ListItemIcon,
  ListItemText,
  Fab,
  useTheme,
  alpha,
} from '@mui/material';
import {
  Search as SearchIcon,
  ViewModule as ViewModuleIcon,
  ViewList as ViewListIcon,
  ViewComfy as ViewComfyIcon,
  Add as AddIcon,
  Download as DownloadIcon,
  Refresh as RefreshIcon,
  Clear as ClearIcon,
  MoreVert as MoreVertIcon,
  People as PeopleIcon,
  PersonAdd as PersonAddIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../common/GlassCard';
import UserCard from './UserCard';

const SORT_OPTIONS = [
  { value: 'name', label: '名前順' },
  { value: 'role', label: '役割順' },
  { value: 'department', label: '部署順' },
  { value: 'lastActivity', label: '最終活動順' },
  { value: 'transactionCount', label: '取引数順' },
  { value: 'totalExpenses', label: '支出額順' },
  { value: 'totalIncome', label: '収入額順' },
  { value: 'joinDate', label: '入社日順' },
];

const VIEW_MODES = [
  { value: 'grid', icon: ViewModuleIcon, label: 'グリッド表示' },
  { value: 'list', icon: ViewListIcon, label: 'リスト表示' },
  { value: 'compact', icon: ViewComfyIcon, label: 'コンパクト表示' },
];

const UserList = ({
  users = [],
  loading = false,
  onEdit,
  onDelete,
  onView,
  onAdd,
  onToggleStarred,
  onToggleActive,
  onBulkAction,
  onRefresh,
  onExport,
  showAddButton = true,
  showBulkActions = true,
  initialViewMode = 'grid',
}) => {
  const theme = useTheme();

  // State
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('name');
  const [sortOrder, setSortOrder] = useState('asc');
  const [filterRole, setFilterRole] = useState('all');
  const [filterDepartment, setFilterDepartment] = useState('all');
  const [filterStatus, setFilterStatus] = useState('all');
  const [onlyStarred, setOnlyStarred] = useState(false);
  const [viewMode, setViewMode] = useState(initialViewMode);
  const [selectedUsers, setSelectedUsers] = useState([]);
  const [bulkMenuAnchor, setBulkMenuAnchor] = useState(null);

  // Get unique values for filters
  const uniqueRoles = useMemo(() => {
    const roles = [...new Set(users.map(user => user.role))].filter(Boolean);
    return roles.sort();
  }, [users]);

  const uniqueDepartments = useMemo(() => {
    const departments = [...new Set(users.map(user => user.department))].filter(Boolean);
    return departments.sort();
  }, [users]);

  // Filter and sort users
  const filteredAndSortedUsers = useMemo(() => {
    let filtered = users.filter(user => {
      const matchesSearch = 
        user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        user.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
        user.department.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (user.notes && user.notes.toLowerCase().includes(searchTerm.toLowerCase()));

      const matchesRole = filterRole === 'all' || user.role === filterRole;
      const matchesDepartment = filterDepartment === 'all' || user.department === filterDepartment;
      const matchesStatus = 
        filterStatus === 'all' || 
        (filterStatus === 'active' && user.isActive) ||
        (filterStatus === 'inactive' && !user.isActive);
      const matchesStarred = !onlyStarred || user.isStarred;

      return matchesSearch && matchesRole && matchesDepartment && matchesStatus && matchesStarred;
    });

    // Sort
    filtered.sort((a, b) => {
      let aValue = a[sortBy];
      let bValue = b[sortBy];

      // Handle different data types
      if (sortBy === 'lastActivity' || sortBy === 'joinDate') {
        aValue = new Date(aValue || 0);
        bValue = new Date(bValue || 0);
      } else if (typeof aValue === 'string') {
        aValue = aValue.toLowerCase();
        bValue = bValue.toLowerCase();
      } else if (typeof aValue === 'number') {
        aValue = aValue || 0;
        bValue = bValue || 0;
      }

      if (aValue < bValue) return sortOrder === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortOrder === 'asc' ? 1 : -1;
      return 0;
    });

    return filtered;
  }, [users, searchTerm, sortBy, sortOrder, filterRole, filterDepartment, filterStatus, onlyStarred]);

  // Handle user selection
  const handleSelectUser = (userId, selected) => {
    if (selected) {
      setSelectedUsers(prev => [...prev, userId]);
    } else {
      setSelectedUsers(prev => prev.filter(id => id !== userId));
    }
  };

  const handleSelectAll = () => {
    if (selectedUsers.length === filteredAndSortedUsers.length) {
      setSelectedUsers([]);
    } else {
      setSelectedUsers(filteredAndSortedUsers.map(user => user.id));
    }
  };

  // Handle bulk actions
  const handleBulkAction = (action) => {
    if (selectedUsers.length > 0) {
      onBulkAction(action, selectedUsers);
      setSelectedUsers([]);
    }
    setBulkMenuAnchor(null);
  };

  // Clear all filters
  const clearFilters = () => {
    setSearchTerm('');
    setFilterRole('all');
    setFilterDepartment('all');
    setFilterStatus('all');
    setOnlyStarred(false);
    setSortBy('name');
    setSortOrder('asc');
  };

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.05,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3 },
    },
  };

  return (
    <Box>
      {/* Search and Filters */}
      <GlassCard sx={{ mb: 3 }}>
        <GlassCardContent>
          <Grid container spacing={3} alignItems="center">
            {/* Search */}
            <Grid item xs={12} md={4}>
              <TextField
                fullWidth
                placeholder="ユーザーを検索..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                InputProps={{
                  startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />,
                }}
              />
            </Grid>

            {/* Filters */}
            <Grid item xs={12} md={2}>
              <FormControl fullWidth size="small">
                <InputLabel>役割</InputLabel>
                <Select
                  value={filterRole}
                  onChange={(e) => setFilterRole(e.target.value)}
                  label="役割"
                >
                  <MenuItem value="all">すべて</MenuItem>
                  {uniqueRoles.map(role => (
                    <MenuItem key={role} value={role}>{role}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} md={2}>
              <FormControl fullWidth size="small">
                <InputLabel>部署</InputLabel>
                <Select
                  value={filterDepartment}
                  onChange={(e) => setFilterDepartment(e.target.value)}
                  label="部署"
                >
                  <MenuItem value="all">すべて</MenuItem>
                  {uniqueDepartments.map(dept => (
                    <MenuItem key={dept} value={dept}>{dept}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} md={2}>
              <FormControl fullWidth size="small">
                <InputLabel>ステータス</InputLabel>
                <Select
                  value={filterStatus}
                  onChange={(e) => setFilterStatus(e.target.value)}
                  label="ステータス"
                >
                  <MenuItem value="all">すべて</MenuItem>
                  <MenuItem value="active">アクティブ</MenuItem>
                  <MenuItem value="inactive">非アクティブ</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} md={2}>
              <Stack direction="row" spacing={1} alignItems="center">
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={onlyStarred}
                      onChange={(e) => setOnlyStarred(e.target.checked)}
                      size="small"
                    />
                  }
                  label="お気に入りのみ"
                />
              </Stack>
            </Grid>
          </Grid>

          {/* Controls Row */}
          <Stack
            direction={{ xs: 'column', sm: 'row' }}
            justifyContent="space-between"
            alignItems={{ xs: 'stretch', sm: 'center' }}
            spacing={2}
            sx={{ mt: 2 }}
          >
            {/* Sort and View Controls */}
            <Stack direction="row" spacing={2} alignItems="center">
              <FormControl size="small" sx={{ minWidth: 120 }}>
                <InputLabel>並び順</InputLabel>
                <Select
                  value={sortBy}
                  onChange={(e) => setSortBy(e.target.value)}
                  label="並び順"
                >
                  {SORT_OPTIONS.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              <ToggleButtonGroup
                value={sortOrder}
                exclusive
                onChange={(e, value) => value && setSortOrder(value)}
                size="small"
              >
                <ToggleButton value="asc">昇順</ToggleButton>
                <ToggleButton value="desc">降順</ToggleButton>
              </ToggleButtonGroup>

              <ToggleButtonGroup
                value={viewMode}
                exclusive
                onChange={(e, value) => value && setViewMode(value)}
                size="small"
              >
                {VIEW_MODES.map(mode => (
                  <ToggleButton key={mode.value} value={mode.value}>
                    <Tooltip title={mode.label}>
                      <mode.icon />
                    </Tooltip>
                  </ToggleButton>
                ))}
              </ToggleButtonGroup>
            </Stack>

            {/* Action Buttons */}
            <Stack direction="row" spacing={1} alignItems="center">
              <Button
                variant="outlined"
                size="small"
                onClick={clearFilters}
                startIcon={<ClearIcon />}
              >
                フィルターをクリア
              </Button>

              <Button
                variant="outlined"
                size="small"
                onClick={onRefresh}
                startIcon={<RefreshIcon />}
              >
                更新
              </Button>

              {onExport && (
                <Button
                  variant="outlined"
                  size="small"
                  onClick={onExport}
                  startIcon={<DownloadIcon />}
                >
                  エクスポート
                </Button>
              )}
            </Stack>
          </Stack>

          {/* Results Info */}
          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="body2" color="text.secondary">
              {filteredAndSortedUsers.length} 人のユーザーが見つかりました
            </Typography>

            {/* Bulk Actions */}
            {showBulkActions && selectedUsers.length > 0 && (
              <Stack direction="row" spacing={1} alignItems="center">
                <Chip
                  label={`${selectedUsers.length}人を選択中`}
                  color="primary"
                  variant="outlined"
                  onDelete={() => setSelectedUsers([])}
                />
                <Button
                  variant="outlined"
                  size="small"
                  onClick={(e) => setBulkMenuAnchor(e.currentTarget)}
                  startIcon={<MoreVertIcon />}
                >
                  一括操作
                </Button>
              </Stack>
            )}
          </Box>
        </GlassCardContent>
      </GlassCard>

      {/* User List */}
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {loading ? (
          <GlassCard>
            <GlassCardContent>
              <Typography variant="body1" textAlign="center" color="text.secondary">
                ユーザーを読み込み中...
              </Typography>
            </GlassCardContent>
          </GlassCard>
        ) : filteredAndSortedUsers.length === 0 ? (
          <GlassCard>
            <GlassCardContent>
              <Box sx={{ textAlign: 'center', py: 4 }}>
                <PeopleIcon sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
                <Typography variant="h6" color="text.secondary" gutterBottom>
                  ユーザーが見つかりませんでした
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
                  検索条件を変更するか、新しいユーザーを追加してください
                </Typography>
                {showAddButton && (
                  <Button
                    variant="contained"
                    startIcon={<PersonAddIcon />}
                    onClick={onAdd}
                    sx={{
                      background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    }}
                  >
                    ユーザーを追加
                  </Button>
                )}
              </Box>
            </GlassCardContent>
          </GlassCard>
        ) : (
          <Grid container spacing={viewMode === 'compact' ? 2 : 3}>
            {/* Select All Option */}
            {showBulkActions && (
              <Grid item xs={12}>
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={selectedUsers.length === filteredAndSortedUsers.length}
                      indeterminate={
                        selectedUsers.length > 0 && 
                        selectedUsers.length < filteredAndSortedUsers.length
                      }
                      onChange={handleSelectAll}
                    />
                  }
                  label={`すべて選択 (${filteredAndSortedUsers.length}人)`}
                />
              </Grid>
            )}

            <AnimatePresence>
              {filteredAndSortedUsers.map((user, index) => (
                <Grid
                  item
                  xs={12}
                  sm={viewMode === 'list' ? 12 : viewMode === 'compact' ? 6 : 6}
                  md={viewMode === 'list' ? 12 : viewMode === 'compact' ? 6 : 6}
                  lg={viewMode === 'list' ? 12 : viewMode === 'compact' ? 4 : 4}
                  key={user.id}
                >
                  <motion.div variants={itemVariants}>
                    <Box sx={{ position: 'relative' }}>
                      {/* Selection Checkbox */}
                      {showBulkActions && (
                        <Checkbox
                          checked={selectedUsers.includes(user.id)}
                          onChange={(e) => handleSelectUser(user.id, e.target.checked)}
                          sx={{
                            position: 'absolute',
                            top: 8,
                            left: 8,
                            zIndex: 1,
                            backgroundColor: alpha(theme.palette.background.paper, 0.8),
                            '&:hover': {
                              backgroundColor: alpha(theme.palette.background.paper, 0.9),
                            },
                          }}
                        />
                      )}

                      <UserCard
                        user={user}
                        onEdit={onEdit}
                        onDelete={onDelete}
                        onView={onView}
                        onToggleStarred={onToggleStarred}
                        onToggleActive={onToggleActive}
                        compact={viewMode === 'compact'}
                        animationDelay={index * 0.05}
                      />
                    </Box>
                  </motion.div>
                </Grid>
              ))}
            </AnimatePresence>
          </Grid>
        )}
      </motion.div>

      {/* Add User FAB */}
      {showAddButton && (
        <Fab
          color="primary"
          sx={{
            position: 'fixed',
            bottom: 24,
            right: 24,
            background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
            '&:hover': {
              opacity: 0.9,
            },
          }}
          onClick={onAdd}
        >
          <AddIcon />
        </Fab>
      )}

      {/* Bulk Actions Menu */}
      <Menu
        anchorEl={bulkMenuAnchor}
        open={Boolean(bulkMenuAnchor)}
        onClose={() => setBulkMenuAnchor(null)}
        PaperProps={{
          sx: {
            background: alpha(theme.palette.background.paper, 0.9),
            backdropFilter: 'blur(20px)',
            border: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
          },
        }}
      >
        <MenuItem onClick={() => handleBulkAction('activate')}>
          <ListItemIcon>
            <PersonAddIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>アクティブ化</ListItemText>
        </MenuItem>
        
        <MenuItem onClick={() => handleBulkAction('deactivate')}>
          <ListItemIcon>
            <PersonAddIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>非アクティブ化</ListItemText>
        </MenuItem>
        
        <MenuItem onClick={() => handleBulkAction('export')}>
          <ListItemIcon>
            <DownloadIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>エクスポート</ListItemText>
        </MenuItem>
        
        <Divider />
        
        <MenuItem 
          onClick={() => handleBulkAction('delete')}
          sx={{ color: 'error.main' }}
        >
          <ListItemIcon>
            <ClearIcon fontSize="small" color="error" />
          </ListItemIcon>
          <ListItemText>削除</ListItemText>
        </MenuItem>
      </Menu>
    </Box>
  );
};

export default UserList;
</file>

<file path="src/db/services/categoryService.js">
import { db } from '../database.js';

/**
 * Category Service - Handles all category-related database operations
 */

// Validation helpers
const validateCategoryType = (type) => {
  return ['expense', 'income'].includes(type);
};

const validateColor = (color) => {
  const colorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
  return colorRegex.test(color);
};

const validateCategory = (categoryData) => {
  const errors = [];
  
  if (!categoryData.name || categoryData.name.trim().length < 2) {
    errors.push('Category name must be at least 2 characters long');
  }
  
  if (!categoryData.type || !validateCategoryType(categoryData.type)) {
    errors.push('Category type must be either "expense" or "income"');
  }
  
  if (!categoryData.color || !validateColor(categoryData.color)) {
    errors.push('Valid color in hex format is required (e.g., #FF0000)');
  }
  
  if (!categoryData.icon || categoryData.icon.trim().length < 1) {
    errors.push('Icon is required');
  }
  
  return errors;
};

/**
 * Create a new category
 * @param {Object} categoryData - Category data object
 * @returns {Promise<Object>} Created category with ID
 */
export const createCategory = async (categoryData) => {
  try {
    // Validate input
    const validationErrors = validateCategory(categoryData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Check if category name already exists for the same type
    const existingCategory = await db.categories
      .where('name').equals(categoryData.name.trim())
      .and(category => category.type === categoryData.type)
      .first();
    
    if (existingCategory) {
      throw new Error(`Category with name "${categoryData.name}" already exists for ${categoryData.type} type`);
    }

    // Verify parent category if provided
    if (categoryData.parentId) {
      const parentCategory = await db.categories.get(Number(categoryData.parentId));
      if (!parentCategory) {
        throw new Error('Parent category not found');
      }
      if (parentCategory.type !== categoryData.type) {
        throw new Error('Parent category must be of the same type');
      }
    }

    const now = new Date().toISOString();
    const newCategory = {
      name: categoryData.name.trim(),
      type: categoryData.type,
      color: categoryData.color,
      icon: categoryData.icon.trim(),
      parentId: categoryData.parentId ? Number(categoryData.parentId) : null,
      isActive: categoryData.isActive !== undefined ? categoryData.isActive : true,
      createdAt: now,
      updatedAt: now
    };

    const id = await db.categories.add(newCategory);
    return { ...newCategory, id };
  } catch (error) {
    console.error('Error creating category:', error);
    throw error;
  }
};

/**
 * Get category by ID
 * @param {number} id - Category ID
 * @returns {Promise<Object|null>} Category object or null if not found
 */
export const getCategoryById = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid category ID is required');
    }

    const category = await db.categories.get(Number(id));
    return category || null;
  } catch (error) {
    console.error('Error getting category by ID:', error);
    throw error;
  }
};

/**
 * Get all categories with optional filtering
 * @param {Object} filters - Optional filters (type, isActive, parentId)
 * @returns {Promise<Array>} Array of categories
 */
export const getAllCategories = async (filters = {}) => {
  try {
    let query = db.categories.orderBy('name');

    if (filters.type) {
      query = query.filter(category => category.type === filters.type);
    }

    if (filters.isActive !== undefined) {
      query = query.filter(category => category.isActive === filters.isActive);
    }

    if (filters.parentId !== undefined) {
      if (filters.parentId === null) {
        query = query.filter(category => category.parentId === null);
      } else {
        query = query.filter(category => category.parentId === Number(filters.parentId));
      }
    }

    const categories = await query.toArray();
    return categories;
  } catch (error) {
    console.error('Error getting all categories:', error);
    throw error;
  }
};

/**
 * Get categories by type (expense or income)
 * @param {string} type - Category type ('expense' or 'income')
 * @param {boolean} activeOnly - Whether to return only active categories
 * @returns {Promise<Array>} Array of categories
 */
export const getCategoriesByType = async (type, activeOnly = true) => {
  try {
    if (!validateCategoryType(type)) {
      throw new Error('Category type must be either "expense" or "income"');
    }

    let query = db.categories.where('type').equals(type);

    if (activeOnly) {
      query = query.filter(category => category.isActive === true);
    }

    const categories = await query.toArray();
    return categories.sort((a, b) => a.name.localeCompare(b.name));
  } catch (error) {
    console.error('Error getting categories by type:', error);
    throw error;
  }
};

/**
 * Get category hierarchy (parent categories with their children)
 * @param {string} type - Category type ('expense' or 'income')
 * @param {boolean} activeOnly - Whether to return only active categories
 * @returns {Promise<Array>} Array of parent categories with children property
 */
export const getCategoryHierarchy = async (type, activeOnly = true) => {
  try {
    if (!validateCategoryType(type)) {
      throw new Error('Category type must be either "expense" or "income"');
    }

    const categories = await getCategoriesByType(type, activeOnly);
    
    const parentCategories = categories.filter(cat => cat.parentId === null);
    const childCategories = categories.filter(cat => cat.parentId !== null);

    const hierarchy = parentCategories.map(parent => ({
      ...parent,
      children: childCategories.filter(child => child.parentId === parent.id)
    }));

    return hierarchy;
  } catch (error) {
    console.error('Error getting category hierarchy:', error);
    throw error;
  }
};

/**
 * Update category
 * @param {number} id - Category ID
 * @param {Object} updateData - Data to update
 * @returns {Promise<Object>} Updated category object
 */
export const updateCategory = async (id, updateData) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid category ID is required');
    }

    const existingCategory = await getCategoryById(id);
    if (!existingCategory) {
      throw new Error('Category not found');
    }

    // Validate update data
    const mergedData = { ...existingCategory, ...updateData };
    const validationErrors = validateCategory(mergedData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Check for name conflicts if name is being updated
    if (updateData.name && updateData.name !== existingCategory.name) {
      const nameExists = await db.categories
        .where('name').equals(updateData.name.trim())
        .and(category => category.type === (updateData.type || existingCategory.type))
        .and(category => category.id !== Number(id))
        .first();
      
      if (nameExists) {
        throw new Error(`Category with name "${updateData.name}" already exists for this type`);
      }
    }

    // Verify parent category if being updated
    if (updateData.parentId !== undefined) {
      if (updateData.parentId !== null) {
        if (Number(updateData.parentId) === Number(id)) {
          throw new Error('Category cannot be its own parent');
        }
        
        const parentCategory = await getCategoryById(updateData.parentId);
        if (!parentCategory) {
          throw new Error('Parent category not found');
        }
        
        if (parentCategory.type !== (updateData.type || existingCategory.type)) {
          throw new Error('Parent category must be of the same type');
        }
        
        // Check for circular references
        const wouldCreateCircularReference = await checkCircularReference(
          Number(id), 
          Number(updateData.parentId)
        );
        if (wouldCreateCircularReference) {
          throw new Error('This would create a circular reference');
        }
      }
    }

    const updatedFields = {
      ...updateData,
      updatedAt: new Date().toISOString()
    };

    // Clean up fields
    if (updatedFields.name) updatedFields.name = updatedFields.name.trim();
    if (updatedFields.icon) updatedFields.icon = updatedFields.icon.trim();

    await db.categories.update(Number(id), updatedFields);
    
    const updatedCategory = await getCategoryById(id);
    return updatedCategory;
  } catch (error) {
    console.error('Error updating category:', error);
    throw error;
  }
};

/**
 * Check if setting a parent would create a circular reference
 * @param {number} categoryId - Category ID
 * @param {number} parentId - Proposed parent ID
 * @returns {Promise<boolean>} True if circular reference would be created
 */
const checkCircularReference = async (categoryId, parentId) => {
  try {
    let currentParentId = parentId;
    const visited = new Set();

    while (currentParentId && !visited.has(currentParentId)) {
      if (currentParentId === categoryId) {
        return true; // Circular reference found
      }
      
      visited.add(currentParentId);
      const parentCategory = await getCategoryById(currentParentId);
      currentParentId = parentCategory?.parentId;
    }

    return false;
  } catch (error) {
    console.error('Error checking circular reference:', error);
    return true; // Err on the side of caution
  }
};

/**
 * Soft delete category (set isActive to false)
 * @param {number} id - Category ID
 * @returns {Promise<boolean>} Success status
 */
export const deactivateCategory = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid category ID is required');
    }

    const category = await getCategoryById(id);
    if (!category) {
      throw new Error('Category not found');
    }

    // Check if category is being used in expenses or income
    const isUsedInExpenses = await db.expenses.where('categoryId').equals(Number(id)).count();
    const isUsedInIncome = await db.income.where('categoryId').equals(Number(id)).count();

    if (isUsedInExpenses > 0 || isUsedInIncome > 0) {
      throw new Error('Cannot deactivate category that is being used in expense or income records');
    }

    // Deactivate all child categories
    const childCategories = await db.categories.where('parentId').equals(Number(id)).toArray();
    for (const child of childCategories) {
      await db.categories.update(child.id, {
        isActive: false,
        updatedAt: new Date().toISOString()
      });
    }

    await db.categories.update(Number(id), {
      isActive: false,
      updatedAt: new Date().toISOString()
    });

    return true;
  } catch (error) {
    console.error('Error deactivating category:', error);
    throw error;
  }
};

/**
 * Reactivate category
 * @param {number} id - Category ID
 * @returns {Promise<boolean>} Success status
 */
export const reactivateCategory = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid category ID is required');
    }

    const category = await getCategoryById(id);
    if (!category) {
      throw new Error('Category not found');
    }

    // If category has a parent, ensure parent is active
    if (category.parentId) {
      const parentCategory = await getCategoryById(category.parentId);
      if (!parentCategory || !parentCategory.isActive) {
        throw new Error('Cannot reactivate category with inactive parent');
      }
    }

    await db.categories.update(Number(id), {
      isActive: true,
      updatedAt: new Date().toISOString()
    });

    return true;
  } catch (error) {
    console.error('Error reactivating category:', error);
    throw error;
  }
};

/**
 * Permanently delete category (use with caution)
 * @param {number} id - Category ID
 * @returns {Promise<boolean>} Success status
 */
export const deleteCategory = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid category ID is required');
    }

    const category = await getCategoryById(id);
    if (!category) {
      throw new Error('Category not found');
    }

    // Check if category is being used
    const isUsedInExpenses = await db.expenses.where('categoryId').equals(Number(id)).count();
    const isUsedInIncome = await db.income.where('categoryId').equals(Number(id)).count();
    const hasChildren = await db.categories.where('parentId').equals(Number(id)).count();

    if (isUsedInExpenses > 0 || isUsedInIncome > 0) {
      throw new Error('Cannot delete category that is being used in expense or income records');
    }

    if (hasChildren > 0) {
      throw new Error('Cannot delete category that has child categories');
    }

    await db.categories.delete(Number(id));
    return true;
  } catch (error) {
    console.error('Error deleting category:', error);
    throw error;
  }
};

/**
 * Search categories by name
 * @param {string} searchTerm - Search term
 * @param {string} type - Optional category type filter
 * @returns {Promise<Array>} Array of matching categories
 */
export const searchCategories = async (searchTerm, type = null) => {
  try {
    if (!searchTerm || searchTerm.trim().length < 2) {
      throw new Error('Search term must be at least 2 characters long');
    }

    const term = searchTerm.toLowerCase().trim();
    
    let categories = await db.categories
      .filter(category => category.name.toLowerCase().includes(term))
      .toArray();

    if (type) {
      categories = categories.filter(category => category.type === type);
    }

    return categories.sort((a, b) => a.name.localeCompare(b.name));
  } catch (error) {
    console.error('Error searching categories:', error);
    throw error;
  }
};

/**
 * Get category statistics
 * @param {string} type - Optional category type filter
 * @returns {Promise<Object>} Category statistics
 */
export const getCategoryStats = async (type = null) => {
  try {
    let query = db.categories;
    
    if (type) {
      query = query.where('type').equals(type);
    }

    const categories = await query.toArray();
    
    const total = categories.length;
    const active = categories.filter(cat => cat.isActive).length;
    const inactive = categories.filter(cat => !cat.isActive).length;
    const parents = categories.filter(cat => cat.parentId === null).length;
    const children = categories.filter(cat => cat.parentId !== null).length;

    const typeStats = categories.reduce((stats, category) => {
      stats[category.type] = (stats[category.type] || 0) + 1;
      return stats;
    }, {});

    // Get usage statistics
    const expenseUsage = {};
    const incomeUsage = {};
    
    const expenses = await db.expenses.toArray();
    const incomes = await db.income.toArray();
    
    expenses.forEach(expense => {
      expenseUsage[expense.categoryId] = (expenseUsage[expense.categoryId] || 0) + 1;
    });
    
    incomes.forEach(income => {
      incomeUsage[income.categoryId] = (incomeUsage[income.categoryId] || 0) + 1;
    });

    return {
      total,
      active,
      inactive,
      parents,
      children,
      typeStats,
      expenseUsage,
      incomeUsage
    };
  } catch (error) {
    console.error('Error getting category stats:', error);
    throw error;
  }
};

/**
 * Get category usage count
 * @param {number} id - Category ID
 * @returns {Promise<Object>} Usage statistics for the category
 */
export const getCategoryUsage = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid category ID is required');
    }

    const category = await getCategoryById(id);
    if (!category) {
      throw new Error('Category not found');
    }

    const expenseCount = await db.expenses.where('categoryId').equals(Number(id)).count();
    const incomeCount = await db.income.where('categoryId').equals(Number(id)).count();

    return {
      categoryId: Number(id),
      categoryName: category.name,
      categoryType: category.type,
      expenseCount,
      incomeCount,
      totalUsage: expenseCount + incomeCount
    };
  } catch (error) {
    console.error('Error getting category usage:', error);
    throw error;
  }
};

const categoryService = {
  createCategory,
  getCategoryById,
  getAllCategories,
  getCategoriesByType,
  getCategoryHierarchy,
  updateCategory,
  deactivateCategory,
  reactivateCategory,
  deleteCategory,
  searchCategories,
  getCategoryStats,
  getCategoryUsage
};

export default categoryService;
</file>

<file path="src/db/services/expenseService.js">
import { db } from '../database.js';

/**
 * Expense Service - Handles all expense-related database operations
 */

// Validation helpers
const validateAmount = (amount) => {
  return !isNaN(amount) && parseFloat(amount) >= 0;
};

const validateDate = (date) => {
  return date && !isNaN(new Date(date).getTime());
};

const validateExpense = (expenseData) => {
  const errors = [];
  
  if (!validateDate(expenseData.date)) {
    errors.push('Valid date is required');
  }
  
  if (!expenseData.categoryId || !Number.isInteger(Number(expenseData.categoryId))) {
    errors.push('Valid category ID is required');
  }
  
  if (!validateAmount(expenseData.amount)) {
    errors.push('Valid amount is required (must be 0 or positive)');
  }
  
  if (!expenseData.description || expenseData.description.trim().length < 3) {
    errors.push('Description must be at least 3 characters long');
  }
  
  if (!expenseData.userId || !Number.isInteger(Number(expenseData.userId))) {
    errors.push('Valid user ID is required');
  }
  
  return errors;
};

/**
 * Create a new expense
 * @param {Object} expenseData - Expense data object
 * @returns {Promise<Object>} Created expense with ID
 */
export const createExpense = async (expenseData) => {
  try {
    // Validate input
    const validationErrors = validateExpense(expenseData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Verify user exists
    const user = await db.users.get(Number(expenseData.userId));
    if (!user) {
      throw new Error('User not found');
    }

    // Verify category exists and is an expense category
    const category = await db.categories.get(Number(expenseData.categoryId));
    if (!category) {
      throw new Error('Category not found');
    }
    if (category.type !== 'expense') {
      throw new Error('Selected category is not an expense category');
    }

    const now = new Date().toISOString();
    const newExpense = {
      date: new Date(expenseData.date).toISOString().split('T')[0], // Store as YYYY-MM-DD
      categoryId: Number(expenseData.categoryId),
      amount: parseFloat(expenseData.amount),
      description: expenseData.description.trim(),
      userId: Number(expenseData.userId),
      tags: Array.isArray(expenseData.tags) ? expenseData.tags : [],
      receiptIds: Array.isArray(expenseData.receiptIds) ? expenseData.receiptIds : [],
      status: expenseData.status || 'pending',
      approvedBy: expenseData.approvedBy || null,
      approvedAt: expenseData.approvedAt || null,
      rejectedReason: expenseData.rejectedReason || null,
      createdAt: now,
      updatedAt: now
    };

    const id = await db.expenses.add(newExpense);
    return { ...newExpense, id };
  } catch (error) {
    console.error('Error creating expense:', error);
    throw error;
  }
};

/**
 * Get expense by ID with related data
 * @param {number} id - Expense ID
 * @returns {Promise<Object|null>} Expense object with user and category data
 */
export const getExpenseById = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid expense ID is required');
    }

    const expense = await db.expenses.get(Number(id));
    if (!expense) {
      return null;
    }

    // Get related data
    const [user, category, receipts] = await Promise.all([
      db.users.get(expense.userId),
      db.categories.get(expense.categoryId),
      expense.receiptIds?.length > 0 
        ? db.files.where('id').anyOf(expense.receiptIds).toArray()
        : []
    ]);

    return {
      ...expense,
      user,
      category,
      receipts
    };
  } catch (error) {
    console.error('Error getting expense by ID:', error);
    throw error;
  }
};

/**
 * Get expenses with filtering and pagination
 * @param {Object} options - Query options
 * @returns {Promise<Object>} Object containing expenses array and metadata
 */
export const getExpenses = async (options = {}) => {
  try {
    const {
      userId,
      categoryId,
      status,
      dateFrom,
      dateTo,
      tags,
      minAmount,
      maxAmount,
      limit = 50,
      offset = 0,
      sortBy = 'date',
      sortOrder = 'desc'
    } = options;

    let query = db.expenses;

    // Apply filters
    if (userId) {
      query = query.where('userId').equals(Number(userId));
    }

    if (categoryId) {
      query = query.where('categoryId').equals(Number(categoryId));
    }

    if (status) {
      query = query.where('status').equals(status);
    }

    // Get all matching expenses
    let expenses = await query.toArray();

    // Apply additional filters
    if (dateFrom) {
      expenses = expenses.filter(expense => expense.date >= dateFrom);
    }

    if (dateTo) {
      expenses = expenses.filter(expense => expense.date <= dateTo);
    }

    if (minAmount !== undefined) {
      expenses = expenses.filter(expense => expense.amount >= minAmount);
    }

    if (maxAmount !== undefined) {
      expenses = expenses.filter(expense => expense.amount <= maxAmount);
    }

    if (tags && tags.length > 0) {
      expenses = expenses.filter(expense => 
        tags.some(tag => expense.tags.includes(tag))
      );
    }

    // Sort expenses
    expenses.sort((a, b) => {
      let aValue = a[sortBy];
      let bValue = b[sortBy];
      
      if (sortBy === 'date') {
        aValue = new Date(aValue).getTime();
        bValue = new Date(bValue).getTime();
      }
      
      if (sortOrder === 'desc') {
        return bValue > aValue ? 1 : -1;
      } else {
        return aValue > bValue ? 1 : -1;
      }
    });

    const total = expenses.length;
    const paginatedExpenses = expenses.slice(offset, offset + limit);

    // Get related data for paginated results
    const expensesWithData = await Promise.all(
      paginatedExpenses.map(async (expense) => {
        const [user, category] = await Promise.all([
          db.users.get(expense.userId),
          db.categories.get(expense.categoryId)
        ]);
        
        return {
          ...expense,
          user,
          category
        };
      })
    );

    return {
      expenses: expensesWithData,
      total,
      offset,
      limit,
      hasMore: offset + limit < total
    };
  } catch (error) {
    console.error('Error getting expenses:', error);
    throw error;
  }
};

/**
 * Update expense
 * @param {number} id - Expense ID
 * @param {Object} updateData - Data to update
 * @returns {Promise<Object>} Updated expense object
 */
export const updateExpense = async (id, updateData) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid expense ID is required');
    }

    const existingExpense = await db.expenses.get(Number(id));
    if (!existingExpense) {
      throw new Error('Expense not found');
    }

    // Validate update data
    const mergedData = { ...existingExpense, ...updateData };
    const validationErrors = validateExpense(mergedData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Verify category if being updated
    if (updateData.categoryId) {
      const category = await db.categories.get(Number(updateData.categoryId));
      if (!category || category.type !== 'expense') {
        throw new Error('Invalid expense category');
      }
    }

    const updatedFields = {
      ...updateData,
      updatedAt: new Date().toISOString()
    };

    // Clean up fields
    if (updatedFields.description) {
      updatedFields.description = updatedFields.description.trim();
    }
    if (updatedFields.date) {
      updatedFields.date = new Date(updatedFields.date).toISOString().split('T')[0];
    }
    if (updatedFields.amount !== undefined) {
      updatedFields.amount = parseFloat(updatedFields.amount);
    }

    await db.expenses.update(Number(id), updatedFields);
    
    const updatedExpense = await getExpenseById(id);
    return updatedExpense;
  } catch (error) {
    console.error('Error updating expense:', error);
    throw error;
  }
};

/**
 * Delete expense
 * @param {number} id - Expense ID
 * @returns {Promise<boolean>} Success status
 */
export const deleteExpense = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid expense ID is required');
    }

    const expense = await db.expenses.get(Number(id));
    if (!expense) {
      throw new Error('Expense not found');
    }

    await db.expenses.delete(Number(id));
    return true;
  } catch (error) {
    console.error('Error deleting expense:', error);
    throw error;
  }
};

/**
 * Approve expense
 * @param {number} id - Expense ID
 * @param {number} approvedById - ID of user approving
 * @returns {Promise<Object>} Updated expense object
 */
export const approveExpense = async (id, approvedById) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid expense ID is required');
    }

    if (!approvedById || !Number.isInteger(Number(approvedById))) {
      throw new Error('Valid approver ID is required');
    }

    const expense = await db.expenses.get(Number(id));
    if (!expense) {
      throw new Error('Expense not found');
    }

    const approver = await db.users.get(Number(approvedById));
    if (!approver) {
      throw new Error('Approver not found');
    }

    await db.expenses.update(Number(id), {
      status: 'approved',
      approvedBy: Number(approvedById),
      approvedAt: new Date().toISOString(),
      rejectedReason: null,
      updatedAt: new Date().toISOString()
    });

    return await getExpenseById(id);
  } catch (error) {
    console.error('Error approving expense:', error);
    throw error;
  }
};

/**
 * Reject expense
 * @param {number} id - Expense ID
 * @param {number} rejectedById - ID of user rejecting
 * @param {string} reason - Rejection reason
 * @returns {Promise<Object>} Updated expense object
 */
export const rejectExpense = async (id, rejectedById, reason) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid expense ID is required');
    }

    if (!rejectedById || !Number.isInteger(Number(rejectedById))) {
      throw new Error('Valid rejector ID is required');
    }

    if (!reason || reason.trim().length < 3) {
      throw new Error('Rejection reason is required (minimum 3 characters)');
    }

    const expense = await db.expenses.get(Number(id));
    if (!expense) {
      throw new Error('Expense not found');
    }

    const rejector = await db.users.get(Number(rejectedById));
    if (!rejector) {
      throw new Error('Rejector not found');
    }

    await db.expenses.update(Number(id), {
      status: 'rejected',
      approvedBy: Number(rejectedById),
      approvedAt: new Date().toISOString(),
      rejectedReason: reason.trim(),
      updatedAt: new Date().toISOString()
    });

    return await getExpenseById(id);
  } catch (error) {
    console.error('Error rejecting expense:', error);
    throw error;
  }
};

/**
 * Get expense statistics
 * @param {Object} filters - Optional filters (userId, dateFrom, dateTo)
 * @returns {Promise<Object>} Expense statistics
 */
export const getExpenseStats = async (filters = {}) => {
  try {
    let query = db.expenses;

    if (filters.userId) {
      query = query.where('userId').equals(Number(filters.userId));
    }

    let expenses = await query.toArray();

    // Apply date filters
    if (filters.dateFrom) {
      expenses = expenses.filter(expense => expense.date >= filters.dateFrom);
    }

    if (filters.dateTo) {
      expenses = expenses.filter(expense => expense.date <= filters.dateTo);
    }

    const total = expenses.length;
    const totalAmount = expenses.reduce((sum, expense) => sum + expense.amount, 0);
    const averageAmount = total > 0 ? totalAmount / total : 0;

    const statusStats = expenses.reduce((stats, expense) => {
      stats[expense.status] = (stats[expense.status] || 0) + 1;
      return stats;
    }, {});

    const categoryStats = expenses.reduce((stats, expense) => {
      stats[expense.categoryId] = (stats[expense.categoryId] || 0) + 1;
      return stats;
    }, {});

    const monthlyStats = expenses.reduce((stats, expense) => {
      const month = expense.date.substring(0, 7); // YYYY-MM
      if (!stats[month]) {
        stats[month] = { count: 0, amount: 0 };
      }
      stats[month].count += 1;
      stats[month].amount += expense.amount;
      return stats;
    }, {});

    return {
      total,
      totalAmount,
      averageAmount,
      statusStats,
      categoryStats,
      monthlyStats
    };
  } catch (error) {
    console.error('Error getting expense stats:', error);
    throw error;
  }
};

/**
 * Search expenses by description
 * @param {string} searchTerm - Search term
 * @param {Object} filters - Optional additional filters
 * @returns {Promise<Array>} Array of matching expenses
 */
export const searchExpenses = async (searchTerm, filters = {}) => {
  try {
    if (!searchTerm || searchTerm.trim().length < 2) {
      throw new Error('Search term must be at least 2 characters long');
    }

    const term = searchTerm.toLowerCase().trim();
    
    let expenses = await db.expenses
      .filter(expense => 
        expense.description.toLowerCase().includes(term) ||
        expense.tags.some(tag => tag.toLowerCase().includes(term))
      )
      .toArray();

    // Apply additional filters
    if (filters.userId) {
      expenses = expenses.filter(expense => expense.userId === Number(filters.userId));
    }

    if (filters.status) {
      expenses = expenses.filter(expense => expense.status === filters.status);
    }

    // Get related data
    const expensesWithData = await Promise.all(
      expenses.map(async (expense) => {
        const [user, category] = await Promise.all([
          db.users.get(expense.userId),
          db.categories.get(expense.categoryId)
        ]);
        
        return {
          ...expense,
          user,
          category
        };
      })
    );

    return expensesWithData;
  } catch (error) {
    console.error('Error searching expenses:', error);
    throw error;
  }
};

export default {
  createExpense,
  getExpenseById,
  getExpenses,
  updateExpense,
  deleteExpense,
  approveExpense,
  rejectExpense,
  getExpenseStats,
  searchExpenses
};
</file>

<file path="src/db/services/incomeService.js">
import { db } from '../database.js';

/**
 * Income Service - Handles all income-related database operations
 */

// Validation helpers
const validateAmount = (amount) => {
  return !isNaN(amount) && parseFloat(amount) >= 0;
};

const validateDate = (date) => {
  return date && !isNaN(new Date(date).getTime());
};

const validateIncome = (incomeData) => {
  const errors = [];
  
  if (!validateDate(incomeData.date)) {
    errors.push('Valid date is required');
  }
  
  if (!incomeData.categoryId || !Number.isInteger(Number(incomeData.categoryId))) {
    errors.push('Valid category ID is required');
  }
  
  if (!incomeData.source || incomeData.source.trim().length < 2) {
    errors.push('Source must be at least 2 characters long');
  }
  
  if (!validateAmount(incomeData.amount)) {
    errors.push('Valid amount is required (must be 0 or positive)');
  }
  
  if (!incomeData.description || incomeData.description.trim().length < 3) {
    errors.push('Description must be at least 3 characters long');
  }
  
  if (!incomeData.userId || !Number.isInteger(Number(incomeData.userId))) {
    errors.push('Valid user ID is required');
  }
  
  return errors;
};

/**
 * Create a new income record
 * @param {Object} incomeData - Income data object
 * @returns {Promise<Object>} Created income with ID
 */
export const createIncome = async (incomeData) => {
  try {
    // Validate input
    const validationErrors = validateIncome(incomeData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Verify user exists
    const user = await db.users.get(Number(incomeData.userId));
    if (!user) {
      throw new Error('User not found');
    }

    // Verify category exists and is an income category
    const category = await db.categories.get(Number(incomeData.categoryId));
    if (!category) {
      throw new Error('Category not found');
    }
    if (category.type !== 'income') {
      throw new Error('Selected category is not an income category');
    }

    const now = new Date().toISOString();
    const newIncome = {
      date: new Date(incomeData.date).toISOString().split('T')[0], // Store as YYYY-MM-DD
      categoryId: Number(incomeData.categoryId),
      source: incomeData.source.trim(),
      amount: parseFloat(incomeData.amount),
      description: incomeData.description.trim(),
      userId: Number(incomeData.userId),
      tags: Array.isArray(incomeData.tags) ? incomeData.tags : [],
      fileIds: Array.isArray(incomeData.fileIds) ? incomeData.fileIds : [],
      status: incomeData.status || 'confirmed',
      createdAt: now,
      updatedAt: now
    };

    const id = await db.income.add(newIncome);
    return { ...newIncome, id };
  } catch (error) {
    console.error('Error creating income:', error);
    throw error;
  }
};

/**
 * Get income by ID with related data
 * @param {number} id - Income ID
 * @returns {Promise<Object|null>} Income object with user and category data
 */
export const getIncomeById = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid income ID is required');
    }

    const income = await db.income.get(Number(id));
    if (!income) {
      return null;
    }

    // Get related data
    const [user, category, files] = await Promise.all([
      db.users.get(income.userId),
      db.categories.get(income.categoryId),
      income.fileIds?.length > 0 
        ? db.files.where('id').anyOf(income.fileIds).toArray()
        : []
    ]);

    return {
      ...income,
      user,
      category,
      files
    };
  } catch (error) {
    console.error('Error getting income by ID:', error);
    throw error;
  }
};

/**
 * Get income records with filtering and pagination
 * @param {Object} options - Query options
 * @returns {Promise<Object>} Object containing income array and metadata
 */
export const getIncome = async (options = {}) => {
  try {
    const {
      userId,
      categoryId,
      status,
      source,
      dateFrom,
      dateTo,
      tags,
      minAmount,
      maxAmount,
      limit = 50,
      offset = 0,
      sortBy = 'date',
      sortOrder = 'desc'
    } = options;

    let query = db.income;

    // Apply filters
    if (userId) {
      query = query.where('userId').equals(Number(userId));
    }

    if (categoryId) {
      query = query.where('categoryId').equals(Number(categoryId));
    }

    if (status) {
      query = query.where('status').equals(status);
    }

    // Get all matching income records
    let incomeRecords = await query.toArray();

    // Apply additional filters
    if (dateFrom) {
      incomeRecords = incomeRecords.filter(income => income.date >= dateFrom);
    }

    if (dateTo) {
      incomeRecords = incomeRecords.filter(income => income.date <= dateTo);
    }

    if (minAmount !== undefined) {
      incomeRecords = incomeRecords.filter(income => income.amount >= minAmount);
    }

    if (maxAmount !== undefined) {
      incomeRecords = incomeRecords.filter(income => income.amount <= maxAmount);
    }

    if (source) {
      incomeRecords = incomeRecords.filter(income => 
        income.source.toLowerCase().includes(source.toLowerCase())
      );
    }

    if (tags && tags.length > 0) {
      incomeRecords = incomeRecords.filter(income => 
        tags.some(tag => income.tags.includes(tag))
      );
    }

    // Sort income records
    incomeRecords.sort((a, b) => {
      let aValue = a[sortBy];
      let bValue = b[sortBy];
      
      if (sortBy === 'date') {
        aValue = new Date(aValue).getTime();
        bValue = new Date(bValue).getTime();
      }
      
      if (sortOrder === 'desc') {
        return bValue > aValue ? 1 : -1;
      } else {
        return aValue > bValue ? 1 : -1;
      }
    });

    const total = incomeRecords.length;
    const paginatedIncome = incomeRecords.slice(offset, offset + limit);

    // Get related data for paginated results
    const incomeWithData = await Promise.all(
      paginatedIncome.map(async (income) => {
        const [user, category] = await Promise.all([
          db.users.get(income.userId),
          db.categories.get(income.categoryId)
        ]);
        
        return {
          ...income,
          user,
          category
        };
      })
    );

    return {
      income: incomeWithData,
      total,
      offset,
      limit,
      hasMore: offset + limit < total
    };
  } catch (error) {
    console.error('Error getting income:', error);
    throw error;
  }
};

/**
 * Update income record
 * @param {number} id - Income ID
 * @param {Object} updateData - Data to update
 * @returns {Promise<Object>} Updated income object
 */
export const updateIncome = async (id, updateData) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid income ID is required');
    }

    const existingIncome = await db.income.get(Number(id));
    if (!existingIncome) {
      throw new Error('Income record not found');
    }

    // Validate update data
    const mergedData = { ...existingIncome, ...updateData };
    const validationErrors = validateIncome(mergedData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Verify category if being updated
    if (updateData.categoryId) {
      const category = await db.categories.get(Number(updateData.categoryId));
      if (!category || category.type !== 'income') {
        throw new Error('Invalid income category');
      }
    }

    const updatedFields = {
      ...updateData,
      updatedAt: new Date().toISOString()
    };

    // Clean up fields
    if (updatedFields.description) {
      updatedFields.description = updatedFields.description.trim();
    }
    if (updatedFields.source) {
      updatedFields.source = updatedFields.source.trim();
    }
    if (updatedFields.date) {
      updatedFields.date = new Date(updatedFields.date).toISOString().split('T')[0];
    }
    if (updatedFields.amount !== undefined) {
      updatedFields.amount = parseFloat(updatedFields.amount);
    }

    await db.income.update(Number(id), updatedFields);
    
    const updatedIncome = await getIncomeById(id);
    return updatedIncome;
  } catch (error) {
    console.error('Error updating income:', error);
    throw error;
  }
};

/**
 * Delete income record
 * @param {number} id - Income ID
 * @returns {Promise<boolean>} Success status
 */
export const deleteIncome = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid income ID is required');
    }

    const income = await db.income.get(Number(id));
    if (!income) {
      throw new Error('Income record not found');
    }

    await db.income.delete(Number(id));
    return true;
  } catch (error) {
    console.error('Error deleting income:', error);
    throw error;
  }
};

/**
 * Get income statistics
 * @param {Object} filters - Optional filters (userId, dateFrom, dateTo)
 * @returns {Promise<Object>} Income statistics
 */
export const getIncomeStats = async (filters = {}) => {
  try {
    let query = db.income;

    if (filters.userId) {
      query = query.where('userId').equals(Number(filters.userId));
    }

    let incomeRecords = await query.toArray();

    // Apply date filters
    if (filters.dateFrom) {
      incomeRecords = incomeRecords.filter(income => income.date >= filters.dateFrom);
    }

    if (filters.dateTo) {
      incomeRecords = incomeRecords.filter(income => income.date <= filters.dateTo);
    }

    const total = incomeRecords.length;
    const totalAmount = incomeRecords.reduce((sum, income) => sum + income.amount, 0);
    const averageAmount = total > 0 ? totalAmount / total : 0;

    const statusStats = incomeRecords.reduce((stats, income) => {
      stats[income.status] = (stats[income.status] || 0) + 1;
      return stats;
    }, {});

    const categoryStats = incomeRecords.reduce((stats, income) => {
      stats[income.categoryId] = (stats[income.categoryId] || 0) + 1;
      return stats;
    }, {});

    const sourceStats = incomeRecords.reduce((stats, income) => {
      stats[income.source] = (stats[income.source] || 0) + 1;
      return stats;
    }, {});

    const monthlyStats = incomeRecords.reduce((stats, income) => {
      const month = income.date.substring(0, 7); // YYYY-MM
      if (!stats[month]) {
        stats[month] = { count: 0, amount: 0 };
      }
      stats[month].count += 1;
      stats[month].amount += income.amount;
      return stats;
    }, {});

    return {
      total,
      totalAmount,
      averageAmount,
      statusStats,
      categoryStats,
      sourceStats,
      monthlyStats
    };
  } catch (error) {
    console.error('Error getting income stats:', error);
    throw error;
  }
};

/**
 * Search income records by description or source
 * @param {string} searchTerm - Search term
 * @param {Object} filters - Optional additional filters
 * @returns {Promise<Array>} Array of matching income records
 */
export const searchIncome = async (searchTerm, filters = {}) => {
  try {
    if (!searchTerm || searchTerm.trim().length < 2) {
      throw new Error('Search term must be at least 2 characters long');
    }

    const term = searchTerm.toLowerCase().trim();
    
    let incomeRecords = await db.income
      .filter(income => 
        income.description.toLowerCase().includes(term) ||
        income.source.toLowerCase().includes(term) ||
        income.tags.some(tag => tag.toLowerCase().includes(term))
      )
      .toArray();

    // Apply additional filters
    if (filters.userId) {
      incomeRecords = incomeRecords.filter(income => income.userId === Number(filters.userId));
    }

    if (filters.status) {
      incomeRecords = incomeRecords.filter(income => income.status === filters.status);
    }

    // Get related data
    const incomeWithData = await Promise.all(
      incomeRecords.map(async (income) => {
        const [user, category] = await Promise.all([
          db.users.get(income.userId),
          db.categories.get(income.categoryId)
        ]);
        
        return {
          ...income,
          user,
          category
        };
      })
    );

    return incomeWithData;
  } catch (error) {
    console.error('Error searching income:', error);
    throw error;
  }
};

/**
 * Get income by source
 * @param {string} source - Income source
 * @param {Object} options - Additional options (userId, dateFrom, dateTo)
 * @returns {Promise<Array>} Array of income records from the source
 */
export const getIncomeBySource = async (source, options = {}) => {
  try {
    if (!source || source.trim().length < 2) {
      throw new Error('Valid source is required (minimum 2 characters)');
    }

    let query = db.income.where('source').equals(source.trim());
    
    let incomeRecords = await query.toArray();

    // Apply additional filters
    if (options.userId) {
      incomeRecords = incomeRecords.filter(income => income.userId === Number(options.userId));
    }

    if (options.dateFrom) {
      incomeRecords = incomeRecords.filter(income => income.date >= options.dateFrom);
    }

    if (options.dateTo) {
      incomeRecords = incomeRecords.filter(income => income.date <= options.dateTo);
    }

    // Get related data
    const incomeWithData = await Promise.all(
      incomeRecords.map(async (income) => {
        const [user, category] = await Promise.all([
          db.users.get(income.userId),
          db.categories.get(income.categoryId)
        ]);
        
        return {
          ...income,
          user,
          category
        };
      })
    );

    return incomeWithData;
  } catch (error) {
    console.error('Error getting income by source:', error);
    throw error;
  }
};

/**
 * Get unique income sources
 * @param {number} userId - Optional user ID filter
 * @returns {Promise<Array>} Array of unique sources
 */
export const getIncomeSources = async (userId = null) => {
  try {
    let query = db.income;
    
    if (userId) {
      query = query.where('userId').equals(Number(userId));
    }

    const incomeRecords = await query.toArray();
    const sources = [...new Set(incomeRecords.map(income => income.source))];
    
    return sources.sort();
  } catch (error) {
    console.error('Error getting income sources:', error);
    throw error;
  }
};

export default {
  createIncome,
  getIncomeById,
  getIncome,
  updateIncome,
  deleteIncome,
  getIncomeStats,
  searchIncome,
  getIncomeBySource,
  getIncomeSources
};
</file>

<file path="src/db/services/settingsService.js">
import { db } from '../database.js';

/**
 * Settings Service - Handles all settings-related database operations
 */

// Valid setting types
const SETTING_TYPES = ['string', 'number', 'boolean', 'json', 'array'];

// Default settings configuration
const DEFAULT_SETTINGS = {
  currency: { type: 'string', defaultValue: 'JPY', description: 'Default currency' },
  dateFormat: { type: 'string', defaultValue: 'YYYY-MM-DD', description: 'Date format preference' },
  theme: { type: 'string', defaultValue: 'light', description: 'UI theme preference' },
  language: { type: 'string', defaultValue: 'ja', description: 'Language preference' },
  autoBackup: { type: 'boolean', defaultValue: true, description: 'Enable automatic backup' },
  maxFileSize: { type: 'number', defaultValue: 10485760, description: 'Maximum file size in bytes (10MB)' },
  expenseApprovalRequired: { type: 'boolean', defaultValue: false, description: 'Require approval for expenses' },
  defaultExpenseStatus: { type: 'string', defaultValue: 'pending', description: 'Default status for new expenses' },
  expenseCategories: { type: 'array', defaultValue: [], description: 'Favorite expense categories' },
  incomeCategories: { type: 'array', defaultValue: [], description: 'Favorite income categories' },
  recentTags: { type: 'array', defaultValue: [], description: 'Recently used tags' },
  emailNotifications: { type: 'boolean', defaultValue: true, description: 'Enable email notifications' },
  pushNotifications: { type: 'boolean', defaultValue: false, description: 'Enable push notifications' },
  dataRetentionDays: { type: 'number', defaultValue: 365, description: 'Data retention period in days' },
  exportFormat: { type: 'string', defaultValue: 'csv', description: 'Default export format' }
};

// Validation helpers
const validateSettingType = (type) => {
  return SETTING_TYPES.includes(type);
};

const validateSettingValue = (value, type) => {
  switch (type) {
    case 'string':
      return typeof value === 'string';
    case 'number':
      return typeof value === 'number' && !isNaN(value);
    case 'boolean':
      return typeof value === 'boolean';
    case 'json':
      try {
        JSON.parse(JSON.stringify(value));
        return true;
      } catch {
        return false;
      }
    case 'array':
      return Array.isArray(value);
    default:
      return false;
  }
};

const parseSettingValue = (value, type) => {
  switch (type) {
    case 'string':
      return String(value);
    case 'number':
      return Number(value);
    case 'boolean':
      if (typeof value === 'string') {
        return value.toLowerCase() === 'true';
      }
      return Boolean(value);
    case 'json':
      return typeof value === 'string' ? JSON.parse(value) : value;
    case 'array':
      if (typeof value === 'string') {
        try {
          return JSON.parse(value);
        } catch {
          return [];
        }
      }
      return Array.isArray(value) ? value : [];
    default:
      return value;
  }
};

const serializeSettingValue = (value, type) => {
  switch (type) {
    case 'json':
    case 'array':
      return JSON.stringify(value);
    default:
      return String(value);
  }
};

/**
 * Get setting by key
 * @param {string} key - Setting key
 * @returns {Promise<any>} Setting value or default value
 */
export const getSetting = async (key) => {
  try {
    if (!key || typeof key !== 'string') {
      throw new Error('Valid setting key is required');
    }

    const setting = await db.settings.where('key').equals(key).first();
    
    if (!setting) {
      // Return default value if available
      const defaultSetting = DEFAULT_SETTINGS[key];
      return defaultSetting ? defaultSetting.defaultValue : null;
    }

    return parseSettingValue(setting.value, setting.type);
  } catch (error) {
    console.error('Error getting setting:', error);
    throw error;
  }
};

/**
 * Set setting value
 * @param {string} key - Setting key
 * @param {any} value - Setting value
 * @param {string} type - Setting type (optional, will be inferred from default settings)
 * @param {string} description - Setting description (optional)
 * @returns {Promise<Object>} Updated setting object
 */
export const setSetting = async (key, value, type = null, description = null) => {
  try {
    if (!key || typeof key !== 'string') {
      throw new Error('Valid setting key is required');
    }

    // Get type and description from defaults if not provided
    const defaultSetting = DEFAULT_SETTINGS[key];
    const settingType = type || (defaultSetting ? defaultSetting.type : 'string');
    const settingDescription = description || (defaultSetting ? defaultSetting.description : '');

    if (!validateSettingType(settingType)) {
      throw new Error(`Invalid setting type: ${settingType}. Must be one of: ${SETTING_TYPES.join(', ')}`);
    }

    if (!validateSettingValue(value, settingType)) {
      throw new Error(`Invalid value for type ${settingType}`);
    }

    const serializedValue = serializeSettingValue(value, settingType);
    const now = new Date().toISOString();

    const existingSetting = await db.settings.where('key').equals(key).first();

    if (existingSetting) {
      // Update existing setting
      await db.settings.update(existingSetting.id, {
        value: serializedValue,
        type: settingType,
        description: settingDescription,
        updatedAt: now
      });

      return {
        ...existingSetting,
        value: serializedValue,
        type: settingType,
        description: settingDescription,
        updatedAt: now
      };
    } else {
      // Create new setting
      const newSetting = {
        key,
        value: serializedValue,
        type: settingType,
        description: settingDescription,
        createdAt: now,
        updatedAt: now
      };

      const id = await db.settings.add(newSetting);
      return { ...newSetting, id };
    }
  } catch (error) {
    console.error('Error setting value:', error);
    throw error;
  }
};

/**
 * Get multiple settings by keys
 * @param {Array<string>} keys - Array of setting keys
 * @returns {Promise<Object>} Object with key-value pairs
 */
export const getSettings = async (keys) => {
  try {
    if (!Array.isArray(keys)) {
      throw new Error('Keys must be an array');
    }

    const settings = {};
    
    for (const key of keys) {
      settings[key] = await getSetting(key);
    }

    return settings;
  } catch (error) {
    console.error('Error getting settings:', error);
    throw error;
  }
};

/**
 * Get all settings
 * @returns {Promise<Object>} Object with all settings as key-value pairs
 */
export const getAllSettings = async () => {
  try {
    const settingsRecords = await db.settings.toArray();
    const settings = {};

    settingsRecords.forEach(setting => {
      settings[setting.key] = parseSettingValue(setting.value, setting.type);
    });

    // Add default values for missing settings
    Object.keys(DEFAULT_SETTINGS).forEach(key => {
      if (!(key in settings)) {
        settings[key] = DEFAULT_SETTINGS[key].defaultValue;
      }
    });

    return settings;
  } catch (error) {
    console.error('Error getting all settings:', error);
    throw error;
  }
};

/**
 * Set multiple settings at once
 * @param {Object} settingsObject - Object with key-value pairs
 * @returns {Promise<Array>} Array of updated setting objects
 */
export const setSettings = async (settingsObject) => {
  try {
    if (!settingsObject || typeof settingsObject !== 'object') {
      throw new Error('Settings object is required');
    }

    const results = [];

    for (const [key, value] of Object.entries(settingsObject)) {
      const result = await setSetting(key, value);
      results.push(result);
    }

    return results;
  } catch (error) {
    console.error('Error setting multiple settings:', error);
    throw error;
  }
};

/**
 * Delete setting
 * @param {string} key - Setting key
 * @returns {Promise<boolean>} Success status
 */
export const deleteSetting = async (key) => {
  try {
    if (!key || typeof key !== 'string') {
      throw new Error('Valid setting key is required');
    }

    const setting = await db.settings.where('key').equals(key).first();
    
    if (!setting) {
      throw new Error('Setting not found');
    }

    await db.settings.delete(setting.id);
    return true;
  } catch (error) {
    console.error('Error deleting setting:', error);
    throw error;
  }
};

/**
 * Reset setting to default value
 * @param {string} key - Setting key
 * @returns {Promise<any>} Default value or null if no default exists
 */
export const resetSetting = async (key) => {
  try {
    if (!key || typeof key !== 'string') {
      throw new Error('Valid setting key is required');
    }

    const defaultSetting = DEFAULT_SETTINGS[key];
    
    if (!defaultSetting) {
      throw new Error(`No default value available for setting: ${key}`);
    }

    await setSetting(key, defaultSetting.defaultValue, defaultSetting.type, defaultSetting.description);
    return defaultSetting.defaultValue;
  } catch (error) {
    console.error('Error resetting setting:', error);
    throw error;
  }
};

/**
 * Reset all settings to default values
 * @returns {Promise<Object>} Object with all default settings
 */
export const resetAllSettings = async () => {
  try {
    // Delete all existing settings
    await db.settings.clear();

    // Set all default settings
    const defaultSettings = {};
    
    for (const [key, config] of Object.entries(DEFAULT_SETTINGS)) {
      await setSetting(key, config.defaultValue, config.type, config.description);
      defaultSettings[key] = config.defaultValue;
    }

    return defaultSettings;
  } catch (error) {
    console.error('Error resetting all settings:', error);
    throw error;
  }
};

/**
 * Get setting metadata (type, description, etc.)
 * @param {string} key - Setting key
 * @returns {Promise<Object|null>} Setting metadata or null if not found
 */
export const getSettingMetadata = async (key) => {
  try {
    if (!key || typeof key !== 'string') {
      throw new Error('Valid setting key is required');
    }

    const setting = await db.settings.where('key').equals(key).first();
    
    if (!setting) {
      const defaultSetting = DEFAULT_SETTINGS[key];
      return defaultSetting ? {
        key,
        type: defaultSetting.type,
        description: defaultSetting.description,
        isDefault: true,
        defaultValue: defaultSetting.defaultValue
      } : null;
    }

    return {
      key: setting.key,
      type: setting.type,
      description: setting.description,
      isDefault: false,
      createdAt: setting.createdAt,
      updatedAt: setting.updatedAt
    };
  } catch (error) {
    console.error('Error getting setting metadata:', error);
    throw error;
  }
};

/**
 * Get all settings with metadata
 * @returns {Promise<Array>} Array of setting objects with metadata
 */
export const getAllSettingsWithMetadata = async () => {
  try {
    const settingsRecords = await db.settings.toArray();
    const allSettings = [];

    // Add existing settings
    settingsRecords.forEach(setting => {
      allSettings.push({
        ...setting,
        value: parseSettingValue(setting.value, setting.type),
        isDefault: false
      });
    });

    // Add default settings that don't exist yet
    Object.keys(DEFAULT_SETTINGS).forEach(key => {
      const exists = settingsRecords.some(setting => setting.key === key);
      if (!exists) {
        const defaultSetting = DEFAULT_SETTINGS[key];
        allSettings.push({
          key,
          value: defaultSetting.defaultValue,
          type: defaultSetting.type,
          description: defaultSetting.description,
          isDefault: true
        });
      }
    });

    return allSettings.sort((a, b) => a.key.localeCompare(b.key));
  } catch (error) {
    console.error('Error getting all settings with metadata:', error);
    throw error;
  }
};

/**
 * Search settings by key or description
 * @param {string} searchTerm - Search term
 * @returns {Promise<Array>} Array of matching settings
 */
export const searchSettings = async (searchTerm) => {
  try {
    if (!searchTerm || typeof searchTerm !== 'string' || searchTerm.trim().length < 2) {
      throw new Error('Search term must be at least 2 characters long');
    }

    const term = searchTerm.toLowerCase().trim();
    const allSettings = await getAllSettingsWithMetadata();

    return allSettings.filter(setting =>
      setting.key.toLowerCase().includes(term) ||
      setting.description.toLowerCase().includes(term)
    );
  } catch (error) {
    console.error('Error searching settings:', error);
    throw error;
  }
};

/**
 * Export all settings
 * @returns {Promise<Object>} Settings export object
 */
export const exportSettings = async () => {
  try {
    const settings = await getAllSettings();
    
    return {
      exported_at: new Date().toISOString(),
      version: '1.0',
      settings
    };
  } catch (error) {
    console.error('Error exporting settings:', error);
    throw error;
  }
};

/**
 * Import settings from export object
 * @param {Object} exportData - Settings export object
 * @param {boolean} overwrite - Whether to overwrite existing settings
 * @returns {Promise<Object>} Import result summary
 */
export const importSettings = async (exportData, overwrite = false) => {
  try {
    if (!exportData || !exportData.settings) {
      throw new Error('Invalid export data');
    }

    const results = {
      imported: 0,
      skipped: 0,
      errors: 0,
      errorDetails: []
    };

    for (const [key, value] of Object.entries(exportData.settings)) {
      try {
        const existingSetting = await db.settings.where('key').equals(key).first();
        
        if (existingSetting && !overwrite) {
          results.skipped++;
          continue;
        }

        await setSetting(key, value);
        results.imported++;
      } catch (error) {
        results.errors++;
        results.errorDetails.push({
          key,
          error: error.message
        });
      }
    }

    return results;
  } catch (error) {
    console.error('Error importing settings:', error);
    throw error;
  }
};

const settingsService = {
  getSetting,
  setSetting,
  getSettings,
  getAllSettings,
  setSettings,
  deleteSetting,
  resetSetting,
  resetAllSettings,
  getSettingMetadata,
  getAllSettingsWithMetadata,
  searchSettings,
  exportSettings,
  importSettings
};

export default settingsService;
</file>

<file path="src/db/services/userService.js">
import { db } from '../database.js';

/**
 * User Service - Handles all user-related database operations
 */

// Validation helpers
const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePhone = (phone) => {
  if (!phone) return true; // Phone is optional
  const phoneRegex = /^[\d\-+()\\s]+$/;
  return phoneRegex.test(phone);
};

const validateUser = (userData) => {
  const errors = [];
  
  if (!userData.name || userData.name.trim().length < 2) {
    errors.push('Name must be at least 2 characters long');
  }
  
  if (!userData.email || !validateEmail(userData.email)) {
    errors.push('Valid email is required');
  }
  
  if (!userData.department || userData.department.trim().length < 2) {
    errors.push('Department is required');
  }
  
  if (!userData.role || userData.role.trim().length < 2) {
    errors.push('Role is required');
  }
  
  if (userData.phone && !validatePhone(userData.phone)) {
    errors.push('Invalid phone number format');
  }
  
  return errors;
};

/**
 * Create a new user
 * @param {Object} userData - User data object
 * @returns {Promise<Object>} Created user with ID
 */
export const createUser = async (userData) => {
  try {
    // Validate input
    const validationErrors = validateUser(userData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    // Check if email already exists
    const existingUser = await db.users.where('email').equals(userData.email).first();
    if (existingUser) {
      throw new Error('User with this email already exists');
    }

    const now = new Date().toISOString();
    const newUser = {
      ...userData,
      name: userData.name.trim(),
      email: userData.email.toLowerCase().trim(),
      department: userData.department.trim(),
      role: userData.role.trim(),
      phone: userData.phone?.trim() || null,
      avatar: userData.avatar || null,
      status: userData.status || 'active',
      createdAt: now,
      updatedAt: now
    };

    const id = await db.users.add(newUser);
    return { ...newUser, id };
  } catch (error) {
    console.error('Error creating user:', error);
    throw error;
  }
};

/**
 * Get user by ID
 * @param {number} id - User ID
 * @returns {Promise<Object|null>} User object or null if not found
 */
export const getUserById = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid user ID is required');
    }

    const user = await db.users.get(Number(id));
    return user || null;
  } catch (error) {
    console.error('Error getting user by ID:', error);
    throw error;
  }
};

/**
 * Get user by email
 * @param {string} email - User email
 * @returns {Promise<Object|null>} User object or null if not found
 */
export const getUserByEmail = async (email) => {
  try {
    if (!email || !validateEmail(email)) {
      throw new Error('Valid email is required');
    }

    const user = await db.users.where('email').equals(email.toLowerCase().trim()).first();
    return user || null;
  } catch (error) {
    console.error('Error getting user by email:', error);
    throw error;
  }
};

/**
 * Get all users with optional filtering
 * @param {Object} filters - Optional filters (status, department, role)
 * @returns {Promise<Array>} Array of users
 */
export const getAllUsers = async (filters = {}) => {
  try {
    let query = db.users.orderBy('name');

    if (filters.status) {
      query = query.filter(user => user.status === filters.status);
    }

    if (filters.department) {
      query = query.filter(user => user.department === filters.department);
    }

    if (filters.role) {
      query = query.filter(user => user.role === filters.role);
    }

    const users = await query.toArray();
    return users;
  } catch (error) {
    console.error('Error getting all users:', error);
    throw error;
  }
};

/**
 * Update user
 * @param {number} id - User ID
 * @param {Object} updateData - Data to update
 * @returns {Promise<Object>} Updated user object
 */
export const updateUser = async (id, updateData) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid user ID is required');
    }

    const existingUser = await getUserById(id);
    if (!existingUser) {
      throw new Error('User not found');
    }

    // If email is being updated, check for duplicates
    if (updateData.email && updateData.email !== existingUser.email) {
      const emailExists = await getUserByEmail(updateData.email);
      if (emailExists) {
        throw new Error('User with this email already exists');
      }
    }

    // Validate update data
    const mergedData = { ...existingUser, ...updateData };
    const validationErrors = validateUser(mergedData);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    const updatedFields = {
      ...updateData,
      updatedAt: new Date().toISOString()
    };

    // Clean up fields
    if (updatedFields.name) updatedFields.name = updatedFields.name.trim();
    if (updatedFields.email) updatedFields.email = updatedFields.email.toLowerCase().trim();
    if (updatedFields.department) updatedFields.department = updatedFields.department.trim();
    if (updatedFields.role) updatedFields.role = updatedFields.role.trim();
    if (updatedFields.phone) updatedFields.phone = updatedFields.phone.trim();

    await db.users.update(Number(id), updatedFields);
    
    const updatedUser = await getUserById(id);
    return updatedUser;
  } catch (error) {
    console.error('Error updating user:', error);
    throw error;
  }
};

/**
 * Soft delete user (set status to inactive)
 * @param {number} id - User ID
 * @returns {Promise<boolean>} Success status
 */
export const deactivateUser = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid user ID is required');
    }

    const user = await getUserById(id);
    if (!user) {
      throw new Error('User not found');
    }

    await db.users.update(Number(id), {
      status: 'inactive',
      updatedAt: new Date().toISOString()
    });

    return true;
  } catch (error) {
    console.error('Error deactivating user:', error);
    throw error;
  }
};

/**
 * Reactivate user
 * @param {number} id - User ID
 * @returns {Promise<boolean>} Success status
 */
export const reactivateUser = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid user ID is required');
    }

    const user = await getUserById(id);
    if (!user) {
      throw new Error('User not found');
    }

    await db.users.update(Number(id), {
      status: 'active',
      updatedAt: new Date().toISOString()
    });

    return true;
  } catch (error) {
    console.error('Error reactivating user:', error);
    throw error;
  }
};

/**
 * Permanently delete user (use with caution)
 * @param {number} id - User ID
 * @returns {Promise<boolean>} Success status
 */
export const deleteUser = async (id) => {
  try {
    if (!id || !Number.isInteger(Number(id))) {
      throw new Error('Valid user ID is required');
    }

    const user = await getUserById(id);
    if (!user) {
      throw new Error('User not found');
    }

    // Check if user has associated data
    const hasExpenses = await db.expenses.where('userId').equals(Number(id)).count();
    const hasIncome = await db.income.where('userId').equals(Number(id)).count();
    
    if (hasExpenses > 0 || hasIncome > 0) {
      throw new Error('Cannot delete user with associated expenses or income records. Deactivate instead.');
    }

    await db.users.delete(Number(id));
    return true;
  } catch (error) {
    console.error('Error deleting user:', error);
    throw error;
  }
};

/**
 * Search users by name or email
 * @param {string} searchTerm - Search term
 * @returns {Promise<Array>} Array of matching users
 */
export const searchUsers = async (searchTerm) => {
  try {
    if (!searchTerm || searchTerm.trim().length < 2) {
      throw new Error('Search term must be at least 2 characters long');
    }

    const term = searchTerm.toLowerCase().trim();
    
    const users = await db.users
      .filter(user => 
        user.name.toLowerCase().includes(term) ||
        user.email.toLowerCase().includes(term) ||
        user.department.toLowerCase().includes(term)
      )
      .toArray();

    return users;
  } catch (error) {
    console.error('Error searching users:', error);
    throw error;
  }
};

/**
 * Get user statistics
 * @returns {Promise<Object>} User statistics
 */
export const getUserStats = async () => {
  try {
    const totalUsers = await db.users.count();
    const activeUsers = await db.users.where('status').equals('active').count();
    const inactiveUsers = await db.users.where('status').equals('inactive').count();
    
    const departments = await db.users.orderBy('department').uniqueKeys();
    const roles = await db.users.orderBy('role').uniqueKeys();

    return {
      total: totalUsers,
      active: activeUsers,
      inactive: inactiveUsers,
      departments: departments.length,
      roles: roles.length,
      departmentList: departments,
      roleList: roles
    };
  } catch (error) {
    console.error('Error getting user stats:', error);
    throw error;
  }
};

/**
 * Get transaction summary for a specific user
 * @param {number} userId - User ID
 * @returns {Promise<Object>} User transaction summary
 */
export const getUserTransactionSummary = async (userId) => {
  try {
    if (!userId || !Number.isInteger(Number(userId))) {
      throw new Error('Valid user ID is required');
    }

    // Get all expenses for the user
    const expenses = await db.expenses.where('userId').equals(Number(userId)).toArray();
    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);

    // Get all income for the user
    const income = await db.income.where('userId').equals(Number(userId)).toArray();
    const totalIncome = income.reduce((sum, inc) => sum + inc.amount, 0);

    // Calculate transaction count
    const transactionCount = expenses.length + income.length;

    // Get last activity date
    const allTransactions = [...expenses, ...income];
    let lastActivity = null;
    if (allTransactions.length > 0) {
      const sortedTransactions = allTransactions.sort((a, b) => 
        new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt)
      );
      lastActivity = sortedTransactions[0].updatedAt || sortedTransactions[0].createdAt;
    }

    return {
      totalExpenses,
      totalIncome,
      transactionCount,
      lastActivity,
      netAmount: totalIncome - totalExpenses
    };
  } catch (error) {
    console.error('Error getting user transaction summary:', error);
    throw error;
  }
};

/**
 * Get all users with transaction summaries
 * @param {Object} filters - Optional filters (status, department, role)
 * @returns {Promise<Array>} Array of users with transaction data
 */
export const getAllUsersWithTransactionData = async (filters = {}) => {
  try {
    // Get all users
    const users = await getAllUsers(filters);

    // Get transaction summaries for all users
    const usersWithTransactionData = await Promise.all(
      users.map(async (user) => {
        const transactionSummary = await getUserTransactionSummary(user.id);
        return {
          ...user,
          ...transactionSummary,
          isActive: user.status === 'active'
        };
      })
    );

    return usersWithTransactionData;
  } catch (error) {
    console.error('Error getting users with transaction data:', error);
    throw error;
  }
};

const userService = {
  createUser,
  getUserById,
  getUserByEmail,
  getAllUsers,
  updateUser,
  deactivateUser,
  reactivateUser,
  deleteUser,
  searchUsers,
  getUserStats,
  getUserTransactionSummary,
  getAllUsersWithTransactionData
};

export default userService;
</file>

<file path="src/db/database.js">
import Dexie from 'dexie';

// Create database instance
const db = new Dexie('AttureExpenceDB');

// Define database schema
db.version(1).stores({
  users: '++id, name, department, role, email, phone, avatar, status, createdAt, updatedAt',
  expenses: '++id, date, categoryId, amount, description, userId, tags, receiptIds, status, approvedBy, approvedAt, rejectedReason, createdAt, updatedAt',
  income: '++id, date, categoryId, source, amount, description, userId, tags, fileIds, status, createdAt, updatedAt',
  categories: '++id, name, type, color, icon, parentId, isActive, createdAt, updatedAt',
  tags: '++id, name, color, description, isActive, createdAt, updatedAt',
  settings: '++id, key, value, type, description, createdAt, updatedAt',
  files: '++id, name, originalName, type, size, path, blob, entityType, entityId, userId, createdAt'
});

// Initialize default data after database is opened
const initializeDefaultData = async () => {
  try {
    // Initialize default categories
    const categoryCount = await db.categories.count();
    if (categoryCount === 0) {
      const now = new Date().toISOString();
      await db.categories.bulkAdd([
        // Expense categories
        { name: '交通費', type: 'expense', color: '#2196F3', icon: 'directions_car', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '宿泊費', type: 'expense', color: '#4CAF50', icon: 'hotel', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '会議費', type: 'expense', color: '#FF9800', icon: 'meeting_room', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '接待交際費', type: 'expense', color: '#9C27B0', icon: 'restaurant', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '消耗品費', type: 'expense', color: '#00BCD4', icon: 'shopping_cart', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '通信費', type: 'expense', color: '#795548', icon: 'phone', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '水道光熱費', type: 'expense', color: '#607D8B', icon: 'power', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '家賃', type: 'expense', color: '#F44336', icon: 'home', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: 'その他', type: 'expense', color: '#9E9E9E', icon: 'more_horiz', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        
        // Income categories
        { name: '売上', type: 'income', color: '#4CAF50', icon: 'attach_money', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: 'コンサルティング', type: 'income', color: '#2196F3', icon: 'business_center', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: '受託開発', type: 'income', color: '#FF9800', icon: 'code', parentId: null, isActive: true, createdAt: now, updatedAt: now },
        { name: 'その他収入', type: 'income', color: '#9C27B0', icon: 'account_balance_wallet', parentId: null, isActive: true, createdAt: now, updatedAt: now }
      ]);
    }

    // Initialize default settings
    const settingsCount = await db.settings.count();
    if (settingsCount === 0) {
      const now = new Date().toISOString();
      await db.settings.bulkAdd([
        { key: 'currency', value: 'JPY', type: 'string', description: 'Default currency', createdAt: now, updatedAt: now },
        { key: 'dateFormat', value: 'YYYY-MM-DD', type: 'string', description: 'Date format preference', createdAt: now, updatedAt: now },
        { key: 'theme', value: 'light', type: 'string', description: 'UI theme preference', createdAt: now, updatedAt: now },
        { key: 'language', value: 'ja', type: 'string', description: 'Language preference', createdAt: now, updatedAt: now },
        { key: 'autoBackup', value: 'true', type: 'boolean', description: 'Enable automatic backup', createdAt: now, updatedAt: now },
        { key: 'maxFileSize', value: '10485760', type: 'number', description: 'Maximum file size in bytes (10MB)', createdAt: now, updatedAt: now }
      ]);
    }
  } catch (error) {
    console.error('Error initializing default data:', error);
  }
};

// Open database and initialize
const openDatabase = async () => {
  try {
    await db.open();
    console.log('Database opened successfully');
    await initializeDefaultData();
    return db;
  } catch (error) {
    console.error('Failed to open database:', error);
    throw error;
  }
};

// Export the database instance and helper function
export { db, openDatabase };
export default db;
</file>

<file path="src/hooks/useAnalytics.js">
import { useState, useEffect, useMemo } from 'react';
import expenseService from '../services/expenseService';
import incomeService from '../services/incomeService';
import userService from '../db/services/userService';

const useAnalytics = (filters = {}) => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [rawData, setRawData] = useState({
    transactions: [],
    users: []
  });

  // Load data from database
  const loadData = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // Load expenses and income from database
      const [expenseResult, incomeResult, usersResult] = await Promise.all([
        expenseService.getAllExpenses(),
        incomeService.getAllIncome(),
        userService.getAllUsers()
      ]);

      // Transform data to unified format
      const expenseTransactions = (expenseResult.success ? expenseResult.data : []).map(expense => ({
        id: expense.id,
        type: 'expense',
        amount: expense.amount,
        category: expense.category?.name || 'Unknown',
        user: expense.user?.name || 'Unknown',
        department: expense.user?.department || 'Unknown',
        date: expense.date,
        categoryId: expense.categoryId,
        userId: expense.userId,
        description: expense.description,
        status: expense.status
      }));

      const incomeTransactions = (incomeResult.success ? incomeResult.data : []).map(income => ({
        id: income.id,
        type: 'income',
        amount: income.amount,
        category: income.category?.name || 'Unknown',
        user: income.user?.name || 'Unknown',
        department: income.user?.department || 'Unknown',
        date: income.date,
        categoryId: income.categoryId,
        userId: income.userId,
        description: income.description,
        source: income.source,
        status: income.status
      }));

      const allTransactions = [...expenseTransactions, ...incomeTransactions];

      setRawData({
        transactions: allTransactions,
        users: usersResult.success ? usersResult.data : []
      });
    } catch (err) {
      console.error('Error loading analytics data:', err);
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Load data on mount and when filters change significantly
  useEffect(() => {
    loadData();
  }, []);

  // Filter data based on current filters
  const filteredData = useMemo(() => {
    if (!rawData.transactions.length) {
      return [];
    }

    try {
      let filtered = [...rawData.transactions];

      // Apply date range filter
      if (filters.dateRange) {
        const { startDate, endDate } = filters.dateRange;
        filtered = filtered.filter(transaction => {
          const transactionDate = new Date(transaction.date);
          return transactionDate >= startDate && transactionDate <= endDate;
        });
      }

      // Apply transaction type filter
      if (filters.transactionType && filters.transactionType !== 'all') {
        filtered = filtered.filter(transaction => transaction.type === filters.transactionType);
      }

      // Apply category filter
      if (filters.categories && filters.categories.length > 0) {
        filtered = filtered.filter(transaction => filters.categories.includes(transaction.category));
      }

      // Apply user filter
      if (filters.users && filters.users.length > 0) {
        filtered = filtered.filter(transaction => filters.users.includes(transaction.user));
      }

      // Apply department filter
      if (filters.departments && filters.departments.length > 0) {
        filtered = filtered.filter(transaction => filters.departments.includes(transaction.department));
      }

      // Apply amount range filter
      if (filters.amountRange) {
        const { min, max } = filters.amountRange;
        if (min) {
          filtered = filtered.filter(transaction => transaction.amount >= parseInt(min));
        }
        if (max) {
          filtered = filtered.filter(transaction => transaction.amount <= parseInt(max));
        }
      }

      return filtered;
    } catch (err) {
      setError(err.message);
      return [];
    }
  }, [rawData, filters]);

  // Calculate financial summary
  const financialSummary = useMemo(() => {
    const incomeTransactions = filteredData.filter(t => t.type === 'income');
    const expenseTransactions = filteredData.filter(t => t.type === 'expense');

    const totalIncome = incomeTransactions.reduce((sum, t) => sum + t.amount, 0);
    const totalExpense = expenseTransactions.reduce((sum, t) => sum + t.amount, 0);

    // Calculate monthly averages based on actual data range
    const dates = filteredData.map(t => new Date(t.date));
    const minDate = dates.length ? new Date(Math.min(...dates)) : new Date();
    const maxDate = dates.length ? new Date(Math.max(...dates)) : new Date();
    const monthsDiff = Math.max(1, Math.round((maxDate - minDate) / (1000 * 60 * 60 * 24 * 30)));
    
    const monthlyIncome = totalIncome / monthsDiff;
    const monthlyExpense = totalExpense / monthsDiff;
    const quarterlyIncome = monthlyIncome * 3;
    const quarterlyExpense = monthlyExpense * 3;

    // Calculate growth rates based on data trends (compare last period vs previous)
    const now = new Date();
    const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
    const previousMonthStart = new Date(now.getFullYear(), now.getMonth() - 2, 1);
    const previousMonthEnd = new Date(now.getFullYear(), now.getMonth() - 1, 0);

    const lastMonthIncome = incomeTransactions
      .filter(t => {
        const date = new Date(t.date);
        return date >= lastMonthStart && date <= lastMonthEnd;
      })
      .reduce((sum, t) => sum + t.amount, 0);

    const previousMonthIncome = incomeTransactions
      .filter(t => {
        const date = new Date(t.date);
        return date >= previousMonthStart && date <= previousMonthEnd;
      })
      .reduce((sum, t) => sum + t.amount, 0);

    const lastMonthExpense = expenseTransactions
      .filter(t => {
        const date = new Date(t.date);
        return date >= lastMonthStart && date <= lastMonthEnd;
      })
      .reduce((sum, t) => sum + t.amount, 0);

    const previousMonthExpense = expenseTransactions
      .filter(t => {
        const date = new Date(t.date);
        return date >= previousMonthStart && date <= previousMonthEnd;
      })
      .reduce((sum, t) => sum + t.amount, 0);

    const incomeGrowth = previousMonthIncome > 0 
      ? ((lastMonthIncome - previousMonthIncome) / previousMonthIncome) * 100 
      : 0;

    const expenseGrowth = previousMonthExpense > 0 
      ? ((lastMonthExpense - previousMonthExpense) / previousMonthExpense) * 100 
      : 0;

    return {
      totalIncome,
      totalExpense,
      monthlyIncome,
      monthlyExpense,
      quarterlyIncome,
      quarterlyExpense,
      incomeGrowth,
      expenseGrowth,
      profitMargin: totalIncome > 0 ? ((totalIncome - totalExpense) / totalIncome) * 100 : 0,
      averageTransaction: filteredData.length > 0 ? filteredData.reduce((sum, t) => sum + t.amount, 0) / filteredData.length : 0,
    };
  }, [filteredData]);

  // Calculate expense chart data
  const expenseChartData = useMemo(() => {
    const expenseTransactions = filteredData.filter(t => t.type === 'expense');
    
    // Group by category
    const categoryTotals = expenseTransactions.reduce((acc, transaction) => {
      acc[transaction.category] = (acc[transaction.category] || 0) + transaction.amount;
      return acc;
    }, {});

    // Group by month for trends
    const monthlyTotals = expenseTransactions.reduce((acc, transaction) => {
      const month = new Date(transaction.date).toLocaleDateString('ja-JP', { month: 'short' });
      acc[month] = (acc[month] || 0) + transaction.amount;
      return acc;
    }, {});

    // Calculate category trends based on actual data (last 2 months comparison)
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    const categoryTrends = Object.keys(categoryTotals).map(categoryName => {
      const currentMonthExpenses = expenseTransactions
        .filter(t => {
          const date = new Date(t.date);
          return t.category === categoryName && 
                 date.getMonth() === currentMonth && 
                 date.getFullYear() === currentYear;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      const lastMonthExpenses = expenseTransactions
        .filter(t => {
          const date = new Date(t.date);
          return t.category === categoryName && 
                 date.getMonth() === (currentMonth - 1 + 12) % 12 && 
                 date.getFullYear() === (currentMonth === 0 ? currentYear - 1 : currentYear);
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      return lastMonthExpenses > 0 
        ? ((currentMonthExpenses - lastMonthExpenses) / lastMonthExpenses) * 100 
        : 0;
    });

    // Calculate previous year data for comparison
    const previousYearData = Object.keys(monthlyTotals).map(month => {
      const monthIndex = new Date(`${month} 1, 2024`).getMonth();
      const previousYearAmount = expenseTransactions
        .filter(t => {
          const date = new Date(t.date);
          return date.getMonth() === monthIndex && date.getFullYear() === currentYear - 1;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      return previousYearAmount;
    });

    return {
      categoryData: {
        labels: Object.keys(categoryTotals),
        amounts: Object.values(categoryTotals),
        trends: categoryTrends
      },
      monthlyTrends: {
        labels: Object.keys(monthlyTotals),
        data: Object.values(monthlyTotals)
      },
      comparisonData: {
        labels: Object.keys(monthlyTotals),
        currentYear: Object.values(monthlyTotals),
        previousYear: previousYearData
      }
    };
  }, [filteredData]);

  // Calculate income chart data
  const incomeChartData = useMemo(() => {
    const incomeTransactions = filteredData.filter(t => t.type === 'income');
    
    // Group by category (income source)
    const sourceTotals = incomeTransactions.reduce((acc, transaction) => {
      acc[transaction.category] = (acc[transaction.category] || 0) + transaction.amount;
      return acc;
    }, {});

    // Group by month for trends
    const monthlyTotals = incomeTransactions.reduce((acc, transaction) => {
      const month = new Date(transaction.date).toLocaleDateString('ja-JP', { month: 'short' });
      acc[month] = (acc[month] || 0) + transaction.amount;
      return acc;
    }, {});

    // Calculate source trends based on actual data (last 2 months comparison)
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    const sourceTrends = Object.keys(sourceTotals).map(sourceName => {
      const currentMonthIncome = incomeTransactions
        .filter(t => {
          const date = new Date(t.date);
          return t.category === sourceName && 
                 date.getMonth() === currentMonth && 
                 date.getFullYear() === currentYear;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      const lastMonthIncome = incomeTransactions
        .filter(t => {
          const date = new Date(t.date);
          return t.category === sourceName && 
                 date.getMonth() === (currentMonth - 1 + 12) % 12 && 
                 date.getFullYear() === (currentMonth === 0 ? currentYear - 1 : currentYear);
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      return lastMonthIncome > 0 
        ? ((currentMonthIncome - lastMonthIncome) / lastMonthIncome) * 100 
        : 0;
    });

    // Calculate previous year data for comparison
    const previousYearData = Object.keys(monthlyTotals).map(month => {
      const monthIndex = new Date(`${month} 1, 2024`).getMonth();
      const previousYearAmount = incomeTransactions
        .filter(t => {
          const date = new Date(t.date);
          return date.getMonth() === monthIndex && date.getFullYear() === currentYear - 1;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      return previousYearAmount;
    });

    // Calculate growth metrics based on actual data
    const totalCurrentYear = incomeTransactions
      .filter(t => new Date(t.date).getFullYear() === currentYear)
      .reduce((sum, t) => sum + t.amount, 0);
    
    const totalPreviousYear = incomeTransactions
      .filter(t => new Date(t.date).getFullYear() === currentYear - 1)
      .reduce((sum, t) => sum + t.amount, 0);

    const yearOverYear = totalPreviousYear > 0 
      ? ((totalCurrentYear - totalPreviousYear) / totalPreviousYear) * 100 
      : 0;

    const monthlyValues = Object.values(monthlyTotals);
    const monthlyGrowth = monthlyValues.length > 1 
      ? ((monthlyValues[monthlyValues.length - 1] - monthlyValues[monthlyValues.length - 2]) / monthlyValues[monthlyValues.length - 2]) * 100 
      : 0;

    return {
      sourceData: {
        labels: Object.keys(sourceTotals),
        amounts: Object.values(sourceTotals),
        trends: sourceTrends
      },
      monthlyTrends: {
        labels: Object.keys(monthlyTotals),
        data: Object.values(monthlyTotals)
      },
      comparisonData: {
        labels: Object.keys(monthlyTotals),
        currentYear: Object.values(monthlyTotals),
        previousYear: previousYearData
      },
      growthMetrics: {
        monthlyGrowth,
        yearOverYear,
        quarterlyGrowth: monthlyGrowth * 3 // Approximate quarterly growth
      }
    };
  }, [filteredData]);

  // Calculate user ranking data
  const userRankingData = useMemo(() => {
    const userExpenses = {};
    const userTransactionCounts = {};
    
    filteredData.filter(t => t.type === 'expense').forEach(transaction => {
      userExpenses[transaction.user] = (userExpenses[transaction.user] || 0) + transaction.amount;
      userTransactionCounts[transaction.user] = (userTransactionCounts[transaction.user] || 0) + 1;
    });

    // Calculate user trends based on actual data (current vs previous month)
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    const lastMonth = (currentMonth - 1 + 12) % 12;
    const lastMonthYear = currentMonth === 0 ? currentYear - 1 : currentYear;

    const calculateUserTrend = (userName) => {
      const currentMonthExpenses = filteredData
        .filter(t => {
          const date = new Date(t.date);
          return t.type === 'expense' && 
                 t.user === userName && 
                 date.getMonth() === currentMonth && 
                 date.getFullYear() === currentYear;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      const lastMonthExpenses = filteredData
        .filter(t => {
          const date = new Date(t.date);
          return t.type === 'expense' && 
                 t.user === userName && 
                 date.getMonth() === lastMonth && 
                 date.getFullYear() === lastMonthYear;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      return lastMonthExpenses > 0 
        ? ((currentMonthExpenses - lastMonthExpenses) / lastMonthExpenses) * 100 
        : 0;
    };

    // Create user rankings
    const userRankings = Object.entries(userExpenses)
      .map(([userName, amount], index) => {
        const user = rawData.users.find(u => u.name === userName);
        const totalTransactions = userTransactionCounts[userName] || 0;
        const averageTransaction = totalTransactions > 0 ? amount / totalTransactions : 0;
        const trend = calculateUserTrend(userName);
        
        // Calculate efficiency based on expense/transaction ratio (lower is better)
        const efficiency = totalTransactions > 0 ? Math.max(0, 100 - (averageTransaction / 10000)) : 50;
        
        return {
          id: user?.id || index + 1,
          name: userName,
          department: user?.department || '不明',
          amount,
          transactions: totalTransactions,
          trend,
          efficiency: Math.min(100, Math.max(0, efficiency)),
          rank: index + 1,
          badge: null // Will be set after sorting
        };
      })
      .sort((a, b) => b.amount - a.amount)
      .map((user, index) => ({ 
        ...user, 
        rank: index + 1,
        badge: index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : null
      }));

    // Calculate department data
    const departmentExpenses = {};
    const departmentUserCounts = {};
    
    filteredData.filter(t => t.type === 'expense').forEach(transaction => {
      departmentExpenses[transaction.department] = (departmentExpenses[transaction.department] || 0) + transaction.amount;
    });

    rawData.users.forEach(user => {
      departmentUserCounts[user.department] = (departmentUserCounts[user.department] || 0) + 1;
    });

    const departmentData = Object.entries(departmentExpenses).map(([deptName, totalAmount]) => {
      const userCount = departmentUserCounts[deptName] || 1;
      const avgAmount = totalAmount / userCount;
      
      // Calculate department trend
      const currentMonthDeptExpenses = filteredData
        .filter(t => {
          const date = new Date(t.date);
          return t.type === 'expense' && 
                 t.department === deptName && 
                 date.getMonth() === currentMonth && 
                 date.getFullYear() === currentYear;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      const lastMonthDeptExpenses = filteredData
        .filter(t => {
          const date = new Date(t.date);
          return t.type === 'expense' && 
                 t.department === deptName && 
                 date.getMonth() === lastMonth && 
                 date.getFullYear() === lastMonthYear;
        })
        .reduce((sum, t) => sum + t.amount, 0);
      
      const trend = lastMonthDeptExpenses > 0 
        ? ((currentMonthDeptExpenses - lastMonthDeptExpenses) / lastMonthDeptExpenses) * 100 
        : 0;
      
      // Calculate efficiency based on expenses per user (lower is better)
      const efficiency = Math.max(0, 100 - (avgAmount / 50000));
      
      return {
        name: deptName,
        totalAmount,
        userCount,
        avgAmount,
        trend,
        efficiency: Math.min(100, Math.max(0, efficiency))
      };
    });

    return {
      userRankings,
      departmentData
    };
  }, [filteredData, rawData.users]);

  // Calculate statistics
  const statistics = useMemo(() => {
    const totalTransactions = filteredData.length;
    const incomeTransactions = filteredData.filter(t => t.type === 'income').length;
    const expenseTransactions = filteredData.filter(t => t.type === 'expense').length;
    
    const uniqueUsers = new Set(filteredData.map(t => t.user)).size;
    const uniqueCategories = new Set(filteredData.map(t => t.category)).size;
    const uniqueDepartments = new Set(filteredData.map(t => t.department)).size;

    const averageTransactionAmount = filteredData.length > 0 
      ? filteredData.reduce((sum, t) => sum + t.amount, 0) / filteredData.length 
      : 0;

    // Calculate data quality metrics based on actual data
    const transactionsWithDescriptions = filteredData.filter(t => t.description && t.description.trim()).length;
    const transactionsWithCategories = filteredData.filter(t => t.category && t.category !== 'Unknown').length;
    const transactionsWithUsers = filteredData.filter(t => t.user && t.user !== 'Unknown').length;
    
    const completeness = totalTransactions > 0 
      ? Math.round((transactionsWithDescriptions / totalTransactions) * 100) 
      : 100;
    
    const accuracy = totalTransactions > 0 
      ? Math.round((transactionsWithCategories / totalTransactions) * 100) 
      : 100;
    
    const consistency = totalTransactions > 0 
      ? Math.round((transactionsWithUsers / totalTransactions) * 100) 
      : 100;

    return {
      totalTransactions,
      incomeTransactions,
      expenseTransactions,
      uniqueUsers,
      uniqueCategories,
      uniqueDepartments,
      averageTransactionAmount,
      dataQuality: {
        completeness,
        accuracy,
        consistency
      }
    };
  }, [filteredData]);

  // Export functionality
  const exportData = (format = 'json') => {
    const exportObj = {
      filters,
      financialSummary,
      expenseChartData,
      incomeChartData,
      userRankingData,
      statistics,
      exportDate: new Date().toISOString(),
      totalRecords: filteredData.length
    };

    switch (format) {
      case 'json':
        return JSON.stringify(exportObj, null, 2);
      case 'csv':
        // Simple CSV export of transactions
        const headers = ['Date', 'Type', 'Amount', 'Category', 'User', 'Department'];
        const csvContent = [
          headers.join(','),
          ...filteredData.map(t => 
            [t.date, t.type, t.amount, t.category, t.user, t.department].join(',')
          )
        ].join('\n');
        return csvContent;
      default:
        return exportObj;
    }
  };

  // Reset function
  const resetFilters = () => {
    setError(null);
  };

  useEffect(() => {
    resetFilters();
  }, [filters]);

  return {
    // Data
    financialSummary,
    expenseChartData,
    incomeChartData,
    userRankingData,
    statistics,
    filteredData,
    
    // State
    isLoading,
    error,
    
    // Functions
    exportData,
    resetFilters,
    
    // Metadata
    totalRecords: filteredData.length,
    appliedFilters: filters
  };
};

export default useAnalytics;
</file>

<file path="src/hooks/usePageTransition.js">
import { useState, useEffect } from 'react';
import { useLocation } from 'react-router-dom';

/**
 * Custom hook for managing page transitions and animations
 * Provides smooth transitions between different pages/routes
 */
export const usePageTransition = (duration = 300) => {
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [transitionStage, setTransitionStage] = useState('idle'); // 'idle', 'exiting', 'entering'
  const location = useLocation();

  useEffect(() => {
    // Start transition when location changes
    setIsTransitioning(true);
    setTransitionStage('exiting');

    // After exit animation, switch to entering
    const exitTimer = setTimeout(() => {
      setTransitionStage('entering');
    }, duration / 2);

    // Complete transition
    const enterTimer = setTimeout(() => {
      setIsTransitioning(false);
      setTransitionStage('idle');
    }, duration);

    return () => {
      clearTimeout(exitTimer);
      clearTimeout(enterTimer);
    };
  }, [location.pathname, duration]);

  // Common transition variants for framer-motion
  const pageVariants = {
    initial: {
      opacity: 0,
      y: 20,
      scale: 0.98,
    },
    in: {
      opacity: 1,
      y: 0,
      scale: 1,
    },
    out: {
      opacity: 0,
      y: -20,
      scale: 1.02,
    },
  };

  const pageTransition = {
    type: 'tween',
    ease: 'anticipate',
    duration: duration / 1000,
  };

  // Slide transition variants
  const slideVariants = {
    initial: (direction = 1) => ({
      x: direction > 0 ? 300 : -300,
      opacity: 0,
    }),
    in: {
      x: 0,
      opacity: 1,
    },
    out: (direction = 1) => ({
      x: direction > 0 ? -300 : 300,
      opacity: 0,
    }),
  };

  // Fade transition variants
  const fadeVariants = {
    initial: {
      opacity: 0,
    },
    in: {
      opacity: 1,
    },
    out: {
      opacity: 0,
    },
  };

  // Scale transition variants
  const scaleVariants = {
    initial: {
      opacity: 0,
      scale: 0.8,
    },
    in: {
      opacity: 1,
      scale: 1,
    },
    out: {
      opacity: 0,
      scale: 1.1,
    },
  };

  // Rotation transition variants
  const rotateVariants = {
    initial: {
      opacity: 0,
      rotate: -10,
      scale: 0.8,
    },
    in: {
      opacity: 1,
      rotate: 0,
      scale: 1,
    },
    out: {
      opacity: 0,
      rotate: 10,
      scale: 0.8,
    },
  };

  // Container variants for staggered animations
  const containerVariants = {
    hidden: {
      opacity: 0,
    },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
        delayChildren: 0.1,
      },
    },
    exit: {
      opacity: 0,
      transition: {
        staggerChildren: 0.05,
        staggerDirection: -1,
      },
    },
  };

  // Item variants for staggered animations
  const itemVariants = {
    hidden: {
      opacity: 0,
      y: 20,
    },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
    exit: {
      opacity: 0,
      y: -20,
      transition: {
        duration: 0.3,
      },
    },
  };

  // Helper function to get transition direction based on route
  const getTransitionDirection = (fromPath, toPath) => {
    const routes = ['/', '/registration', '/users', '/analytics', '/settings'];
    const fromIndex = routes.indexOf(fromPath);
    const toIndex = routes.indexOf(toPath);
    
    if (fromIndex === -1 || toIndex === -1) return 1;
    return fromIndex < toIndex ? 1 : -1;
  };

  // Custom transition based on route type
  const getRouteTransition = (routePath) => {
    const routeTransitions = {
      '/': 'fade', // Dashboard - simple fade
      '/registration': 'slide', // Registration - slide in
      '/users': 'scale', // Users - scale effect
      '/analytics': 'rotate', // Analytics - rotate effect
      '/settings': 'slide', // Settings - slide effect
    };

    return routeTransitions[routePath] || 'fade';
  };

  return {
    isTransitioning,
    transitionStage,
    pageVariants,
    pageTransition,
    slideVariants,
    fadeVariants,
    scaleVariants,
    rotateVariants,
    containerVariants,
    itemVariants,
    getTransitionDirection,
    getRouteTransition,
  };
};

/**
 * Hook for managing loading states during transitions
 */
export const useTransitionLoader = (delay = 200) => {
  const [isLoading, setIsLoading] = useState(false);
  const location = useLocation();

  useEffect(() => {
    setIsLoading(true);
    
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, delay);

    return () => clearTimeout(timer);
  }, [location.pathname, delay]);

  return isLoading;
};

/**
 * Hook for managing breadcrumb navigation during transitions
 */
export const useBreadcrumbTransition = () => {
  const location = useLocation();
  
  const getBreadcrumbs = (pathname) => {
    const breadcrumbMap = {
      '/': [{ label: 'ダッシュボード', path: '/' }],
      '/registration': [
        { label: 'ダッシュボード', path: '/' },
        { label: '収支登録', path: '/registration' },
      ],
      '/users': [
        { label: 'ダッシュボード', path: '/' },
        { label: 'ユーザー管理', path: '/users' },
      ],
      '/analytics': [
        { label: 'ダッシュボード', path: '/' },
        { label: '分析・レポート', path: '/analytics' },
      ],
      '/settings': [
        { label: 'ダッシュボード', path: '/' },
        { label: '設定', path: '/settings' },
      ],
    };

    return breadcrumbMap[pathname] || [{ label: 'ダッシュボード', path: '/' }];
  };

  return {
    breadcrumbs: getBreadcrumbs(location.pathname),
    currentPath: location.pathname,
  };
};

export default usePageTransition;
</file>

<file path="src/hooks/useSettings.js">
import { useState, useEffect, useCallback } from 'react';
import settingsService from '../services/settingsService';
import aiService from '../services/aiService';

/**
 * Custom hook for managing application settings
 * Provides validation, persistence, and error handling
 */
export const useSettings = () => {
  const [settings, setSettingsState] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [hasChanges, setHasChanges] = useState(false);
  const [pendingChanges, setPendingChanges] = useState({});

  // Default settings configuration with validation
  const defaultSettings = {
    // Theme settings
    theme: 'light',
    colorScheme: 'default',
    fontSize: 14,
    glassIntensity: 0.25,
    customColors: {
      primary: '#6366f1',
      secondary: '#ec4899',
      success: '#10b981',
      warning: '#f59e0b',
      error: '#ef4444'
    },
    
    // General settings
    dateFormat: 'YYYY-MM-DD',
    
    // Notifications
    notifications: true,
    emailNotifications: true,
    pushNotifications: false,
    soundEnabled: true,
    notificationVolume: 50,
    
    // Data management
    dataRetentionDays: 365,
    autoSave: true,
    autoSaveInterval: 30, // seconds
    
    // AI settings
    openaiApiKey: '',
    apiEndpoint: 'https://api.openai.com/v1/chat/completions',
    aiSuggestions: true,
    maxRetries: 3,
    requestTimeout: 30000,
    
    // Security
    sessionTimeout: 60, // minutes
    lockOnInactivity: false,
    requirePasswordConfirmation: false,
    encryptExports: false,
    
    // UI preferences
    compactMode: false,
    showAnimations: true,
    showTutorials: true,
    defaultView: 'dashboard',
    itemsPerPage: 25
  };

  // Validation rules for settings
  const validationRules = {
    theme: (value) => ['light', 'dark', 'auto'].includes(value),
    colorScheme: (value) => ['default', 'blue', 'purple', 'green', 'custom'].includes(value),
    fontSize: (value) => value >= 10 && value <= 24,
    glassIntensity: (value) => value >= 0 && value <= 1,
    dateFormat: (value) => ['YYYY-MM-DD', 'MM/DD/YYYY', 'DD/MM/YYYY', 'YYYY年MM月DD日', 'MM月DD日, YYYY年'].includes(value),
    notificationVolume: (value) => value >= 0 && value <= 100,
    dataRetentionDays: (value) => value >= 30 && value <= 2555, // 30 days to 7 years
    autoSaveInterval: (value) => value >= 10 && value <= 300, // 10 seconds to 5 minutes
    sessionTimeout: (value) => value >= 5 && value <= 480, // 5 minutes to 8 hours
    maxRetries: (value) => value >= 1 && value <= 10,
    requestTimeout: (value) => value >= 5000 && value <= 120000, // 5 seconds to 2 minutes
    itemsPerPage: (value) => [10, 25, 50, 100].includes(value),
    openaiApiKey: (value) => !value || value.startsWith('sk-'),
    apiEndpoint: (value) => {
      try {
        new URL(value);
        return true;
      } catch {
        return false;
      }
    }
  };

  // Load settings from database
  const loadSettings = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await settingsService.getAllSettings();
      const loadedSettings = result.success ? result.data : {};
      const mergedSettings = { ...defaultSettings, ...loadedSettings };
      
      setSettingsState(mergedSettings);
      setPendingChanges({});
      setHasChanges(false);
    } catch (err) {
      console.error('Failed to load settings:', err);
      setError('設定の読み込みに失敗しました');
      setSettingsState(defaultSettings);
    } finally {
      setLoading(false);
    }
  }, []);

  // Validate a single setting value
  const validateSetting = useCallback((key, value) => {
    const rule = validationRules[key];
    if (!rule) return { isValid: true };
    
    try {
      const isValid = rule(value);
      return {
        isValid,
        error: isValid ? null : `Invalid value for ${key}`
      };
    } catch (err) {
      return {
        isValid: false,
        error: `Validation error for ${key}: ${err.message}`
      };
    }
  }, []);

  // Update a single setting (in memory only until saved)
  const updateSetting = useCallback((key, value) => {
    const validation = validateSetting(key, value);
    
    if (!validation.isValid) {
      throw new Error(validation.error);
    }

    setPendingChanges(prev => ({
      ...prev,
      [key]: value
    }));
    
    setSettingsState(prev => ({
      ...prev,
      [key]: value
    }));
    
    setHasChanges(true);

    // Update AI service settings if they changed
    if (key === 'openaiApiKey' || key === 'apiEndpoint') {
      aiService.updateSettings(
        key === 'openaiApiKey' ? value : settings.openaiApiKey,
        key === 'apiEndpoint' ? value : settings.apiEndpoint
      );
    }
  }, [validateSetting, settings]);

  // Update multiple settings
  const updateSettings = useCallback((settingsUpdate) => {
    const errors = [];
    const validUpdates = {};

    // Validate all updates first
    Object.entries(settingsUpdate).forEach(([key, value]) => {
      const validation = validateSetting(key, value);
      if (validation.isValid) {
        validUpdates[key] = value;
      } else {
        errors.push({ key, error: validation.error });
      }
    });

    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.map(e => e.error).join(', ')}`);
    }

    setPendingChanges(prev => ({
      ...prev,
      ...validUpdates
    }));
    
    setSettingsState(prev => ({
      ...prev,
      ...validUpdates
    }));
    
    setHasChanges(true);

    // Update AI service settings if they changed
    if (validUpdates.openaiApiKey || validUpdates.apiEndpoint) {
      aiService.updateSettings(
        validUpdates.openaiApiKey || settings.openaiApiKey,
        validUpdates.apiEndpoint || settings.apiEndpoint
      );
    }
  }, [validateSetting, settings]);

  // Save pending changes to database
  const saveSettings = useCallback(async () => {
    if (!hasChanges || Object.keys(pendingChanges).length === 0) {
      return { success: true, message: '保存する変更がありません' };
    }

    try {
      setLoading(true);
      setError(null);

      await settingsService.updateSettings(pendingChanges);
      
      setPendingChanges({});
      setHasChanges(false);
      
      return { success: true, message: '設定を保存しました' };
    } catch (err) {
      console.error('Failed to save settings:', err);
      setError('設定の保存に失敗しました');
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [hasChanges, pendingChanges]);

  // Discard pending changes
  const discardChanges = useCallback(() => {
    // Revert to saved settings
    Object.keys(pendingChanges).forEach(key => {
      setSettingsState(prev => ({
        ...prev,
        [key]: settings[key] || defaultSettings[key]
      }));
    });
    
    setPendingChanges({});
    setHasChanges(false);
  }, [pendingChanges, settings]);

  // Reset a single setting to default
  const resetSettingToDefault = useCallback(async (key) => {
    try {
      const defaultValue = defaultSettings[key];
      if (defaultValue === undefined) {
        throw new Error(`No default value for setting: ${key}`);
      }

      await settingsService.updateSetting(key, defaultValue);
      await loadSettings(); // Reload all settings
      
      return { success: true, message: '設定をリセットしました' };
    } catch (err) {
      console.error('Failed to reset setting:', err);
      setError('設定のリセットに失敗しました');
      return { success: false, error: err.message };
    }
  }, [loadSettings]);

  // Reset all settings to defaults
  const resetAllSettingsToDefaults = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      await settingsService.resetSettings();
      await loadSettings(); // Reload all settings
      
      return { success: true, message: 'すべての設定をリセットしました' };
    } catch (err) {
      console.error('Failed to reset all settings:', err);
      setError('設定のリセットに失敗しました');
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [loadSettings]);

  // Export settings
  const exportSettingsData = useCallback(async () => {
    try {
      const result = await settingsService.exportSettings();
      return result;
    } catch (err) {
      console.error('Failed to export settings:', err);
      return { success: false, error: err.message };
    }
  }, []);

  // Import settings
  const importSettingsData = useCallback(async (data, overwrite = false) => {
    try {
      setLoading(true);
      setError(null);

      const result = await settingsService.importSettings(data);
      if (result.success) {
        await loadSettings(); // Reload settings after import
      }
      return result;
    } catch (err) {
      console.error('Failed to import settings:', err);
      setError('設定のインポートに失敗しました');
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [loadSettings]);

  // Test API connection
  const testApiConnection = useCallback(async () => {
    return await aiService.testConnection();
  }, []);

  // Get setting value with fallback to default
  const getSetting = useCallback((key) => {
    return settings[key] !== undefined ? settings[key] : defaultSettings[key];
  }, [settings]);

  // Check if setting has been modified
  const isModified = useCallback((key) => {
    return key in pendingChanges;
  }, [pendingChanges]);

  // Initialize settings on mount
  useEffect(() => {
    loadSettings();
  }, [loadSettings]);

  // Update AI service when settings change
  useEffect(() => {
    if (settings.openaiApiKey || settings.apiEndpoint) {
      aiService.updateSettings(settings.openaiApiKey, settings.apiEndpoint);
    }
  }, [settings.openaiApiKey, settings.apiEndpoint]);

  return {
    // State
    settings,
    loading,
    error,
    hasChanges,
    pendingChanges,
    
    // Settings management
    getSetting,
    updateSetting,
    updateSettings,
    saveSettings,
    discardChanges,
    loadSettings,
    
    // Reset functionality
    resetSettingToDefault,
    resetAllSettingsToDefaults,
    
    // Import/Export
    exportSettingsData,
    importSettingsData,
    
    // Utilities
    validateSetting,
    isModified,
    testApiConnection,
    
    // Default values
    defaultSettings
  };
};

export default useSettings;
</file>

<file path="src/hooks/useUsers.js">
import { useState, useEffect, useCallback, useMemo } from 'react';
import userService from '../services/userService';

/**
 * Custom hook for user management operations
 * Provides state management and CRUD operations for users
 */
const useUsers = () => {
  // State
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [stats, setStats] = useState({
    total: 0,
    active: 0,
    inactive: 0,
    departments: 0,
    roles: 0,
    departmentList: [],
    roleList: [],
  });

  // Clear error helper
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Load all users
  const loadUsers = useCallback(async (filters = {}) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await userService.getAllUsers();
      if (result.success) {
        setUsers(result.data);
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error('Error loading users:', err);
      setError(err.message || 'ユーザーの読み込みに失敗しました');
    } finally {
      setLoading(false);
    }
  }, []);

  // Load user statistics
  const loadStats = useCallback(async () => {
    try {
      // Get stats for all users
      const result = await userService.getAllUsers();
      if (result.success) {
        const stats = {
          total: result.data.length,
          active: result.data.filter(u => u.status === 'active').length,
          inactive: result.data.filter(u => u.status === 'inactive').length
        };
        setStats(stats);
      }
    } catch (err) {
      console.error('Error loading user stats:', err);
    }
  }, []);

  // Create new user
  const addUser = useCallback(async (userData) => {
    setLoading(true);
    setError(null);

    try {
      const result = await userService.createUser(userData);
      if (result.success) {
        setUsers(prev => [...prev, result.data]);
        await loadStats(); // Refresh stats
        return result.data;
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error('Error creating user:', err);
      setError(err.message || 'ユーザーの作成に失敗しました');
      throw err;
    } finally {
      setLoading(false);
    }
  }, [loadStats]);

  // Update existing user
  const updateExistingUser = useCallback(async (userId, updateData) => {
    setLoading(true);
    setError(null);

    try {
      const result = await userService.updateUser(userId, updateData);
      if (!result.success) {
        throw new Error(result.error);
      }
      const updatedUser = result.data;
      setUsers(prev => prev.map(user => 
        user.id === userId ? updatedUser : user
      ));
      await loadStats(); // Refresh stats
      return updatedUser;
    } catch (err) {
      console.error('Error updating user:', err);
      setError(err.message || 'ユーザーの更新に失敗しました');
      throw err;
    } finally {
      setLoading(false);
    }
  }, [loadStats]);

  // Delete user
  const removeUser = useCallback(async (userId) => {
    setLoading(true);
    setError(null);

    try {
      const result = await userService.deleteUser(userId);
      if (result.success) {
        setUsers(prev => prev.filter(user => user.id !== userId));
        await loadStats(); // Refresh stats
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error('Error deleting user:', err);
      setError(err.message || 'ユーザーの削除に失敗しました');
      throw err;
    } finally {
      setLoading(false);
    }
  }, [loadStats]);

  // Toggle user active status
  const toggleUserActive = useCallback(async (userId) => {
    setError(null);

    try {
      const result = await userService.toggleUserActive(userId);
      if (!result.success) {
        throw new Error(result.error);
      }

      // Update local state with the toggled user
      setUsers(prev => prev.map(u => 
        u.id === userId ? result.data : u
      ));
      
      await loadStats(); // Refresh stats
    } catch (err) {
      console.error('Error toggling user status:', err);
      setError(err.message || 'ユーザーステータスの変更に失敗しました');
      throw err;
    }
  }, [users, loadStats]);

  // Toggle user starred status (local only for now)
  const toggleUserStarred = useCallback(async (userId) => {
    try {
      setUsers(prev => prev.map(user => 
        user.id === userId 
          ? { ...user, isStarred: !user.isStarred }
          : user
      ));

      // Note: In a real app, this would also update the database
      // For now, we're keeping it in local state only
    } catch (err) {
      console.error('Error toggling user starred status:', err);
      setError('お気に入りの変更に失敗しました');
    }
  }, []);

  // Search users
  const searchUsersByTerm = useCallback(async (searchTerm) => {
    if (!searchTerm || searchTerm.trim().length < 2) {
      await loadUsers(); // Load all users if search term is empty
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Simple search implementation
      const result = await userService.getAllUsers();
      if (result.success) {
        const filtered = result.data.filter(user => 
          user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          user.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
          user.department.toLowerCase().includes(searchTerm.toLowerCase())
        );
        setUsers(filtered);
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error('Error searching users:', err);
      setError(err.message || 'ユーザーの検索に失敗しました');
    } finally {
      setLoading(false);
    }
  }, [loadUsers]);

  // Get user by ID
  const getUserData = useCallback(async (userId) => {
    setError(null);

    try {
      const result = await userService.getUserById(userId);
      if (result.success) {
        return result.data;
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error('Error getting user:', err);
      setError(err.message || 'ユーザーの取得に失敗しました');
      throw err;
    }
  }, []);

  // Bulk operations
  const performBulkAction = useCallback(async (action, userIds) => {
    setLoading(true);
    setError(null);

    try {
      const promises = userIds.map(userId => {
        switch (action) {
          case 'activate':
          case 'deactivate':
            return userService.toggleUserActive(userId);
          case 'delete':
            return userService.deleteUser(userId);
          default:
            return Promise.resolve();
        }
      });

      await Promise.all(promises);

      // Refresh user list
      await loadUsers();
      await loadStats();

      return true;
    } catch (err) {
      console.error('Error performing bulk action:', err);
      setError(err.message || '一括操作に失敗しました');
      throw err;
    } finally {
      setLoading(false);
    }
  }, [loadUsers, loadStats]);

  // Export users to CSV
  const exportUsers = useCallback((usersToExport = users) => {
    try {
      const headers = [
        'ID',
        '名前',
        'メールアドレス',
        '電話番号',
        '役割',
        '部署',
        'ステータス',
        '総支出',
        '総収入',
        '取引数',
        '最終活動',
        '入社日',
        '備考'
      ];

      const csvData = usersToExport.map(user => [
        user.id,
        user.name,
        user.email,
        user.phone || '',
        user.role,
        user.department,
        user.isActive ? 'アクティブ' : '非アクティブ',
        user.totalExpenses || 0,
        user.totalIncome || 0,
        user.transactionCount || 0,
        user.lastActivity || '',
        user.joinDate || '',
        user.notes || ''
      ]);

      const csvContent = [headers, ...csvData]
        .map(row => row.map(field => `"${field}"`).join(','))
        .join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', `users_${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      return true;
    } catch (err) {
      console.error('Error exporting users:', err);
      setError('ユーザーのエクスポートに失敗しました');
      return false;
    }
  }, [users]);

  // Computed values
  const activeUsers = useMemo(() => 
    users.filter(user => user.isActive || user.status === 'active'),
    [users]
  );

  const starredUsers = useMemo(() => 
    users.filter(user => user.isStarred),
    [users]
  );

  const usersByDepartment = useMemo(() => {
    const grouped = users.reduce((acc, user) => {
      const dept = user.department || 'その他';
      if (!acc[dept]) acc[dept] = [];
      acc[dept].push(user);
      return acc;
    }, {});
    return grouped;
  }, [users]);

  const usersByRole = useMemo(() => {
    const grouped = users.reduce((acc, user) => {
      const role = user.role || 'その他';
      if (!acc[role]) acc[role] = [];
      acc[role].push(user);
      return acc;
    }, {});
    return grouped;
  }, [users]);

  // Load initial data
  useEffect(() => {
    loadUsers();
    loadStats();
  }, [loadUsers, loadStats]);

  return {
    // State
    users,
    loading,
    error,
    stats,

    // Computed values
    activeUsers,
    starredUsers,
    usersByDepartment,
    usersByRole,

    // Actions
    loadUsers,
    loadStats,
    addUser,
    updateUser: updateExistingUser,
    removeUser,
    toggleUserActive,
    toggleUserStarred,
    searchUsers: searchUsersByTerm,
    getUserData,
    performBulkAction,
    exportUsers,
    clearError,

    // Utilities
    refreshData: useCallback(() => {
      loadUsers();
      loadStats();
    }, [loadUsers, loadStats]),
  };
};

export default useUsers;
</file>

<file path="src/pages/Analytics.js">
import React, { useState, useEffect } from 'react';
import {
  Container,
  Grid,
  Typography,
  Box,
  Button,
  Stack,
  Fab,
  Snackbar,
  Alert,
} from '@mui/material';
import {
  Download as DownloadIcon,
  Refresh as RefreshIcon,
  GetApp as GetAppIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../components/common/GlassCard';
import { formatCurrency } from '../utils/formatters';

// Import new analytics components
import FinancialSummary from '../components/Analytics/FinancialSummary';
import ExpenseChart from '../components/Analytics/ExpenseChart';
import IncomeChart from '../components/Analytics/IncomeChart';
import UserRanking from '../components/Analytics/UserRanking';
import FilterPanel from '../components/Analytics/FilterPanel';
import useAnalytics from '../hooks/useAnalytics';
import categoryService from '../services/categoryService';
import userService from '../services/userService';
import { formatDate } from '../utils/formatters';
import useSettings from '../hooks/useSettings';

const Analytics = () => {
  const { settings } = useSettings();
  const [filters, setFilters] = useState({
    dateRange: {
      startDate: new Date(2024, 0, 1),
      endDate: new Date(),
    },
    period: 'monthly',
    categories: [],
    users: [],
    departments: [],
    amountRange: {
      min: '',
      max: '',
    },
    transactionType: 'all',
  });

  const [exportSnackbar, setExportSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });

  const [filterOptions, setFilterOptions] = useState({
    categories: [],
    users: [],
    departments: []
  });

  // Use the analytics hook
  const {
    financialSummary,
    expenseChartData,
    incomeChartData,
    userRankingData,
    statistics,
    isLoading,
    error,
    exportData,
    totalRecords,
  } = useAnalytics(filters);

  // Filter change handler
  const handleFiltersChange = (newFilters) => {
    setFilters(newFilters);
  };

  // Load filter options on mount
  useEffect(() => {
    const loadFilterOptions = async () => {
      try {
        const [categoriesResult, usersResult] = await Promise.all([
          categoryService.getAllCategories(),
          userService.getAllUsers()
        ]);

        const categories = categoriesResult.success ? categoriesResult.data : [];
        const users = usersResult.success ? usersResult.data : [];

        // Extract unique categories and departments
        const categoryNames = [...new Set(categories.map(cat => cat.name))];
        const userNames = [...new Set(users.map(user => user.name))];
        const departments = [...new Set(users.map(user => user.department).filter(Boolean))];

        setFilterOptions({
          categories: categoryNames,
          users: userNames,
          departments: departments
        });
      } catch (error) {
        console.error('Error loading filter options:', error);
      }
    };

    loadFilterOptions();
  }, []);

  // Export handlers
  const handleExportJSON = () => {
    try {
      const jsonData = exportData('json');
      const blob = new Blob([jsonData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `analytics-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      setExportSnackbar({
        open: true,
        message: 'JSONファイルをエクスポートしました',
        severity: 'success'
      });
    } catch (err) {
      setExportSnackbar({
        open: true,
        message: 'エクスポートに失敗しました',
        severity: 'error'
      });
    }
  };

  const handleExportCSV = () => {
    try {
      const csvData = exportData('csv');
      const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `analytics-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      setExportSnackbar({
        open: true,
        message: 'CSVファイルをエクスポートしました',
        severity: 'success'
      });
    } catch (err) {
      setExportSnackbar({
        open: true,
        message: 'エクスポートに失敗しました',
        severity: 'error'
      });
    }
  };

  const handleRefresh = () => {
    // In a real app, this would refetch data from the API
    setExportSnackbar({
      open: true,
      message: 'データを更新しました',
      severity: 'info'
    });
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  if (error) {
    return (
      <Container maxWidth="xl">
        <Alert severity="error" sx={{ mt: 2 }}>
          データの読み込み中にエラーが発生しました: {error}
        </Alert>
      </Container>
    );
  }

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* Header */}
        <motion.div variants={itemVariants}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
            <Box>
              <Typography
                variant="h3"
                gutterBottom
                sx={{
                  background: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                  fontWeight: 700,
                  mb: 1,
                }}
              >
                分析・レポート
              </Typography>
              <Typography variant="h6" color="text.secondary">
                {totalRecords}件のデータを分析中
                {isLoading && ' • 読み込み中...'}
              </Typography>
            </Box>
            
            <Stack direction="row" spacing={2}>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={handleRefresh}
                sx={{
                  borderColor: 'rgba(255, 255, 255, 0.3)',
                  color: 'rgba(255, 255, 255, 0.8)',
                  '&:hover': {
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    backgroundColor: 'rgba(255, 255, 255, 0.05)',
                  },
                }}
              >
                更新
              </Button>
              <Button
                variant="contained"
                startIcon={<DownloadIcon />}
                onClick={handleExportJSON}
                sx={{
                  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  color: 'white',
                  '&:hover': {
                    opacity: 0.9,
                  },
                }}
              >
                エクスポート
              </Button>
            </Stack>
          </Box>
        </motion.div>

        {/* Filters */}
        <motion.div variants={itemVariants}>
          <Box sx={{ mb: 4 }}>
            <FilterPanel
              filters={filters}
              onFiltersChange={handleFiltersChange}
              data={filterOptions}
            />
          </Box>
        </motion.div>

        {/* Financial Summary */}
        <motion.div variants={itemVariants}>
          <Box sx={{ mb: 4 }}>
            <FinancialSummary
              data={financialSummary}
              period={filters.period}
            />
          </Box>
        </motion.div>

        {/* Charts Section */}
        <Grid container spacing={4} sx={{ mb: 4 }}>
          {/* Expense Chart */}
          <Grid item xs={12} lg={6}>
            <motion.div variants={itemVariants}>
              <ExpenseChart
                data={expenseChartData}
                period={filters.period}
              />
            </motion.div>
          </Grid>

          {/* Income Chart */}
          <Grid item xs={12} lg={6}>
            <motion.div variants={itemVariants}>
              <IncomeChart
                data={incomeChartData}
                period={filters.period}
              />
            </motion.div>
          </Grid>
        </Grid>

        {/* User Rankings */}
        <motion.div variants={itemVariants}>
          <Box sx={{ mb: 4 }}>
            <UserRanking
              data={userRankingData}
              period={filters.period}
            />
          </Box>
        </motion.div>

        {/* Statistics Summary */}
        <motion.div variants={itemVariants}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={4}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h6" gutterBottom fontWeight="bold">
                    データ統計
                  </Typography>
                  <Stack spacing={2}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        総取引数
                      </Typography>
                      <Typography variant="body1" fontWeight="bold">
                        {statistics.totalTransactions}件
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        収入取引
                      </Typography>
                      <Typography variant="body1" fontWeight="bold" color="success.main">
                        {statistics.incomeTransactions}件
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        支出取引
                      </Typography>
                      <Typography variant="body1" fontWeight="bold" color="error.main">
                        {statistics.expenseTransactions}件
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        平均取引額
                      </Typography>
                      <Typography variant="body1" fontWeight="bold">
                        {formatCurrency(statistics.averageTransactionAmount, true)}
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} md={4}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h6" gutterBottom fontWeight="bold">
                    分析範囲
                  </Typography>
                  <Stack spacing={2}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        ユーザー数
                      </Typography>
                      <Typography variant="body1" fontWeight="bold">
                        {statistics.uniqueUsers}名
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        カテゴリ数
                      </Typography>
                      <Typography variant="body1" fontWeight="bold">
                        {statistics.uniqueCategories}個
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        部門数
                      </Typography>
                      <Typography variant="body1" fontWeight="bold">
                        {statistics.uniqueDepartments}部門
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        分析期間
                      </Typography>
                      <Typography variant="body1" fontWeight="bold">
                        {filters.period === 'monthly' ? '月別' : 
                         filters.period === 'quarterly' ? '四半期別' :
                         filters.period === 'yearly' ? '年別' : 
                         filters.period === 'weekly' ? '週別' : '日別'}
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} md={4}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h6" gutterBottom fontWeight="bold">
                    データ品質
                  </Typography>
                  <Stack spacing={2}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        完全性
                      </Typography>
                      <Typography variant="body1" fontWeight="bold" color="success.main">
                        {statistics.dataQuality?.completeness || 100}%
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        正確性
                      </Typography>
                      <Typography variant="body1" fontWeight="bold" color="success.main">
                        {statistics.dataQuality?.accuracy || 95}%
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        一貫性
                      </Typography>
                      <Typography variant="body1" fontWeight="bold" color="success.main">
                        {statistics.dataQuality?.consistency || 98}%
                      </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="body2" color="text.secondary">
                        最終更新
                      </Typography>
                      <Typography variant="body1" fontWeight="bold">
                        {formatDate(new Date(), settings.dateFormat)}
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </Grid>
          </Grid>
        </motion.div>

        {/* Floating Action Button for CSV Export */}
        <Fab
          color="secondary"
          aria-label="CSV Export"
          onClick={handleExportCSV}
          sx={{
            position: 'fixed',
            bottom: 24,
            right: 24,
            background: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
            '&:hover': {
              opacity: 0.9,
            },
          }}
        >
          <GetAppIcon />
        </Fab>

        {/* Snackbar for notifications */}
        <Snackbar
          open={exportSnackbar.open}
          autoHideDuration={4000}
          onClose={() => setExportSnackbar(prev => ({ ...prev, open: false }))}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'left' }}
        >
          <Alert
            onClose={() => setExportSnackbar(prev => ({ ...prev, open: false }))}
            severity={exportSnackbar.severity}
            variant="filled"
            sx={{ width: '100%' }}
          >
            {exportSnackbar.message}
          </Alert>
        </Snackbar>
      </motion.div>
    </Container>
  );
};

export default Analytics;
</file>

<file path="src/pages/Dashboard.js">
import React, { useState, useEffect } from 'react';
import { useTheme } from '@mui/material/styles';
import {
  Container,
  Grid,
  Typography,
  Box,
  Chip,
  IconButton,
  Stack,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Avatar,
  Divider,
} from '@mui/material';
import {
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  AccountBalance as AccountBalanceIcon,
  Timeline as TimelineIcon,
  ArrowUpward as ArrowUpwardIcon,
  ArrowDownward as ArrowDownwardIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { Doughnut, Line } from 'react-chartjs-2';
import GlassCard, { GlassCardContent, GlassCardPresets } from '../components/common/GlassCard';
import expenseService from '../services/expenseService';
import incomeService from '../services/incomeService';
import categoryService from '../services/categoryService';
import { formatDate } from '../utils/formatters';
import useSettings from '../hooks/useSettings';

const Dashboard = () => {
  const theme = useTheme();
  const { settings } = useSettings();
  const [stats, setStats] = useState({
    totalIncome: 0,
    totalExpenses: 0,
    netProfit: 0,
    totalTransactions: 0,
    previousIncome: 0,
    previousExpenses: 0,
  });

  const [recentTransactions, setRecentTransactions] = useState([]);
  const [categoryData, setCategoryData] = useState({
    labels: [],
    datasets: [{
      data: [],
      backgroundColor: [],
      borderColor: [],
      borderWidth: 2,
    }],
  });

  const [trendData, setTrendData] = useState({
    labels: [],
    datasets: [],
  });

  const [loading, setLoading] = useState(true);

  // Load data from storage
  useEffect(() => {
    loadDashboardData();
  }, []);

  const loadDashboardData = async () => {
    try {
      setLoading(true);

      // Get current month data
      const now = new Date();
      const currentMonth = now.getMonth();
      const currentYear = now.getFullYear();
      const startOfMonth = new Date(currentYear, currentMonth, 1);
      const endOfMonth = new Date(currentYear, currentMonth + 1, 0);
      
      // Get previous month for comparison
      const startOfPrevMonth = new Date(currentYear, currentMonth - 1, 1);
      const endOfPrevMonth = new Date(currentYear, currentMonth, 0);

      // Get expenses and income for current month
      const currentExpenses = await expenseService.getExpensesByDateRange(
        startOfMonth.toISOString(),
        endOfMonth.toISOString()
      );
      const currentIncome = await incomeService.getIncomeByDateRange(
        startOfMonth.toISOString(),
        endOfMonth.toISOString()
      );

      // Get previous month data
      const prevExpenses = await expenseService.getExpensesByDateRange(
        startOfPrevMonth.toISOString(),
        endOfPrevMonth.toISOString()
      );
      const prevIncome = await incomeService.getIncomeByDateRange(
        startOfPrevMonth.toISOString(),
        endOfPrevMonth.toISOString()
      );

      // Calculate totals
      const totalExpenses = currentExpenses.success ? 
        currentExpenses.data.reduce((sum, exp) => sum + exp.amount, 0) : 0;
      const totalIncome = currentIncome.success ? 
        currentIncome.data.reduce((sum, inc) => sum + inc.amount, 0) : 0;
      const previousExpenses = prevExpenses.success ? 
        prevExpenses.data.reduce((sum, exp) => sum + exp.amount, 0) : 0;
      const previousIncome = prevIncome.success ? 
        prevIncome.data.reduce((sum, inc) => sum + inc.amount, 0) : 0;

      setStats({
        totalIncome,
        totalExpenses,
        netProfit: totalIncome - totalExpenses,
        totalTransactions: 
          (currentExpenses.success ? currentExpenses.data.length : 0) + 
          (currentIncome.success ? currentIncome.data.length : 0),
        previousIncome,
        previousExpenses,
      });

      // Get recent transactions (last 5)
      const allTransactions = [
        ...(currentExpenses.success ? currentExpenses.data.map(e => ({
          ...e,
          type: 'expense',
          amount: -e.amount
        })) : []),
        ...(currentIncome.success ? currentIncome.data.map(i => ({
          ...i,
          type: 'income'
        })) : [])
      ].sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, 5);

      // Get category names
      const categories = await categoryService.getAllCategories();
      const categoryMap = {};
      if (categories.success) {
        categories.data.forEach(cat => {
          categoryMap[cat.id] = cat;
        });
      }

      // Map transactions with category names
      const transactionsWithCategories = allTransactions.map(t => ({
        ...t,
        category: categoryMap[t.categoryId]?.name || 'その他'
      }));

      setRecentTransactions(transactionsWithCategories);

      // Prepare category chart data for expenses
      if (currentExpenses.success && categories.success) {
        const expensesByCategory = {};
        currentExpenses.data.forEach(exp => {
          const categoryName = categoryMap[exp.categoryId]?.name || 'その他';
          expensesByCategory[categoryName] = (expensesByCategory[categoryName] || 0) + exp.amount;
        });

        const sortedCategories = Object.entries(expensesByCategory)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        setCategoryData({
          labels: sortedCategories.map(([name]) => name),
          datasets: [{
            data: sortedCategories.map(([, amount]) => amount),
            backgroundColor: [
              'rgba(102, 126, 234, 0.8)',
              'rgba(250, 112, 154, 0.8)',
              'rgba(79, 172, 254, 0.8)',
              'rgba(168, 237, 234, 0.8)',
              'rgba(255, 236, 210, 0.8)',
            ],
            borderColor: [
              'rgba(102, 126, 234, 1)',
              'rgba(250, 112, 154, 1)',
              'rgba(79, 172, 254, 1)',
              'rgba(168, 237, 234, 1)',
              'rgba(255, 236, 210, 1)',
            ],
            borderWidth: 2,
          }],
        });
      }

      // Prepare trend data (last 5 months)
      const monthLabels = [];
      const incomeData = [];
      const expenseData = [];

      for (let i = 4; i >= 0; i--) {
        const month = new Date(currentYear, currentMonth - i, 1);
        const monthEnd = new Date(currentYear, currentMonth - i + 1, 0);
        
        monthLabels.push(month.toLocaleDateString('ja-JP', { month: 'short' }));
        
        const monthExpenses = await expenseService.getExpensesByDateRange(
          month.toISOString(),
          monthEnd.toISOString()
        );
        const monthIncome = await incomeService.getIncomeByDateRange(
          month.toISOString(),
          monthEnd.toISOString()
        );

        expenseData.push(monthExpenses.success ? 
          monthExpenses.data.reduce((sum, exp) => sum + exp.amount, 0) : 0);
        incomeData.push(monthIncome.success ? 
          monthIncome.data.reduce((sum, inc) => sum + inc.amount, 0) : 0);
      }

      setTrendData({
        labels: monthLabels,
        datasets: [
          {
            label: '収入',
            data: incomeData,
            borderColor: 'rgba(102, 126, 234, 1)',
            backgroundColor: 'rgba(102, 126, 234, 0.1)',
            fill: true,
            tension: 0.4,
          },
          {
            label: '支出',
            data: expenseData,
            borderColor: 'rgba(250, 112, 154, 1)',
            backgroundColor: 'rgba(250, 112, 154, 0.1)',
            fill: true,
            tension: 0.4,
          },
        ],
      });

    } catch (error) {
      console.error('Error loading dashboard data:', error);
    } finally {
      setLoading(false);
    }
  };

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        display: false,
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        grid: {
          color: theme.palette.divider,
        },
        ticks: {
          color: theme.palette.text.secondary,
          callback: function(value) {
            return '¥' + value.toLocaleString();
          },
        },
      },
      x: {
        grid: {
          color: theme.palette.divider,
        },
        ticks: {
          color: theme.palette.text.secondary,
        },
      },
    },
  };

  const doughnutOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'bottom',
        labels: {
          color: theme.palette.text.secondary,
          padding: 20,
        },
      },
    },
  };

  const calculateChange = (current, previous) => {
    if (previous === 0) return { value: '0.0', isPositive: true };
    const change = ((current - previous) / previous) * 100;
    return {
      value: Math.abs(change).toFixed(1),
      isPositive: change >= 0,
    };
  };

  const incomeChange = calculateChange(stats.totalIncome, stats.previousIncome);
  const expenseChange = calculateChange(stats.totalExpenses, stats.previousExpenses);
  const profitMargin = stats.totalIncome > 0 ? 
    ((stats.netProfit / stats.totalIncome) * 100).toFixed(1) : '0.0';

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  if (loading) {
    return (
      <Container maxWidth="xl">
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
          <Typography>読み込み中...</Typography>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        <motion.div variants={itemVariants}>
          <Typography
            variant="h3"
            gutterBottom
            sx={{
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 700,
              mb: 4,
            }}
          >
            ダッシュボード
          </Typography>
        </motion.div>

        {/* KPI Cards */}
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard {...GlassCardPresets.success}>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" justifyContent="space-between">
                    <Box>
                      <Typography variant="h6" color="text.secondary">
                        今月の収入
                      </Typography>
                      <Typography variant="h4" fontWeight="bold">
                        ¥{stats.totalIncome.toLocaleString()}
                      </Typography>
                      <Chip
                        icon={incomeChange.isPositive ? <ArrowUpwardIcon /> : <ArrowDownwardIcon />}
                        label={`${incomeChange.isPositive ? '+' : '-'}${incomeChange.value}%`}
                        color={incomeChange.isPositive ? "success" : "error"}
                        variant="outlined"
                        size="small"
                      />
                    </Box>
                    <IconButton
                      sx={{
                        background: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
                        color: theme.palette.mode === 'dark' ? 'white' : theme.palette.primary.contrastText,
                        '&:hover': { opacity: 0.9 },
                      }}
                    >
                      <TrendingUpIcon />
                    </IconButton>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard {...GlassCardPresets.warning}>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" justifyContent="space-between">
                    <Box>
                      <Typography variant="h6" color="text.secondary">
                        今月の支出
                      </Typography>
                      <Typography variant="h4" fontWeight="bold">
                        ¥{stats.totalExpenses.toLocaleString()}
                      </Typography>
                      <Chip
                        icon={expenseChange.isPositive ? <ArrowUpwardIcon /> : <ArrowDownwardIcon />}
                        label={`${expenseChange.isPositive ? '+' : '-'}${expenseChange.value}%`}
                        color={expenseChange.isPositive ? "error" : "success"}
                        variant="outlined"
                        size="small"
                      />
                    </Box>
                    <IconButton
                      sx={{
                        background: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                        color: theme.palette.mode === 'dark' ? 'white' : theme.palette.primary.contrastText,
                        '&:hover': { opacity: 0.9 },
                      }}
                    >
                      <TrendingDownIcon />
                    </IconButton>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard {...GlassCardPresets.primary}>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" justifyContent="space-between">
                    <Box>
                      <Typography variant="h6" color="text.secondary">
                        純利益
                      </Typography>
                      <Typography variant="h4" fontWeight="bold">
                        ¥{stats.netProfit.toLocaleString()}
                      </Typography>
                      <Chip
                        icon={<AccountBalanceIcon />}
                        label={`${profitMargin}%`}
                        color="primary"
                        variant="outlined"
                        size="small"
                      />
                    </Box>
                    <IconButton
                      sx={{
                        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                        color: theme.palette.mode === 'dark' ? 'white' : theme.palette.primary.contrastText,
                        '&:hover': { opacity: 0.9 },
                      }}
                    >
                      <AccountBalanceIcon />
                    </IconButton>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard {...GlassCardPresets.info}>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" justifyContent="space-between">
                    <Box>
                      <Typography variant="h6" color="text.secondary">
                        今月の取引
                      </Typography>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.totalTransactions}
                      </Typography>
                      <Chip
                        icon={<TimelineIcon />}
                        label="件"
                        color="info"
                        variant="outlined"
                        size="small"
                      />
                    </Box>
                    <IconButton
                      sx={{
                        background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                        color: theme.palette.mode === 'dark' ? 'white' : theme.palette.primary.contrastText,
                        '&:hover': { opacity: 0.9 },
                      }}
                    >
                      <TimelineIcon />
                    </IconButton>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        </Grid>

        {/* Charts Section */}
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid item xs={12} md={8}>
            <motion.div variants={itemVariants}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h5" gutterBottom fontWeight="bold">
                    収支推移
                  </Typography>
                  <Box sx={{ height: 350 }}>
                    {trendData.labels.length > 0 ? (
                      <Line data={trendData} options={chartOptions} />
                    ) : (
                      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%' }}>
                        <Typography color="text.secondary">データがありません</Typography>
                      </Box>
                    )}
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} md={4}>
            <motion.div variants={itemVariants}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h6" gutterBottom fontWeight="bold">
                    支出カテゴリ
                  </Typography>
                  <Box sx={{ height: 300 }}>
                    {categoryData.labels.length > 0 ? (
                      <Doughnut data={categoryData} options={doughnutOptions} />
                    ) : (
                      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%' }}>
                        <Typography color="text.secondary">データがありません</Typography>
                      </Box>
                    )}
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        </Grid>

        {/* Recent Transactions */}
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <motion.div variants={itemVariants}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h6" gutterBottom fontWeight="bold">
                    最近の取引
                  </Typography>
                  {recentTransactions.length > 0 ? (
                    <List>
                      {recentTransactions.map((transaction, index) => (
                        <React.Fragment key={transaction.id}>
                          <ListItem
                            sx={{
                              borderRadius: 2,
                              mb: 1,
                              '&:hover': {
                                backgroundColor: 'rgba(255, 255, 255, 0.05)',
                              },
                            }}
                          >
                            <ListItemIcon>
                              <Avatar
                                sx={{
                                  bgcolor: transaction.type === 'income' ? 'success.main' : 'error.main',
                                  width: 40,
                                  height: 40,
                                }}
                              >
                                {transaction.type === 'income' ? <TrendingUpIcon /> : <TrendingDownIcon />}
                              </Avatar>
                            </ListItemIcon>
                            <ListItemText
                              primary={
                                <React.Fragment>
                                  <Typography variant="body1" fontWeight="medium" component="span">
                                    {transaction.description}
                                  </Typography>
                                </React.Fragment>
                              }
                              secondary={
                                <React.Fragment>
                                  <Typography variant="caption" color="text.secondary" component="span">
                                    {transaction.category} • {formatDate(transaction.date, settings.dateFormat)}
                                  </Typography>
                                </React.Fragment>
                              }
                            />
                            <Typography
                              variant="h6"
                              color={transaction.type === 'income' ? 'success.main' : 'error.main'}
                              fontWeight="bold"
                              sx={{ ml: 2 }}
                            >
                              ¥{Math.abs(transaction.amount).toLocaleString()}
                            </Typography>
                          </ListItem>
                          {index < recentTransactions.length - 1 && <Divider />}
                        </React.Fragment>
                      ))}
                    </List>
                  ) : (
                    <Box sx={{ py: 4, textAlign: 'center' }}>
                      <Typography color="text.secondary">取引データがありません</Typography>
                    </Box>
                  )}
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        </Grid>
      </motion.div>
    </Container>
  );
};

export default Dashboard;
</file>

<file path="src/pages/FileTest.js">
import React, { useState } from 'react';
import { Container, Typography, Box, Button, Stack } from '@mui/material';
import FileUpload from '../components/Registration/FileUpload';
import fileService from '../services/fileService';

const FileTest = () => {
  const [files, setFiles] = useState([]);
  const [testResults, setTestResults] = useState([]);

  const addTestResult = (test, success, details = '') => {
    setTestResults(prev => [...prev, { test, success, details, timestamp: new Date().toISOString() }]);
  };

  const testFileService = async () => {
    // Test 1: File upload
    const testFile = new File(['test content'], 'test.txt', { type: 'text/plain' });
    const uploadResult = await fileService.uploadFile(testFile, 'Test file');
    addTestResult('File Upload', uploadResult.success, JSON.stringify(uploadResult.data || uploadResult.error));

    if (uploadResult.success) {
      // Test 2: Get file by ID
      const getResult = await fileService.getFileById(uploadResult.data.id);
      addTestResult('Get File By ID', getResult.success, `Data present: ${!!getResult.data?.data}`);

      // Test 3: Get files by IDs
      const getMultipleResult = await fileService.getFilesByIds([uploadResult.data.id]);
      addTestResult('Get Files By IDs', getMultipleResult.success, `Files count: ${getMultipleResult.data?.length}`);
    }
  };

  return (
    <Container maxWidth="lg">
      <Box sx={{ py: 4 }}>
        <Typography variant="h4" gutterBottom>
          File Upload Test Page
        </Typography>
        
        <Stack spacing={4}>
          <Box>
            <Typography variant="h6" gutterBottom>
              File Upload Component Test
            </Typography>
            <FileUpload
              files={files}
              onFilesChange={setFiles}
              maxFiles={5}
            />
          </Box>

          <Box>
            <Typography variant="h6" gutterBottom>
              Uploaded Files Data
            </Typography>
            <pre style={{ backgroundColor: '#f5f5f5', padding: '16px', borderRadius: '4px', overflow: 'auto' }}>
              {JSON.stringify(files, null, 2)}
            </pre>
          </Box>

          <Box>
            <Button variant="contained" onClick={testFileService}>
              Test File Service
            </Button>
            
            {testResults.length > 0 && (
              <Box sx={{ mt: 2 }}>
                <Typography variant="h6" gutterBottom>
                  Test Results
                </Typography>
                {testResults.map((result, index) => (
                  <Box key={index} sx={{ mb: 1, p: 1, bgcolor: result.success ? 'success.light' : 'error.light', borderRadius: 1 }}>
                    <Typography variant="body2">
                      {result.test}: {result.success ? '✅ Success' : '❌ Failed'}
                    </Typography>
                    {result.details && (
                      <Typography variant="caption" color="text.secondary">
                        {result.details}
                      </Typography>
                    )}
                  </Box>
                ))}
              </Box>
            )}
          </Box>
        </Stack>
      </Box>
    </Container>
  );
};

export default FileTest;
</file>

<file path="src/pages/Invoices.js">
import React, { useState, useEffect } from 'react';
import {
  Container,
  Grid,
  Typography,
  Box,
  Button,
  Chip,
  Stack,
  Avatar,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemSecondaryAction,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  MenuItem,
  FormControlLabel,
  Switch,
  Alert,
  Fab,
  Tooltip,
  Divider,
} from '@mui/material';
import {
  Receipt as ReceiptIcon,
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Payment as PaymentIcon,
  Warning as WarningIcon,
  CheckCircle as CheckCircleIcon,
  Pending as PendingIcon,
  Refresh as RefreshIcon,
  AttachFile as AttachFileIcon,
  Link as LinkIcon,
  Image as ImageIcon,
  Close as CloseIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent, GlassCardPresets } from '../components/common/GlassCard';
import invoiceService from '../services/invoiceService';
import { formatDate, formatCurrency } from '../utils/formatters';
import useSettings from '../hooks/useSettings';
import FileUpload from '../components/Registration/FileUpload';
import FilePreviewDialog from '../components/common/FilePreviewDialog';

const Invoices = () => {
  const { settings } = useSettings();
  const [invoices, setInvoices] = useState([]);
  const [stats, setStats] = useState({});
  const [loading, setLoading] = useState(true);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingInvoice, setEditingInvoice] = useState(null);
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    amount: '',
    dueDate: '',
    isRecurring: false,
    recurringType: 'monthly',
    client: '',
    category: 'other',
    attachments: [],
    links: []
  });
  const [newLink, setNewLink] = useState({ title: '', url: '' });
  const [previewFiles, setPreviewFiles] = useState([]);
  const [previewDialogOpen, setPreviewDialogOpen] = useState(false);
  const [previewIndex, setPreviewIndex] = useState(0);
  const [error, setError] = useState('');

  // Load invoices and stats
  const loadData = async () => {
    try {
      setLoading(true);
      const [invoicesResult, statsResult] = await Promise.all([
        invoiceService.getAllInvoices(),
        invoiceService.getInvoiceStats()
      ]);

      if (invoicesResult.success) {
        setInvoices(invoicesResult.data);
      }
      if (statsResult.success) {
        setStats(statsResult.data);
      }
    } catch (error) {
      console.error('Failed to load data:', error);
      setError('データの読み込みに失敗しました。');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadData();
  }, []);

  // Handle form submission
  const handleSubmit = async () => {
    try {
      setError('');
      
      if (!formData.title || !formData.amount || !formData.dueDate) {
        setError('必須項目を入力してください。');
        return;
      }

      const invoiceData = {
        ...formData,
        amount: parseFloat(formData.amount)
      };

      let result;
      if (editingInvoice) {
        result = await invoiceService.updateInvoice(editingInvoice.id, invoiceData);
      } else {
        result = await invoiceService.createInvoice(invoiceData);
      }

      if (result.success) {
        await loadData();
        handleCloseDialog();
      } else {
        setError(result.error);
      }
    } catch (error) {
      console.error('Error saving invoice:', error);
      setError('保存に失敗しました。');
    }
  };

  // Handle file upload
  const handleFileUpload = (files) => {
    setFormData(prev => ({
      ...prev,
      attachments: [...prev.attachments, ...files]
    }));
  };

  // Handle removing attachment
  const handleRemoveAttachment = (index) => {
    setFormData(prev => ({
      ...prev,
      attachments: prev.attachments.filter((_, i) => i !== index)
    }));
  };

  // Handle adding link
  const handleAddLink = () => {
    if (newLink.title && newLink.url) {
      setFormData(prev => ({
        ...prev,
        links: [...prev.links, { ...newLink, id: Date.now() }]
      }));
      setNewLink({ title: '', url: '' });
    }
  };

  // Handle removing link
  const handleRemoveLink = (id) => {
    setFormData(prev => ({
      ...prev,
      links: prev.links.filter(link => link.id !== id)
    }));
  };

  // Handle attachment preview
  const handlePreviewAttachments = (attachments, startIndex = 0) => {
    setPreviewFiles(attachments);
    setPreviewIndex(startIndex);
    setPreviewDialogOpen(true);
  };

  // Handle opening dialog for new invoice
  const handleNewInvoice = () => {
    setEditingInvoice(null);
    setFormData({
      title: '',
      description: '',
      amount: '',
      dueDate: '',
      isRecurring: false,
      recurringType: 'monthly',
      client: '',
      category: 'other',
      attachments: [],
      links: []
    });
    setNewLink({ title: '', url: '' });
    setDialogOpen(true);
  };

  // Handle editing invoice
  const handleEditInvoice = (invoice) => {
    setEditingInvoice(invoice);
    setFormData({
      title: invoice.title,
      description: invoice.description || '',
      amount: invoice.amount.toString(),
      dueDate: invoice.dueDate.split('T')[0],
      isRecurring: invoice.isRecurring || false,
      recurringType: invoice.recurringType || 'monthly',
      client: invoice.client || '',
      category: invoice.category || 'other',
      attachments: invoice.attachments || [],
      links: invoice.links || []
    });
    setNewLink({ title: '', url: '' });
    setError('');
    setDialogOpen(true);
  };

  // Handle closing dialog
  const handleCloseDialog = () => {
    setDialogOpen(false);
    setEditingInvoice(null);
    setError('');
  };

  // Handle marking as paid
  const handleMarkAsPaid = async (invoiceId) => {
    try {
      const result = await invoiceService.markInvoiceAsPaid(invoiceId);
      if (result.success) {
        await loadData();
      } else {
        setError(result.error);
      }
    } catch (error) {
      console.error('Error marking as paid:', error);
      setError('支払い処理に失敗しました。');
    }
  };

  // Handle delete
  const handleDelete = async (invoiceId) => {
    if (window.confirm('この請求書を削除しますか？')) {
      try {
        const result = await invoiceService.deleteInvoice(invoiceId);
        if (result.success) {
          await loadData();
        } else {
          setError(result.error);
        }
      } catch (error) {
        console.error('Error deleting invoice:', error);
        setError('削除に失敗しました。');
      }
    }
  };

  // Format currency
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('ja-JP', {
      style: 'currency',
      currency: 'JPY'
    }).format(amount);
  };

  // Get status color and icon
  const getStatusInfo = (invoice) => {
    const now = new Date();
    const dueDate = new Date(invoice.dueDate);
    
    if (invoice.status === 'paid') {
      return { color: 'success', icon: <CheckCircleIcon />, label: '支払済' };
    } else if (dueDate < now) {
      return { color: 'error', icon: <WarningIcon />, label: '期限切れ' };
    } else {
      return { color: 'warning', icon: <PendingIcon />, label: '未払い' };
    }
  };

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  if (loading) {
    return (
      <Container maxWidth="xl">
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
          <Typography>読み込み中...</Typography>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* Header */}
        <motion.div variants={itemVariants}>
          <Typography
            variant="h3"
            gutterBottom
            sx={{
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 700,
              mb: 1,
            }}
          >
            請求書管理
          </Typography>
          <Typography variant="subtitle1" color="text.secondary" sx={{ mb: 4 }}>
            請求書の作成・管理・期日通知システム
          </Typography>
        </motion.div>

        {/* Error Alert */}
        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError('')}>
            {error}
          </Alert>
        )}

        {/* Statistics Cards */}
        <motion.div variants={itemVariants}>
          <Grid container spacing={3} sx={{ mb: 4 }}>
            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.info}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'primary.main' }}>
                      <ReceiptIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.total || 0}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        総請求書数
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.warning}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'warning.main' }}>
                      <PendingIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.pending || 0}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        未払い
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.error}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'error.main' }}>
                      <WarningIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.overdue || 0}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        期限切れ
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.success}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'success.main' }}>
                      <CheckCircleIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {formatCurrency(stats.paidAmount || 0)}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        支払済み金額
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>
          </Grid>
        </motion.div>

        {/* Invoice List */}
        <motion.div variants={itemVariants}>
          <GlassCard>
            <GlassCardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <ReceiptIcon />
                  請求書一覧
                </Typography>
                <Button
                  variant="contained"
                  startIcon={<RefreshIcon />}
                  onClick={loadData}
                  sx={{
                    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  }}
                >
                  更新
                </Button>
              </Box>

              {invoices.length > 0 ? (
                <List>
                  {invoices.map((invoice) => {
                    const statusInfo = getStatusInfo(invoice);
                    return (
                      <ListItem
                        key={invoice.id}
                        sx={{
                          border: '1px solid',
                          borderColor: 'divider',
                          borderRadius: 2,
                          mb: 2,
                          backgroundColor: 'background.paper',
                        }}
                      >
                        <ListItemIcon>
                          <Avatar sx={{ bgcolor: `${statusInfo.color}.main` }}>
                            {statusInfo.icon}
                          </Avatar>
                        </ListItemIcon>
                        <Box sx={{ flex: 1 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                            <Typography variant="subtitle1" fontWeight="bold">
                              {invoice.title}
                            </Typography>
                            <Chip
                              size="small"
                              label={statusInfo.label}
                              color={statusInfo.color}
                            />
                            {invoice.isRecurring && (
                              <Chip
                                size="small"
                                label="定期"
                                color="primary"
                                variant="outlined"
                                icon={<RefreshIcon />}
                              />
                            )}
                          </Box>
                          <Typography variant="body2" color="text.secondary">
                            {invoice.description || '説明なし'}
                          </Typography>
                          <Typography variant="body2" color="text.secondary">
                            期日: {formatDate(invoice.dueDate, settings.dateFormat)}
                            {invoice.client && ` • クライアント: ${invoice.client}`}
                          </Typography>
                          <Typography variant="h6" color="primary.main" fontWeight="bold" sx={{ mt: 1 }}>
                            {formatCurrency(invoice.amount)}
                          </Typography>
                          {/* Attachments and Links */}
                          {(invoice.attachments?.length > 0 || invoice.links?.length > 0) && (
                            <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                              {invoice.attachments?.length > 0 && (
                                <Chip
                                  size="small"
                                  icon={<AttachFileIcon />}
                                  label={`${invoice.attachments.length}個のファイル`}
                                  onClick={() => handlePreviewAttachments(invoice.attachments, 0)}
                                  sx={{ cursor: 'pointer' }}
                                  color="secondary"
                                  variant="outlined"
                                />
                              )}
                              {invoice.links?.length > 0 && (
                                <Chip
                                  size="small"
                                  icon={<LinkIcon />}
                                  label={`${invoice.links.length}個のリンク`}
                                  color="info"
                                  variant="outlined"
                                />
                              )}
                            </Box>
                          )}
                        </Box>
                        <ListItemSecondaryAction>
                          <Stack direction="row" spacing={1}>
                            {invoice.status === 'pending' && (
                              <Tooltip title="支払済みにする">
                                <IconButton
                                  color="success"
                                  onClick={() => handleMarkAsPaid(invoice.id)}
                                >
                                  <PaymentIcon />
                                </IconButton>
                              </Tooltip>
                            )}
                            <Tooltip title="編集">
                              <IconButton
                                color="primary"
                                onClick={() => handleEditInvoice(invoice)}
                              >
                                <EditIcon />
                              </IconButton>
                            </Tooltip>
                            <Tooltip title="削除">
                              <IconButton
                                color="error"
                                onClick={() => handleDelete(invoice.id)}
                              >
                                <DeleteIcon />
                              </IconButton>
                            </Tooltip>
                          </Stack>
                        </ListItemSecondaryAction>
                      </ListItem>
                    );
                  })}
                </List>
              ) : (
                <Box sx={{ textAlign: 'center', py: 4 }}>
                  <Typography color="text.secondary">
                    請求書がありません
                  </Typography>
                </Box>
              )}
            </GlassCardContent>
          </GlassCard>
        </motion.div>

        {/* Floating Action Button */}
        <Fab
          color="primary"
          aria-label="add"
          sx={{
            position: 'fixed',
            bottom: 16,
            right: 16,
            background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          }}
          onClick={handleNewInvoice}
        >
          <AddIcon />
        </Fab>

        {/* Invoice Dialog */}
        <Dialog open={dialogOpen} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
          <DialogTitle>
            {editingInvoice ? '請求書を編集' : '新しい請求書を作成'}
          </DialogTitle>
          <DialogContent>
            <Stack spacing={3} sx={{ mt: 1 }}>
              <TextField
                label="タイトル"
                fullWidth
                required
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
              />
              
              <TextField
                label="説明"
                fullWidth
                multiline
                rows={3}
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
              />

              <TextField
                label="金額"
                fullWidth
                required
                type="number"
                value={formData.amount}
                onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
                InputProps={{
                  startAdornment: '¥',
                }}
              />

              <TextField
                label="期日"
                fullWidth
                required
                type="date"
                value={formData.dueDate}
                onChange={(e) => setFormData({ ...formData, dueDate: e.target.value })}
                InputLabelProps={{
                  shrink: true,
                }}
              />

              <TextField
                label="クライアント"
                fullWidth
                value={formData.client}
                onChange={(e) => setFormData({ ...formData, client: e.target.value })}
              />

              <TextField
                label="カテゴリ"
                fullWidth
                select
                value={formData.category}
                onChange={(e) => setFormData({ ...formData, category: e.target.value })}
              >
                <MenuItem value="consulting">コンサルティング</MenuItem>
                <MenuItem value="development">開発</MenuItem>
                <MenuItem value="maintenance">保守</MenuItem>
                <MenuItem value="licensing">ライセンス</MenuItem>
                <MenuItem value="other">その他</MenuItem>
              </TextField>

              <FormControlLabel
                control={
                  <Switch
                    checked={formData.isRecurring}
                    onChange={(e) => setFormData({ ...formData, isRecurring: e.target.checked })}
                  />
                }
                label="定期請求書"
              />

              {formData.isRecurring && (
                <TextField
                  label="繰り返し間隔"
                  fullWidth
                  select
                  value={formData.recurringType}
                  onChange={(e) => setFormData({ ...formData, recurringType: e.target.value })}
                >
                  <MenuItem value="weekly">毎週</MenuItem>
                  <MenuItem value="monthly">毎月</MenuItem>
                  <MenuItem value="quarterly">四半期</MenuItem>
                  <MenuItem value="yearly">毎年</MenuItem>
                </TextField>
              )}

              <Divider />

              {/* File Attachments Section */}
              <Box>
                <Typography variant="subtitle2" sx={{ mb: 2, display: 'flex', alignItems: 'center', gap: 1 }}>
                  <AttachFileIcon />
                  添付ファイル
                </Typography>
                <FileUpload
                  onFileUpload={handleFileUpload}
                  maxFiles={10}
                  acceptedTypes={['image/*', 'application/pdf', '.doc', '.docx', '.xls', '.xlsx']}
                />
                {formData.attachments.length > 0 && (
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="caption" color="text.secondary" sx={{ mb: 1, display: 'block' }}>
                      アップロード済みファイル:
                    </Typography>
                    <Stack direction="row" spacing={1} flexWrap="wrap" gap={1}>
                      {formData.attachments.map((file, index) => (
                        <Chip
                          key={index}
                          label={file.name}
                          onDelete={() => handleRemoveAttachment(index)}
                          onClick={() => handlePreviewAttachments([file], 0)}
                          icon={<ImageIcon />}
                          sx={{ cursor: 'pointer' }}
                        />
                      ))}
                    </Stack>
                  </Box>
                )}
              </Box>

              {/* Links Section */}
              <Box>
                <Typography variant="subtitle2" sx={{ mb: 2, display: 'flex', alignItems: 'center', gap: 1 }}>
                  <LinkIcon />
                  関連リンク
                </Typography>
                <Stack direction="row" spacing={1} sx={{ mb: 2 }}>
                  <TextField
                    label="リンクタイトル"
                    value={newLink.title}
                    onChange={(e) => setNewLink({ ...newLink, title: e.target.value })}
                    size="small"
                    sx={{ flex: 1 }}
                  />
                  <TextField
                    label="URL"
                    value={newLink.url}
                    onChange={(e) => setNewLink({ ...newLink, url: e.target.value })}
                    size="small"
                    sx={{ flex: 2 }}
                    placeholder="https://..."
                  />
                  <Button
                    variant="outlined"
                    onClick={handleAddLink}
                    disabled={!newLink.title || !newLink.url}
                    size="small"
                  >
                    追加
                  </Button>
                </Stack>
                {formData.links.length > 0 && (
                  <Box>
                    <Typography variant="caption" color="text.secondary" sx={{ mb: 1, display: 'block' }}>
                      追加済みリンク:
                    </Typography>
                    <Stack spacing={1}>
                      {formData.links.map((link) => (
                        <Box
                          key={link.id}
                          sx={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            p: 1,
                            border: '1px solid',
                            borderColor: 'divider',
                            borderRadius: 1,
                            bgcolor: 'background.paper'
                          }}
                        >
                          <Box sx={{ flex: 1, overflow: 'hidden' }}>
                            <Typography variant="body2" fontWeight="medium" noWrap>
                              {link.title}
                            </Typography>
                            <Typography
                              variant="caption"
                              color="primary"
                              component="a"
                              href={link.url}
                              target="_blank"
                              rel="noopener noreferrer"
                              sx={{ textDecoration: 'none', '&:hover': { textDecoration: 'underline' } }}
                            >
                              {link.url}
                            </Typography>
                          </Box>
                          <IconButton
                            size="small"
                            onClick={() => handleRemoveLink(link.id)}
                            color="error"
                          >
                            <CloseIcon />
                          </IconButton>
                        </Box>
                      ))}
                    </Stack>
                  </Box>
                )}
              </Box>
            </Stack>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleCloseDialog}>キャンセル</Button>
            <Button
              onClick={handleSubmit}
              variant="contained"
              sx={{
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              }}
            >
              {editingInvoice ? '更新' : '作成'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* File Preview Dialog */}
        <FilePreviewDialog
          open={previewDialogOpen}
          onClose={() => setPreviewDialogOpen(false)}
          files={previewFiles}
          currentIndex={previewIndex}
          onIndexChange={setPreviewIndex}
        />
      </motion.div>
    </Container>
  );
};

export default Invoices;
</file>

<file path="src/pages/Notifications.js">
import React, { useState, useEffect } from 'react';
import {
  Container,
  Grid,
  Typography,
  Box,
  Button,
  Chip,
  Stack,
  Avatar,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemSecondaryAction,
  IconButton,
  Alert,
  Badge,
  Tooltip,
  Divider,
} from '@mui/material';
import {
  Notifications as NotificationsIcon,
  NotificationsActive as NotificationsActiveIcon,
  Schedule as ScheduleIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
  CheckCircle as CheckCircleIcon,
  Delete as DeleteIcon,
  DeleteSweep as DeleteSweepIcon,
  MarkEmailRead as MarkEmailReadIcon,
  Refresh as RefreshIcon,
  Receipt as ReceiptIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent, GlassCardPresets } from '../components/common/GlassCard';
import notificationService from '../services/notificationService';

const Notifications = () => {
  const [notifications, setNotifications] = useState([]);
  const [stats, setStats] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  // Load notifications and stats
  const loadData = async () => {
    try {
      setLoading(true);
      const [notificationsResult, statsResult] = await Promise.all([
        notificationService.getAllNotifications(),
        notificationService.getNotificationStats()
      ]);

      if (notificationsResult.success) {
        setNotifications(notificationsResult.data);
      }
      if (statsResult.success) {
        setStats(statsResult.data);
      }
    } catch (error) {
      console.error('Failed to load data:', error);
      setError('データの読み込みに失敗しました。');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadData();
    // Check for new notifications
    notificationService.autoCheckNotifications().then(() => {
      loadData(); // Reload after checking
    });
  }, []);

  // Handle mark as read
  const handleMarkAsRead = async (notificationId) => {
    try {
      const result = await notificationService.markAsRead(notificationId);
      if (result.success) {
        await loadData();
      } else {
        setError(result.error);
      }
    } catch (error) {
      console.error('Error marking as read:', error);
      setError('既読処理に失敗しました。');
    }
  };

  // Handle mark all as read
  const handleMarkAllAsRead = async () => {
    try {
      const result = await notificationService.markAllAsRead();
      if (result.success) {
        await loadData();
      } else {
        setError(result.error);
      }
    } catch (error) {
      console.error('Error marking all as read:', error);
      setError('一括既読処理に失敗しました。');
    }
  };

  // Handle delete
  const handleDelete = async (notificationId) => {
    try {
      const result = await notificationService.deleteNotification(notificationId);
      if (result.success) {
        await loadData();
      } else {
        setError(result.error);
      }
    } catch (error) {
      console.error('Error deleting notification:', error);
      setError('削除に失敗しました。');
    }
  };

  // Handle clear all
  const handleClearAll = async () => {
    if (window.confirm('すべての通知を削除しますか？')) {
      try {
        const result = await notificationService.clearAllNotifications();
        if (result.success) {
          await loadData();
        } else {
          setError(result.error);
        }
      } catch (error) {
        console.error('Error clearing all notifications:', error);
        setError('一括削除に失敗しました。');
      }
    }
  };

  // Handle refresh
  const handleRefresh = async () => {
    await notificationService.autoCheckNotifications();
    await loadData();
  };

  // Get notification icon and color
  const getNotificationInfo = (notification) => {
    switch (notification.type) {
      case 'invoice_due_soon':
        return { icon: <ScheduleIcon />, color: 'warning', bgColor: 'warning.main' };
      case 'invoice_overdue':
        return { icon: <WarningIcon />, color: 'error', bgColor: 'error.main' };
      case 'expense_approved':
        return { icon: <CheckCircleIcon />, color: 'success', bgColor: 'success.main' };
      case 'expense_rejected':
        return { icon: <WarningIcon />, color: 'error', bgColor: 'error.main' };
      case 'system':
        return { icon: <InfoIcon />, color: 'info', bgColor: 'info.main' };
      default:
        return { icon: <NotificationsIcon />, color: 'default', bgColor: 'grey.500' };
    }
  };

  // Get priority color
  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'high':
        return 'error';
      case 'medium':
        return 'warning';
      case 'low':
        return 'info';
      default:
        return 'default';
    }
  };

  // Format time ago
  const formatTimeAgo = (dateString) => {
    const now = new Date();
    const date = new Date(dateString);
    const diffInMs = now - date;
    const diffInMinutes = Math.floor(diffInMs / (1000 * 60));
    const diffInHours = Math.floor(diffInMinutes / 60);
    const diffInDays = Math.floor(diffInHours / 24);

    if (diffInDays > 0) {
      return `${diffInDays}日前`;
    } else if (diffInHours > 0) {
      return `${diffInHours}時間前`;
    } else if (diffInMinutes > 0) {
      return `${diffInMinutes}分前`;
    } else {
      return 'たった今';
    }
  };

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  if (loading) {
    return (
      <Container maxWidth="xl">
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
          <Typography>読み込み中...</Typography>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* Header */}
        <motion.div variants={itemVariants}>
          <Typography
            variant="h3"
            gutterBottom
            sx={{
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 700,
              mb: 1,
            }}
          >
            通知センター
          </Typography>
          <Typography variant="subtitle1" color="text.secondary" sx={{ mb: 4 }}>
            請求書期日やシステム通知を管理
          </Typography>
        </motion.div>

        {/* Error Alert */}
        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError('')}>
            {error}
          </Alert>
        )}

        {/* Statistics Cards */}
        <motion.div variants={itemVariants}>
          <Grid container spacing={3} sx={{ mb: 4 }}>
            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.info}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'primary.main' }}>
                      <Badge badgeContent={stats.unread || 0} color="error">
                        <NotificationsIcon />
                      </Badge>
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.total || 0}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        総通知数
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.warning}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'warning.main' }}>
                      <NotificationsActiveIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.unread || 0}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        未読通知
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.error}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'error.main' }}>
                      <WarningIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.high || 0}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        重要度：高
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>

            <Grid item xs={12} sm={6} md={3}>
              <GlassCard {...GlassCardPresets.success}>
                <GlassCardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: 'info.main' }}>
                      <ReceiptIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.byType?.invoice_due_soon || 0}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        期日間近
                      </Typography>
                    </Box>
                  </Box>
                </GlassCardContent>
              </GlassCard>
            </Grid>
          </Grid>
        </motion.div>

        {/* Notification List */}
        <motion.div variants={itemVariants}>
          <GlassCard>
            <GlassCardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <NotificationsIcon />
                  通知一覧
                </Typography>
                <Stack direction="row" spacing={1}>
                  <Button
                    variant="outlined"
                    startIcon={<RefreshIcon />}
                    onClick={handleRefresh}
                    size="small"
                  >
                    更新
                  </Button>
                  {stats.unread > 0 && (
                    <Button
                      variant="outlined"
                      startIcon={<MarkEmailReadIcon />}
                      onClick={handleMarkAllAsRead}
                      size="small"
                    >
                      全て既読
                    </Button>
                  )}
                  {notifications.length > 0 && (
                    <Button
                      variant="outlined"
                      color="error"
                      startIcon={<DeleteSweepIcon />}
                      onClick={handleClearAll}
                      size="small"
                    >
                      全て削除
                    </Button>
                  )}
                </Stack>
              </Box>

              {notifications.length > 0 ? (
                <List>
                  {notifications.map((notification, index) => {
                    const notificationInfo = getNotificationInfo(notification);
                    return (
                      <React.Fragment key={notification.id}>
                        <ListItem
                          sx={{
                            backgroundColor: notification.isRead ? 'transparent' : 'action.hover',
                            borderRadius: 1,
                            mb: 1,
                            opacity: notification.isRead ? 0.7 : 1,
                          }}
                        >
                          <ListItemIcon>
                            <Avatar sx={{ bgcolor: notificationInfo.bgColor }}>
                              {notificationInfo.icon}
                            </Avatar>
                          </ListItemIcon>
                          <ListItemText
                            primary={
                              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                <Typography
                                  variant="subtitle1"
                                  fontWeight={notification.isRead ? 'normal' : 'bold'}
                                >
                                  {notification.title}
                                </Typography>
                                <Chip
                                  size="small"
                                  label={notification.priority}
                                  color={getPriorityColor(notification.priority)}
                                  variant="outlined"
                                />
                                {!notification.isRead && (
                                  <Chip
                                    size="small"
                                    label="新着"
                                    color="primary"
                                  />
                                )}
                              </Box>
                            }
                            secondary={
                              <Box>
                                <Typography variant="body2" color="text.secondary">
                                  {notification.message}
                                </Typography>
                                <Typography variant="caption" color="text.secondary">
                                  {formatTimeAgo(notification.createdAt)}
                                  {notification.readAt && (
                                    <> • 既読: {formatTimeAgo(notification.readAt)}</>
                                  )}
                                </Typography>
                              </Box>
                            }
                          />
                          <ListItemSecondaryAction>
                            <Stack direction="row" spacing={1}>
                              {!notification.isRead && (
                                <Tooltip title="既読にする">
                                  <IconButton
                                    color="primary"
                                    onClick={() => handleMarkAsRead(notification.id)}
                                    size="small"
                                  >
                                    <CheckCircleIcon />
                                  </IconButton>
                                </Tooltip>
                              )}
                              <Tooltip title="削除">
                                <IconButton
                                  color="error"
                                  onClick={() => handleDelete(notification.id)}
                                  size="small"
                                >
                                  <DeleteIcon />
                                </IconButton>
                              </Tooltip>
                            </Stack>
                          </ListItemSecondaryAction>
                        </ListItem>
                        {index < notifications.length - 1 && <Divider sx={{ my: 1 }} />}
                      </React.Fragment>
                    );
                  })}
                </List>
              ) : (
                <Box sx={{ textAlign: 'center', py: 4 }}>
                  <NotificationsIcon sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
                  <Typography variant="h6" color="text.secondary" gutterBottom>
                    通知がありません
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    新しい通知が届くとここに表示されます
                  </Typography>
                </Box>
              )}
            </GlassCardContent>
          </GlassCard>
        </motion.div>
      </motion.div>
    </Container>
  );
};

export default Notifications;
</file>

<file path="src/pages/Registration.js">
import React, { useState, useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import {
  Container,
  Grid,
  Typography,
  Box,
  Tabs,
  Tab,
  Card,
  CardContent,
  Stack,
  Avatar,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Button,
} from '@mui/material';
import {
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  Timeline as TimelineIcon,
  Receipt as ReceiptIcon,
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';
import GlassCard, { GlassCardContent, GlassCardPresets } from '../components/common/GlassCard';
import ExpenseForm from '../components/Registration/ExpenseForm';
import IncomeForm from '../components/Registration/IncomeForm';
import expenseService from '../services/expenseService';
import incomeService from '../services/incomeService';
import { formatDate } from '../utils/formatters';
import useSettings from '../hooks/useSettings';

const Registration = () => {
  const location = useLocation();
  const { settings } = useSettings();
  const [activeTab, setActiveTab] = useState(0);
  const [recentTransactions, setRecentTransactions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [monthlyStats, setMonthlyStats] = useState({
    totalExpenses: 0,
    totalIncome: 0,
    transactionCount: 0,
    netIncome: 0
  });

  // Load recent transactions and stats
  const loadData = async () => {
    try {
      setLoading(true);
      
      // Get current month data
      const now = new Date();
      const currentMonth = now.getMonth();
      const currentYear = now.getFullYear();
      const startOfMonth = new Date(currentYear, currentMonth, 1);
      const endOfMonth = new Date(currentYear, currentMonth + 1, 0);

      // Get recent expenses and income
      const expensesResult = await expenseService.getExpensesByDateRange(
        startOfMonth.toISOString(),
        endOfMonth.toISOString()
      );
      const incomeResult = await incomeService.getIncomeByDateRange(
        startOfMonth.toISOString(),
        endOfMonth.toISOString()
      );

      const expenses = expensesResult.success ? expensesResult.data : [];
      const income = incomeResult.success ? incomeResult.data : [];

      // Combine and sort recent transactions
      const allTransactions = [
        ...expenses.map(e => ({ ...e, type: 'expense' })),
        ...income.map(i => ({ ...i, type: 'income' }))
      ].sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, 5);

      setRecentTransactions(allTransactions);

      // Calculate stats
      const totalExpenses = expenses.reduce((sum, exp) => sum + exp.amount, 0);
      const totalIncome = income.reduce((sum, inc) => sum + inc.amount, 0);
      
      setMonthlyStats({
        totalExpenses,
        totalIncome,
        transactionCount: expenses.length + income.length,
        netIncome: totalIncome - totalExpenses
      });

    } catch (error) {
      console.error('Failed to load data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };

  const handleTransactionSubmit = async (transactionData) => {
    try {
      // Save to database
      if (transactionData.type === 'expense') {
        await expenseService.createExpense(transactionData);
      } else {
        await incomeService.createIncome(transactionData);
      }
      
      // Reload data to show the new transaction
      await loadData();
      
    } catch (error) {
      console.error('Failed to save transaction:', error);
    }
  };

  // Initialize data on component mount and handle URL parameters
  useEffect(() => {
    loadData();
    
    // Check for tab parameter in URL
    const urlParams = new URLSearchParams(location.search);
    const tabParam = urlParams.get('tab');
    if (tabParam === 'income') {
      setActiveTab(1);
    } else if (tabParam === 'expense') {
      setActiveTab(0);
    }
  }, [location.search]);

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('ja-JP', {
      style: 'currency',
      currency: 'JPY'
    }).format(amount);
  };

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  if (loading) {
    return (
      <Container maxWidth="xl">
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
          <Typography>読み込み中...</Typography>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* Header */}
        <motion.div variants={itemVariants}>
          <Typography
            variant="h3"
            gutterBottom
            sx={{
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 700,
              mb: 1,
            }}
          >
            収支登録
          </Typography>
          <Typography variant="subtitle1" color="text.secondary" sx={{ mb: 4 }}>
            AI機能付きの経費・収入管理システム
          </Typography>
        </motion.div>

        <Grid container spacing={3}>
          {/* Main Registration Form */}
          <Grid item xs={12} lg={8}>
            <motion.div variants={itemVariants}>
              <GlassCard>
                <GlassCardContent>
                  {/* Tab Navigation */}
                  <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
                    <Tabs
                      value={activeTab}
                      onChange={handleTabChange}
                      variant="fullWidth"
                      sx={{
                        '& .MuiTab-root': {
                          color: 'text.secondary',
                          '&.Mui-selected': {
                            color: 'text.primary',
                          },
                        },
                      }}
                    >
                      <Tab
                        icon={<TrendingDownIcon />}
                        label="支出登録"
                        iconPosition="start"
                      />
                      <Tab
                        icon={<TrendingUpIcon />}
                        label="収入登録"
                        iconPosition="start"
                      />
                    </Tabs>
                  </Box>

                  {/* Form Content */}
                  <AnimatePresence mode="wait">
                    <motion.div
                      key={activeTab}
                      initial={{ opacity: 0, x: 20 }}
                      animate={{ opacity: 1, x: 0 }}
                      exit={{ opacity: 0, x: -20 }}
                      transition={{ duration: 0.3 }}
                    >
                      {activeTab === 0 ? (
                        <ExpenseForm onSubmit={handleTransactionSubmit} />
                      ) : (
                        <IncomeForm onSubmit={handleTransactionSubmit} />
                      )}
                    </motion.div>
                  </AnimatePresence>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          {/* Sidebar */}
          <Grid item xs={12} lg={4}>
            <Stack spacing={3}>
              {/* Monthly Statistics */}
              <motion.div variants={itemVariants}>
                <GlassCard {...GlassCardPresets.info}>
                  <GlassCardContent>
                    <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <TimelineIcon />
                      今月の概要
                    </Typography>
                    <Grid container spacing={2}>
                      <Grid item xs={6}>
                        <Card>
                          <CardContent sx={{ textAlign: 'center', py: 2 }}>
                            <Avatar sx={{ bgcolor: 'error.main', mx: 'auto', mb: 1 }}>
                              <TrendingDownIcon />
                            </Avatar>
                            <Typography variant="h6" color="error.main" fontWeight="bold">
                              {formatCurrency(monthlyStats.totalExpenses)}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              総支出
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                      <Grid item xs={6}>
                        <Card>
                          <CardContent sx={{ textAlign: 'center', py: 2 }}>
                            <Avatar sx={{ bgcolor: 'success.main', mx: 'auto', mb: 1 }}>
                              <TrendingUpIcon />
                            </Avatar>
                            <Typography variant="h6" color="success.main" fontWeight="bold">
                              {formatCurrency(monthlyStats.totalIncome)}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              総収入
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                      <Grid item xs={6}>
                        <Card>
                          <CardContent sx={{ textAlign: 'center', py: 2 }}>
                            <Avatar sx={{ bgcolor: 'primary.main', mx: 'auto', mb: 1 }}>
                              <TimelineIcon />
                            </Avatar>
                            <Typography variant="h6" color="primary.main" fontWeight="bold">
                              {formatCurrency(monthlyStats.netIncome)}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              純利益
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                      <Grid item xs={6}>
                        <Card>
                          <CardContent sx={{ textAlign: 'center', py: 2 }}>
                            <Avatar sx={{ bgcolor: 'info.main', mx: 'auto', mb: 1 }}>
                              <ReceiptIcon />
                            </Avatar>
                            <Typography variant="h6" color="info.main" fontWeight="bold">
                              {monthlyStats.transactionCount}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              取引数
                            </Typography>
                          </CardContent>
                        </Card>
                      </Grid>
                    </Grid>
                  </GlassCardContent>
                </GlassCard>
              </motion.div>

              {/* Recent Transactions */}
              <motion.div variants={itemVariants}>
                <GlassCard>
                  <GlassCardContent>
                    <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <ReceiptIcon />
                      最近の取引
                    </Typography>
                    {recentTransactions.length > 0 ? (
                      <List dense>
                        {recentTransactions.map((transaction) => (
                          <ListItem key={transaction.id} sx={{ px: 0 }}>
                            <ListItemIcon>
                              <Avatar
                                sx={{
                                  bgcolor: transaction.type === 'expense' ? 'error.main' : 'success.main',
                                  width: 32,
                                  height: 32,
                                }}
                              >
                                {transaction.type === 'expense' ? <TrendingDownIcon /> : <TrendingUpIcon />}
                              </Avatar>
                            </ListItemIcon>
                            <ListItemText
                              primary={transaction.description}
                              secondary={
                                <React.Fragment>
                                  <Typography variant="caption" color="text.secondary" component="span">
                                    {formatDate(transaction.date, settings.dateFormat)}
                                  </Typography>
                                </React.Fragment>
                              }
                            />
                            <Typography
                              variant="body2"
                              color={transaction.type === 'expense' ? 'error.main' : 'success.main'}
                              fontWeight="bold"
                            >
                              {formatCurrency(transaction.amount)}
                            </Typography>
                          </ListItem>
                        ))}
                      </List>
                    ) : (
                      <Typography color="text.secondary" textAlign="center" py={2}>
                        取引データがありません
                      </Typography>
                    )}
                  </GlassCardContent>
                </GlassCard>
              </motion.div>

            </Stack>
          </Grid>
        </Grid>
      </motion.div>
    </Container>
  );
};

export default Registration;
</file>

<file path="src/pages/Settings.js">
import React, { useState, useCallback } from 'react';
import {
  Container,
  Grid,
  Typography,
  Box,
  Tabs,
  Tab,
  Alert,
  Snackbar,
  Button,
  Stack,
  TextField,
  InputAdornment,
  Chip,
  Backdrop,
  CircularProgress,
  Fab,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions
} from '@mui/material';
import {
  Palette as PaletteIcon,
  Category as CategoryIcon,
  VpnKey as ApiKeyIcon,
  Tune as GeneralIcon,
  Storage as StorageIcon,
  Search as SearchIcon,
  Save as SaveIcon,
  Undo as UndoIcon,
  RestartAlt as ResetIcon
} from '@mui/icons-material';
import { motion, AnimatePresence } from 'framer-motion';

// Import all settings components
import ThemeSettings from '../components/Settings/ThemeSettings';
import CategorySettings from '../components/Settings/CategorySettings';
import GeneralSettings from '../components/Settings/GeneralSettings';
import DataManagement from '../components/Settings/DataManagement';
import ApiSettings from '../components/Settings/ApiSettings';

// Import the settings hook
import useSettings from '../hooks/useSettings';

// Tab configuration
const settingsTabs = [
  {
    id: 'general',
    label: '一般',
    icon: <GeneralIcon />,
    description: '基本的なアプリケーション設定'
  },
  {
    id: 'theme',
    label: 'テーマ',
    icon: <PaletteIcon />,
    description: 'テーマとUI設定'
  },
  {
    id: 'categories',
    label: 'カテゴリ',
    icon: <CategoryIcon />,
    description: 'カテゴリ管理と設定'
  },
  {
    id: 'api',
    label: 'AI設定',
    icon: <ApiKeyIcon />,
    description: 'AI機能とAPI設定'
  },
  {
    id: 'data',
    label: 'データ',
    icon: <StorageIcon />,
    description: 'データ管理とバックアップ'
  }
];

const Settings = () => {
  const [activeTab, setActiveTab] = useState('general');
  const [searchQuery, setSearchQuery] = useState('');
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });
  
  // Use the settings hook
  const {
    settings,
    loading,
    error,
    hasChanges,
    pendingChanges,
    updateSetting,
    updateSettings,
    saveSettings,
    discardChanges,
    resetAllSettingsToDefaults,
    exportSettingsData,
    importSettingsData,
    isModified,
    testApiConnection
  } = useSettings();

  // Handle tab change
  const handleTabChange = useCallback((event, newValue) => {
    if (hasChanges && newValue !== activeTab) {
      setShowSaveDialog(true);
      return;
    }
    setActiveTab(newValue);
  }, [hasChanges, activeTab]);

  // Handle save settings
  const handleSaveSettings = useCallback(async () => {
    try {
      const result = await saveSettings();
      if (result.success) {
        setSnackbar({
          open: true,
          message: result.message,
          severity: 'success'
        });
      } else {
        setSnackbar({
          open: true,
          message: result.error || '保存に失敗しました',
          severity: 'error'
        });
      }
    } catch (err) {
      setSnackbar({
        open: true,
        message: '保存中にエラーが発生しました',
        severity: 'error'
      });
    }
  }, [saveSettings]);

  // Handle discard changes
  const handleDiscardChanges = useCallback(() => {
    discardChanges();
    setSnackbar({
      open: true,
      message: '変更を破棄しました',
      severity: 'info'
    });
  }, [discardChanges]);

  // Handle reset all settings
  const handleResetAllSettings = useCallback(async () => {
    try {
      const result = await resetAllSettingsToDefaults();
      if (result.success) {
        setSnackbar({
          open: true,
          message: result.message,
          severity: 'success'
        });
      } else {
        setSnackbar({
          open: true,
          message: result.error || 'リセットに失敗しました',
          severity: 'error'
        });
      }
    } catch (err) {
      setSnackbar({
        open: true,
        message: 'リセット中にエラーが発生しました',
        severity: 'error'
      });
    }
  }, [resetAllSettingsToDefaults]);

  // Filter tabs based on search
  const filteredTabs = settingsTabs.filter(tab =>
    !searchQuery || 
    tab.label.toLowerCase().includes(searchQuery.toLowerCase()) ||
    tab.description.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // Get current tab info
  const currentTab = settingsTabs.find(tab => tab.id === activeTab);

  // Render settings content based on active tab
  const renderSettingsContent = useCallback(() => {
    const commonProps = {
      settings,
      updateSetting,
      updateSettings,
      hasChanges,
      isModified,
      exportSettingsData,
      importSettingsData,
      saveSettings,
      testApiConnection
    };

    switch (activeTab) {
      case 'general':
        return <GeneralSettings {...commonProps} />;
      case 'theme':
        return <ThemeSettings {...commonProps} />;
      case 'categories':
        return <CategorySettings {...commonProps} />;
      case 'api':
        return <ApiSettings {...commonProps} />;
      case 'data':
        return <DataManagement {...commonProps} />;
      default:
        return <GeneralSettings {...commonProps} />;
    }
  }, [activeTab, settings, updateSetting, updateSettings, hasChanges, isModified, exportSettingsData, importSettingsData, saveSettings, testApiConnection]);

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
        delayChildren: 0.1
      }
    }
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1]
      }
    }
  };

  const tabContentVariants = {
    hidden: { opacity: 0, x: 20 },
    visible: {
      opacity: 1,
      x: 0,
      transition: {
        duration: 0.3,
        ease: [0.4, 0, 0.2, 1]
      }
    },
    exit: {
      opacity: 0,
      x: -20,
      transition: {
        duration: 0.2
      }
    }
  };

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* Header */}
        <motion.div variants={itemVariants}>
          <Box sx={{ 
            display: 'flex', 
            justifyContent: 'space-between', 
            alignItems: 'center',
            mb: 4,
            flexWrap: 'wrap',
            gap: 2
          }}>
            <Box>
              <Typography
                variant="h3"
                gutterBottom
                sx={{
                  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                  fontWeight: 700,
                  mb: 1
                }}
              >
                設定
              </Typography>
              <Typography variant="body1" color="text.secondary">
                {currentTab?.description || 'アプリケーションの設定を管理'}
              </Typography>
            </Box>

            {/* Search */}
            <TextField
              placeholder="設定を検索..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              size="small"
              sx={{ minWidth: 250 }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                )
              }}
            />
          </Box>
        </motion.div>

        {/* Error Alert */}
        {error && (
          <motion.div variants={itemVariants}>
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          </motion.div>
        )}

        {/* Changes Indicator */}
        <AnimatePresence>
          {hasChanges && (
            <motion.div
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              variants={itemVariants}
            >
              <Alert
                severity="info"
                sx={{ mb: 3 }}
                action={
                  <Stack direction="row" spacing={1}>
                    <Button
                      size="small"
                      onClick={handleDiscardChanges}
                      startIcon={<UndoIcon />}
                    >
                      破棄
                    </Button>
                    <Button
                      size="small"
                      variant="contained"
                      onClick={handleSaveSettings}
                      startIcon={<SaveIcon />}
                    >
                      保存
                    </Button>
                  </Stack>
                }
              >
                設定に未保存の変更があります
                {Object.keys(pendingChanges).length > 0 && (
                  <Box sx={{ mt: 1 }}>
                    {Object.keys(pendingChanges).map(key => (
                      <Chip key={key} label={key} size="small" sx={{ mr: 1 }} />
                    ))}
                  </Box>
                )}
              </Alert>
            </motion.div>
          )}
        </AnimatePresence>

        <Grid container spacing={3}>
          {/* Sidebar Navigation */}
          <Grid item xs={12} md={3}>
            <motion.div variants={itemVariants}>
              <Box
                sx={{
                  position: 'sticky',
                  top: 24,
                  background: 'rgba(255, 255, 255, 0.1)',
                  backdropFilter: 'blur(20px)',
                  borderRadius: 3,
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  overflow: 'hidden'
                }}
              >
                <Tabs
                  orientation="vertical"
                  value={activeTab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      alignItems: 'flex-start',
                      textAlign: 'left',
                      minHeight: 64,
                      px: 3,
                      py: 2,
                      transition: 'all 0.3s ease',
                      '&:hover': {
                        backgroundColor: 'rgba(255, 255, 255, 0.1)'
                      }
                    },
                    '& .MuiTab-selected': {
                      backgroundColor: 'rgba(102, 126, 234, 0.1)',
                      borderRight: '3px solid',
                      borderRightColor: 'primary.main'
                    }
                  }}
                >
                  {filteredTabs.map((tab) => (
                    <Tab
                      key={tab.id}
                      value={tab.id}
                      label={
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%' }}>
                          {tab.icon}
                          <Box sx={{ textAlign: 'left' }}>
                            <Typography variant="body1" fontWeight="bold">
                              {tab.label}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              {tab.description}
                            </Typography>
                          </Box>
                          {isModified(tab.id) && (
                            <Box
                              sx={{
                                width: 8,
                                height: 8,
                                borderRadius: '50%',
                                backgroundColor: 'primary.main',
                                ml: 'auto'
                              }}
                            />
                          )}
                        </Box>
                      }
                    />
                  ))}
                </Tabs>

                {/* Quick Actions */}
                <Box sx={{ p: 2, borderTop: '1px solid rgba(255, 255, 255, 0.1)' }}>
                  <Button
                    fullWidth
                    variant="outlined"
                    size="small"
                    startIcon={<ResetIcon />}
                    onClick={handleResetAllSettings}
                    color="warning"
                  >
                    すべてリセット
                  </Button>
                </Box>
              </Box>
            </motion.div>
          </Grid>

          {/* Main Content */}
          <Grid item xs={12} md={9}>
            <AnimatePresence mode="wait">
              <motion.div
                key={activeTab}
                variants={tabContentVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
              >
                {renderSettingsContent()}
              </motion.div>
            </AnimatePresence>
          </Grid>
        </Grid>

        {/* Floating Action Button for Save */}
        <AnimatePresence>
          {hasChanges && (
            <motion.div
              initial={{ opacity: 0, scale: 0 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0 }}
              style={{
                position: 'fixed',
                bottom: 24,
                right: 24,
                zIndex: 1000
              }}
            >
              <Fab
                color="primary"
                onClick={handleSaveSettings}
                sx={{
                  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  '&:hover': {
                    background: 'linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%)'
                  }
                }}
              >
                <SaveIcon />
              </Fab>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Loading Backdrop */}
        <Backdrop
          sx={{ color: '#fff', zIndex: (theme) => theme.zIndex.drawer + 1 }}
          open={loading}
        >
          <Box sx={{ textAlign: 'center' }}>
            <CircularProgress color="inherit" sx={{ mb: 2 }} />
            <Typography>設定を処理中...</Typography>
          </Box>
        </Backdrop>

        {/* Save Confirmation Dialog */}
        <Dialog open={showSaveDialog} onClose={() => setShowSaveDialog(false)}>
          <DialogTitle>未保存の変更があります</DialogTitle>
          <DialogContent>
            <Typography>
              現在のタブには未保存の変更があります。どうしますか？
            </Typography>
          </DialogContent>
          <DialogActions>
            <Button onClick={() => {
              setShowSaveDialog(false);
              discardChanges();
              setActiveTab(settingsTabs.find(tab => tab.id !== activeTab)?.id || 'general');
            }}>
              変更を破棄
            </Button>
            <Button onClick={handleSaveSettings} variant="contained">
              保存してから移動
            </Button>
            <Button onClick={() => setShowSaveDialog(false)}>
              キャンセル
            </Button>
          </DialogActions>
        </Dialog>

        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'left' }}
        >
          <Alert
            onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
            severity={snackbar.severity}
            variant="filled"
            sx={{ width: '100%' }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </motion.div>
    </Container>
  );
};

export default Settings;
</file>

<file path="src/pages/TransactionList.js">
import React, { useState, useEffect, useMemo } from 'react';
import {
  Container,
  Grid,
  Typography,
  Box,
  Card,
  CardContent,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  TextField,
  Button,
  Stack,
  Chip,
  IconButton,
  InputAdornment,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Avatar,
  Tooltip,
  Menu,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Snackbar,
} from '@mui/material';
import {
  Search as SearchIcon,
  FilterList as FilterIcon,
  TrendingUp as IncomeIcon,
  TrendingDown as ExpenseIcon,
  Receipt as ReceiptIcon,
  Download as ExportIcon,
  Refresh as RefreshIcon,
  Category as CategoryIcon,
  Person as PersonIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  MoreVert as MoreIcon,
  AttachFile as AttachFileIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { LocalizationProvider, DatePicker } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ja } from 'date-fns/locale';
import GlassCard, { GlassCardContent } from '../components/common/GlassCard';
import FilePreviewDialog from '../components/common/FilePreviewDialog';
import expenseService from '../services/expenseService';
import incomeService from '../services/incomeService';
import categoryService from '../services/categoryService';
import userService from '../services/userService';
import trashService from '../services/trashService';
import { formatDate } from '../utils/formatters';
import useSettings from '../hooks/useSettings';

const TransactionList = () => {
  const { settings } = useSettings();
  const [transactions, setTransactions] = useState([]);
  const [categories, setCategories] = useState([]);
  const [users, setUsers] = useState([]);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(25);
  
  // Filters
  const [searchQuery, setSearchQuery] = useState('');
  const [dateFrom, setDateFrom] = useState(null);
  const [dateTo, setDateTo] = useState(null);
  const [typeFilter, setTypeFilter] = useState('all');
  const [categoryFilter, setCategoryFilter] = useState('all');
  const [userFilter, setUserFilter] = useState('all');
  
  // Edit/Delete functionality
  const [menuAnchor, setMenuAnchor] = useState(null);
  const [selectedTransaction, setSelectedTransaction] = useState(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [deleteReason, setDeleteReason] = useState('');
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [editFormData, setEditFormData] = useState({});
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });
  const [filePreviewOpen, setFilePreviewOpen] = useState(false);
  const [previewFileIds, setPreviewFileIds] = useState([]);

  // Load data
  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      const [expensesResult, incomeResult, categoriesResult, usersResult] = await Promise.all([
        expenseService.getAllExpenses(),
        incomeService.getAllIncome(),
        categoryService.getAllCategories(),
        userService.getAllUsers()
      ]);

      const expenses = (expensesResult.success ? expensesResult.data : [])
        .map(item => ({ ...item, type: 'expense' }));
      const income = (incomeResult.success ? incomeResult.data : [])
        .map(item => ({ ...item, type: 'income' }));

      const allTransactions = [...expenses, ...income]
        .sort((a, b) => new Date(b.date) - new Date(a.date));

      setTransactions(allTransactions);
      setCategories(categoriesResult.success ? categoriesResult.data : []);
      setUsers(usersResult.success ? usersResult.data : []);
      
    } catch (error) {
      console.error('Failed to load data:', error);
    }
  };

  // Filter transactions
  const filteredTransactions = useMemo(() => {
    return transactions.filter(transaction => {
      // Search filter
      if (searchQuery && !transaction.description.toLowerCase().includes(searchQuery.toLowerCase())) {
        return false;
      }

      // Date filters
      if (dateFrom && new Date(transaction.date) < dateFrom) {
        return false;
      }
      if (dateTo && new Date(transaction.date) > dateTo) {
        return false;
      }

      // Type filter
      if (typeFilter !== 'all' && transaction.type !== typeFilter) {
        return false;
      }

      // Category filter
      if (categoryFilter !== 'all' && transaction.categoryId !== categoryFilter) {
        return false;
      }

      // User filter
      if (userFilter !== 'all' && transaction.userId !== userFilter) {
        return false;
      }

      return true;
    });
  }, [transactions, searchQuery, dateFrom, dateTo, typeFilter, categoryFilter, userFilter]);

  // Calculate totals
  const totals = useMemo(() => {
    const totalExpenses = filteredTransactions
      .filter(t => t.type === 'expense')
      .reduce((sum, t) => sum + t.amount, 0);
    
    const totalIncome = filteredTransactions
      .filter(t => t.type === 'income')
      .reduce((sum, t) => sum + t.amount, 0);

    return {
      expenses: totalExpenses,
      income: totalIncome,
      net: totalIncome - totalExpenses,
      count: filteredTransactions.length
    };
  }, [filteredTransactions]);

  // Pagination
  const paginatedTransactions = useMemo(() => {
    const start = page * rowsPerPage;
    return filteredTransactions.slice(start, start + rowsPerPage);
  }, [filteredTransactions, page, rowsPerPage]);

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('ja-JP', {
      style: 'currency',
      currency: 'JPY'
    }).format(amount);
  };

  const getCategoryName = (categoryId) => {
    const category = categories.find(c => c.id === categoryId);
    return category ? category.name : '不明';
  };

  const getUserName = (userId) => {
    const user = users.find(u => u.id === userId);
    return user ? user.name : '不明';
  };

  const resetFilters = () => {
    setSearchQuery('');
    setDateFrom(null);
    setDateTo(null);
    setTypeFilter('all');
    setCategoryFilter('all');
    setUserFilter('all');
    setPage(0);
  };

  const exportData = () => {
    const csvData = filteredTransactions.map(t => ({
      日付: formatDate(t.date, settings.dateFormat),
      種類: t.type === 'expense' ? '支出' : '収入',
      金額: t.amount,
      説明: t.description,
      カテゴリ: getCategoryName(t.categoryId),
      ユーザー: getUserName(t.userId),
      メモ: t.memo || ''
    }));

    const csvContent = [
      Object.keys(csvData[0]).join(','),
      ...csvData.map(row => Object.values(row).join(','))
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `transactions_${new Date().toISOString().split('T')[0]}.csv`;
    link.click();
  };

  // Menu handlers
  const handleMenuOpen = (event, transaction) => {
    setMenuAnchor(event.currentTarget);
    setSelectedTransaction(transaction);
  };

  const handleMenuClose = () => {
    setMenuAnchor(null);
    setSelectedTransaction(null);
  };

  // Edit handlers
  const handleEditClick = () => {
    setEditFormData({
      ...selectedTransaction,
      date: selectedTransaction.date.split('T')[0] // Format for date input
    });
    setEditDialogOpen(true);
    handleMenuClose();
  };

  const handleEditSave = async () => {
    try {
      const { type, id, ...updateData } = editFormData;
      
      let result;
      if (type === 'expense') {
        result = await expenseService.updateExpense(id, updateData);
      } else {
        result = await incomeService.updateIncome(id, updateData);
      }

      if (result.success) {
        setSnackbar({ open: true, message: '取引を更新しました', severity: 'success' });
        loadData(); // Reload data
        setEditDialogOpen(false);
      } else {
        setSnackbar({ open: true, message: result.error || '更新に失敗しました', severity: 'error' });
      }
    } catch (error) {
      setSnackbar({ open: true, message: '更新中にエラーが発生しました', severity: 'error' });
    }
  };

  // Delete handlers
  const handleDeleteClick = () => {
    setDeleteDialogOpen(true);
    handleMenuClose();
  };

  const handleDeleteConfirm = async () => {
    try {
      const result = await trashService.moveToTrash(
        selectedTransaction.type, 
        selectedTransaction.id, 
        deleteReason
      );

      if (result.success) {
        setSnackbar({ open: true, message: 'ゴミ箱に移動しました', severity: 'success' });
        loadData(); // Reload data
        setDeleteDialogOpen(false);
        setDeleteReason('');
      } else {
        setSnackbar({ open: true, message: result.error || '削除に失敗しました', severity: 'error' });
      }
    } catch (error) {
      setSnackbar({ open: true, message: '削除中にエラーが発生しました', severity: 'error' });
    }
  };

  const handleFilePreview = (fileIds) => {
    setPreviewFileIds(fileIds);
    setFilePreviewOpen(true);
  };

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: { staggerChildren: 0.1 }
    }
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.5 }
    }
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ja}>
      <Container maxWidth="xl">
        <motion.div
          variants={containerVariants}
          initial="hidden"
          animate="visible"
        >
          {/* Header */}
          <motion.div variants={itemVariants}>
            <Box sx={{ mb: 4 }}>
              <Typography
                variant="h3"
                gutterBottom
                sx={{
                  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                  fontWeight: 700,
                  mb: 1,
                }}
              >
                取引履歴
              </Typography>
              <Typography variant="subtitle1" color="text.secondary">
                期間とカテゴリで絞り込んで収支を一覧表示
              </Typography>
            </Box>
          </motion.div>

          <Grid container spacing={3}>
            {/* Filters */}
            <Grid item xs={12}>
              <motion.div variants={itemVariants}>
                <GlassCard>
                  <GlassCardContent>
                    <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <FilterIcon />
                      フィルター
                    </Typography>
                    
                    <Grid container spacing={2}>
                      {/* Search */}
                      <Grid item xs={12} md={3}>
                        <TextField
                          placeholder="説明で検索..."
                          value={searchQuery}
                          onChange={(e) => setSearchQuery(e.target.value)}
                          fullWidth
                          size="small"
                          InputProps={{
                            startAdornment: (
                              <InputAdornment position="start">
                                <SearchIcon />
                              </InputAdornment>
                            ),
                          }}
                        />
                      </Grid>

                      {/* Date From */}
                      <Grid item xs={12} md={2}>
                        <DatePicker
                          label="開始日"
                          value={dateFrom}
                          onChange={setDateFrom}
                          slotProps={{
                            textField: {
                              size: 'small',
                              fullWidth: true
                            }
                          }}
                        />
                      </Grid>

                      {/* Date To */}
                      <Grid item xs={12} md={2}>
                        <DatePicker
                          label="終了日"
                          value={dateTo}
                          onChange={setDateTo}
                          slotProps={{
                            textField: {
                              size: 'small',
                              fullWidth: true
                            }
                          }}
                        />
                      </Grid>

                      {/* Type Filter */}
                      <Grid item xs={12} md={2}>
                        <FormControl fullWidth size="small">
                          <InputLabel>種類</InputLabel>
                          <Select
                            value={typeFilter}
                            label="種類"
                            onChange={(e) => setTypeFilter(e.target.value)}
                          >
                            <MenuItem value="all">すべて</MenuItem>
                            <MenuItem value="expense">支出</MenuItem>
                            <MenuItem value="income">収入</MenuItem>
                          </Select>
                        </FormControl>
                      </Grid>

                      {/* Category Filter */}
                      <Grid item xs={12} md={2}>
                        <FormControl fullWidth size="small">
                          <InputLabel>カテゴリ</InputLabel>
                          <Select
                            value={categoryFilter}
                            label="カテゴリ"
                            onChange={(e) => setCategoryFilter(e.target.value)}
                          >
                            <MenuItem value="all">すべて</MenuItem>
                            {categories.map((category) => (
                              <MenuItem key={category.id} value={category.id}>
                                {category.name}
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>

                      {/* User Filter */}
                      <Grid item xs={12} md={1}>
                        <FormControl fullWidth size="small">
                          <InputLabel>ユーザー</InputLabel>
                          <Select
                            value={userFilter}
                            label="ユーザー"
                            onChange={(e) => setUserFilter(e.target.value)}
                          >
                            <MenuItem value="all">すべて</MenuItem>
                            {users.map((user) => (
                              <MenuItem key={user.id} value={user.id}>
                                {user.name}
                              </MenuItem>
                            ))}
                          </Select>
                        </FormControl>
                      </Grid>
                    </Grid>

                    <Stack direction="row" spacing={1} sx={{ mt: 2 }}>
                      <Button
                        variant="outlined"
                        size="small"
                        startIcon={<RefreshIcon />}
                        onClick={resetFilters}
                      >
                        リセット
                      </Button>
                      <Button
                        variant="outlined"
                        size="small"
                        startIcon={<ExportIcon />}
                        onClick={exportData}
                        disabled={filteredTransactions.length === 0}
                      >
                        エクスポート
                      </Button>
                    </Stack>
                  </GlassCardContent>
                </GlassCard>
              </motion.div>
            </Grid>

            {/* Summary */}
            <Grid item xs={12}>
              <motion.div variants={itemVariants}>
                <Grid container spacing={2}>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent sx={{ textAlign: 'center' }}>
                        <Avatar sx={{ bgcolor: 'error.main', mx: 'auto', mb: 1 }}>
                          <ExpenseIcon />
                        </Avatar>
                        <Typography variant="h6" color="error.main">
                          {formatCurrency(totals.expenses)}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          総支出
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent sx={{ textAlign: 'center' }}>
                        <Avatar sx={{ bgcolor: 'success.main', mx: 'auto', mb: 1 }}>
                          <IncomeIcon />
                        </Avatar>
                        <Typography variant="h6" color="success.main">
                          {formatCurrency(totals.income)}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          総収入
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent sx={{ textAlign: 'center' }}>
                        <Avatar sx={{ bgcolor: totals.net >= 0 ? 'success.main' : 'error.main', mx: 'auto', mb: 1 }}>
                          <ReceiptIcon />
                        </Avatar>
                        <Typography variant="h6" color={totals.net >= 0 ? 'success.main' : 'error.main'}>
                          {formatCurrency(totals.net)}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          純利益
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                  <Grid item xs={12} sm={6} md={3}>
                    <Card>
                      <CardContent sx={{ textAlign: 'center' }}>
                        <Avatar sx={{ bgcolor: 'info.main', mx: 'auto', mb: 1 }}>
                          <ReceiptIcon />
                        </Avatar>
                        <Typography variant="h6" color="info.main">
                          {totals.count}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          取引数
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                </Grid>
              </motion.div>
            </Grid>

            {/* Transaction Table */}
            <Grid item xs={12}>
              <motion.div variants={itemVariants}>
                <GlassCard>
                  <TableContainer>
                    <Table>
                      <TableHead>
                        <TableRow>
                          <TableCell>日付</TableCell>
                          <TableCell>種類</TableCell>
                          <TableCell>説明</TableCell>
                          <TableCell>カテゴリ</TableCell>
                          <TableCell>ユーザー</TableCell>
                          <TableCell align="right">金額</TableCell>
                          <TableCell>メモ</TableCell>
                          <TableCell align="center">ファイル</TableCell>
                          <TableCell align="center">操作</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {paginatedTransactions.map((transaction) => (
                          <TableRow key={`${transaction.type}-${transaction.id}`} hover>
                            <TableCell>
                              {formatDate(transaction.date, settings.dateFormat)}
                            </TableCell>
                            <TableCell>
                              <Chip
                                icon={transaction.type === 'expense' ? <ExpenseIcon /> : <IncomeIcon />}
                                label={transaction.type === 'expense' ? '支出' : '収入'}
                                color={transaction.type === 'expense' ? 'error' : 'success'}
                                variant="outlined"
                                size="small"
                              />
                            </TableCell>
                            <TableCell>{transaction.description}</TableCell>
                            <TableCell>
                              <Chip
                                icon={<CategoryIcon />}
                                label={getCategoryName(transaction.categoryId)}
                                size="small"
                                variant="outlined"
                              />
                            </TableCell>
                            <TableCell>
                              <Chip
                                icon={<PersonIcon />}
                                label={getUserName(transaction.userId)}
                                size="small"
                                variant="outlined"
                              />
                            </TableCell>
                            <TableCell align="right">
                              <Typography
                                variant="body2"
                                fontWeight="bold"
                                color={transaction.type === 'expense' ? 'error.main' : 'success.main'}
                              >
                                {formatCurrency(transaction.amount)}
                              </Typography>
                            </TableCell>
                            <TableCell>
                              {transaction.memo && (
                                <Tooltip title={transaction.memo}>
                                  <Typography variant="body2" noWrap sx={{ maxWidth: 150 }}>
                                    {transaction.memo}
                                  </Typography>
                                </Tooltip>
                              )}
                            </TableCell>
                            <TableCell align="center">
                              {transaction.fileIds && transaction.fileIds.length > 0 && (
                                <Tooltip title={`${transaction.fileIds.length}個のファイル`}>
                                  <Chip
                                    icon={<AttachFileIcon />}
                                    label={transaction.fileIds.length}
                                    size="small"
                                    variant="outlined"
                                    color="primary"
                                    onClick={() => handleFilePreview(transaction.fileIds)}
                                    sx={{ cursor: 'pointer' }}
                                  />
                                </Tooltip>
                              )}
                            </TableCell>
                            <TableCell align="center">
                              <IconButton
                                size="small"
                                onClick={(e) => handleMenuOpen(e, transaction)}
                              >
                                <MoreIcon />
                              </IconButton>
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>
                  
                  {filteredTransactions.length === 0 && (
                    <Box sx={{ textAlign: 'center', py: 4 }}>
                      <Typography color="text.secondary">
                        条件に一致する取引がありません
                      </Typography>
                    </Box>
                  )}

                  {filteredTransactions.length > 0 && (
                    <TablePagination
                      component="div"
                      count={filteredTransactions.length}
                      page={page}
                      onPageChange={(e, newPage) => setPage(newPage)}
                      rowsPerPage={rowsPerPage}
                      onRowsPerPageChange={(e) => {
                        setRowsPerPage(parseInt(e.target.value, 10));
                        setPage(0);
                      }}
                      rowsPerPageOptions={[10, 25, 50, 100]}
                      labelRowsPerPage="表示件数："
                      labelDisplayedRows={({ from, to, count }) => 
                        `${from}-${to} / ${count}`
                      }
                    />
                  )}
                </GlassCard>
              </motion.div>
            </Grid>
          </Grid>

          {/* Context Menu */}
          <Menu
            anchorEl={menuAnchor}
            open={Boolean(menuAnchor)}
            onClose={handleMenuClose}
          >
            <MenuItem onClick={handleEditClick}>
              <EditIcon sx={{ mr: 1 }} />
              編集
            </MenuItem>
            <MenuItem onClick={handleDeleteClick} sx={{ color: 'error.main' }}>
              <DeleteIcon sx={{ mr: 1 }} />
              削除
            </MenuItem>
          </Menu>

          {/* Edit Dialog */}
          <Dialog open={editDialogOpen} onClose={() => setEditDialogOpen(false)} maxWidth="sm" fullWidth>
            <DialogTitle>取引の編集</DialogTitle>
            <DialogContent>
              <Stack spacing={2} sx={{ mt: 1 }}>
                <TextField
                  label="日付"
                  type="date"
                  value={editFormData.date || ''}
                  onChange={(e) => setEditFormData(prev => ({ ...prev, date: e.target.value }))}
                  fullWidth
                  InputLabelProps={{ shrink: true }}
                />
                <TextField
                  label="金額"
                  type="number"
                  value={editFormData.amount || ''}
                  onChange={(e) => setEditFormData(prev => ({ ...prev, amount: parseFloat(e.target.value) }))}
                  fullWidth
                />
                <TextField
                  label="説明"
                  value={editFormData.description || ''}
                  onChange={(e) => setEditFormData(prev => ({ ...prev, description: e.target.value }))}
                  fullWidth
                  multiline
                  rows={2}
                />
                <FormControl fullWidth>
                  <InputLabel>カテゴリ</InputLabel>
                  <Select
                    value={editFormData.categoryId || ''}
                    label="カテゴリ"
                    onChange={(e) => setEditFormData(prev => ({ ...prev, categoryId: e.target.value }))}
                  >
                    {categories
                      .filter(cat => cat.type === editFormData.type)
                      .map((category) => (
                        <MenuItem key={category.id} value={category.id}>
                          {category.name}
                        </MenuItem>
                      ))}
                  </Select>
                </FormControl>
                <FormControl fullWidth>
                  <InputLabel>ユーザー</InputLabel>
                  <Select
                    value={editFormData.userId || ''}
                    label="ユーザー"
                    onChange={(e) => setEditFormData(prev => ({ ...prev, userId: e.target.value }))}
                  >
                    {users.map((user) => (
                      <MenuItem key={user.id} value={user.id}>
                        {user.name}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
                <TextField
                  label="メモ"
                  value={editFormData.memo || ''}
                  onChange={(e) => setEditFormData(prev => ({ ...prev, memo: e.target.value }))}
                  fullWidth
                  multiline
                  rows={2}
                />
              </Stack>
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setEditDialogOpen(false)}>キャンセル</Button>
              <Button onClick={handleEditSave} variant="contained">保存</Button>
            </DialogActions>
          </Dialog>

          {/* Delete Confirmation Dialog */}
          <Dialog open={deleteDialogOpen} onClose={() => setDeleteDialogOpen(false)} maxWidth="sm" fullWidth>
            <DialogTitle>取引の削除</DialogTitle>
            <DialogContent>
              <Typography gutterBottom>
                この取引をゴミ箱に移動しますか？後で復元することも可能です。
              </Typography>
              {selectedTransaction && (
                <Box sx={{ p: 2, bgcolor: 'grey.50', borderRadius: 1, mt: 2 }}>
                  <Typography variant="body2" color="text.secondary">
                    {formatDate(selectedTransaction.date, settings.dateFormat)} - {selectedTransaction.description}
                  </Typography>
                  <Typography variant="body2" fontWeight="bold">
                    {formatCurrency(selectedTransaction.amount)}
                  </Typography>
                </Box>
              )}
              <TextField
                label="削除理由（任意）"
                value={deleteReason}
                onChange={(e) => setDeleteReason(e.target.value)}
                fullWidth
                multiline
                rows={2}
                sx={{ mt: 2 }}
                placeholder="例：重複登録、誤入力など"
              />
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setDeleteDialogOpen(false)}>キャンセル</Button>
              <Button onClick={handleDeleteConfirm} variant="contained" color="error">
                ゴミ箱に移動
              </Button>
            </DialogActions>
          </Dialog>

          {/* Snackbar */}
          <Snackbar
            open={snackbar.open}
            autoHideDuration={6000}
            onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
            message={snackbar.message}
          />

          {/* File Preview Dialog */}
          <FilePreviewDialog
            open={filePreviewOpen}
            onClose={() => setFilePreviewOpen(false)}
            fileIds={previewFileIds}
          />
        </motion.div>
      </Container>
    </LocalizationProvider>
  );
};

export default TransactionList;
</file>

<file path="src/pages/TrashManagement.js">
import React, { useState, useEffect } from 'react';
import {
  Container,
  Typography,
  Box,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Button,
  Stack,
  Chip,
  IconButton,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Snackbar,
  Tooltip,
} from '@mui/material';
import {
  Delete as DeleteIcon,
  Restore as RestoreIcon,
  DeleteForever as PermanentDeleteIcon,
  CleaningServices as CleanIcon,
  TrendingUp as IncomeIcon,
  TrendingDown as ExpenseIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../components/common/GlassCard';
import trashService from '../services/trashService';
import categoryService from '../services/categoryService';
import userService from '../services/userService';
import { formatDate as formatDateUtil } from '../utils/formatters';
import useSettings from '../hooks/useSettings';

const TrashManagement = () => {
  const { settings } = useSettings();
  const [trashItems, setTrashItems] = useState([]);
  const [categories, setCategories] = useState([]);
  const [users, setUsers] = useState([]);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(25);
  const [confirmDialog, setConfirmDialog] = useState({ open: false, type: '', item: null });
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      const [trashResult, categoriesResult, usersResult] = await Promise.all([
        trashService.getAllTrash(),
        categoryService.getAllCategories(),
        userService.getAllUsers()
      ]);

      setTrashItems(trashResult.success ? trashResult.data : []);
      setCategories(categoriesResult.success ? categoriesResult.data : []);
      setUsers(usersResult.success ? usersResult.data : []);
      
    } catch (error) {
      console.error('Failed to load data:', error);
    }
  };

  const handleRestore = async (trashId) => {
    try {
      const result = await trashService.restoreFromTrash(trashId);
      if (result.success) {
        setSnackbar({ open: true, message: '取引を復元しました', severity: 'success' });
        loadData();
      } else {
        setSnackbar({ open: true, message: result.error || '復元に失敗しました', severity: 'error' });
      }
    } catch (error) {
      setSnackbar({ open: true, message: '復元中にエラーが発生しました', severity: 'error' });
    }
  };

  const handlePermanentDelete = async (trashId) => {
    try {
      const result = await trashService.permanentlyDelete(trashId);
      if (result.success) {
        setSnackbar({ open: true, message: '取引を完全削除しました', severity: 'success' });
        loadData();
      } else {
        setSnackbar({ open: true, message: result.error || '削除に失敗しました', severity: 'error' });
      }
    } catch (error) {
      setSnackbar({ open: true, message: '削除中にエラーが発生しました', severity: 'error' });
    }
  };

  const handleEmptyTrash = async () => {
    try {
      const result = await trashService.emptyTrash();
      if (result.success) {
        setSnackbar({ open: true, message: 'ゴミ箱を空にしました', severity: 'success' });
        loadData();
      } else {
        setSnackbar({ open: true, message: 'ゴミ箱の削除に失敗しました', severity: 'error' });
      }
    } catch (error) {
      setSnackbar({ open: true, message: '削除中にエラーが発生しました', severity: 'error' });
    }
  };

  const handleCleanupOld = async () => {
    try {
      const result = await trashService.cleanupOldTrash(30);
      if (result.success) {
        setSnackbar({ 
          open: true, 
          message: `${result.data.deletedCount}件の古いアイテムを削除しました`, 
          severity: 'success' 
        });
        loadData();
      } else {
        setSnackbar({ open: true, message: 'クリーンアップに失敗しました', severity: 'error' });
      }
    } catch (error) {
      setSnackbar({ open: true, message: 'クリーンアップ中にエラーが発生しました', severity: 'error' });
    }
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('ja-JP', {
      style: 'currency',
      currency: 'JPY'
    }).format(amount);
  };

  const getCategoryName = (categoryId) => {
    const category = categories.find(c => c.id === categoryId);
    return category ? category.name : '不明';
  };

  const getUserName = (userId) => {
    const user = users.find(u => u.id === userId);
    return user ? user.name : '不明';
  };

  const formatDate = (dateString) => {
    return formatDateUtil(dateString, settings.dateFormat);
  };

  const formatDateTime = (dateString) => {
    return new Date(dateString).toLocaleString('ja-JP');
  };

  const paginatedTrashItems = trashItems.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage);

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: { staggerChildren: 0.1 }
    }
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.5 }
    }
  };

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* Header */}
        <motion.div variants={itemVariants}>
          <Box sx={{ mb: 4 }}>
            <Typography
              variant="h3"
              gutterBottom
              sx={{
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                fontWeight: 700,
                mb: 1,
              }}
            >
              ゴミ箱
            </Typography>
            <Typography variant="subtitle1" color="text.secondary">
              削除した取引の管理と復元
            </Typography>
          </Box>
        </motion.div>

        {/* Actions */}
        <motion.div variants={itemVariants}>
          <Box sx={{ mb: 3 }}>
            <Stack direction="row" spacing={2}>
              <Button
                variant="outlined"
                startIcon={<CleanIcon />}
                onClick={() => setConfirmDialog({ open: true, type: 'cleanup', item: null })}
                disabled={trashItems.length === 0}
              >
                30日以上前を削除
              </Button>
              <Button
                variant="outlined"
                color="error"
                startIcon={<DeleteIcon />}
                onClick={() => setConfirmDialog({ open: true, type: 'empty', item: null })}
                disabled={trashItems.length === 0}
              >
                ゴミ箱を空にする
              </Button>
            </Stack>
          </Box>
        </motion.div>

        {/* Trash Items */}
        <motion.div variants={itemVariants}>
          <GlassCard>
            {trashItems.length === 0 ? (
              <GlassCardContent>
                <Box sx={{ textAlign: 'center', py: 8 }}>
                  <DeleteIcon sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
                  <Typography variant="h6" color="text.secondary" gutterBottom>
                    ゴミ箱は空です
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    削除した取引はここに表示されます
                  </Typography>
                </Box>
              </GlassCardContent>
            ) : (
              <>
                <TableContainer>
                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>削除日時</TableCell>
                        <TableCell>取引日</TableCell>
                        <TableCell>種類</TableCell>
                        <TableCell>説明</TableCell>
                        <TableCell>カテゴリ</TableCell>
                        <TableCell>ユーザー</TableCell>
                        <TableCell align="right">金額</TableCell>
                        <TableCell>削除理由</TableCell>
                        <TableCell align="center">操作</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {paginatedTrashItems.map((item) => (
                        <TableRow key={item.trashId} hover>
                          <TableCell>
                            <Typography variant="body2">
                              {formatDateTime(item.deletedAt)}
                            </Typography>
                          </TableCell>
                          <TableCell>
                            {formatDate(item.date)}
                          </TableCell>
                          <TableCell>
                            <Chip
                              icon={item.originalType === 'expense' ? <ExpenseIcon /> : <IncomeIcon />}
                              label={item.originalType === 'expense' ? '支出' : '収入'}
                              color={item.originalType === 'expense' ? 'error' : 'success'}
                              variant="outlined"
                              size="small"
                            />
                          </TableCell>
                          <TableCell>{item.description}</TableCell>
                          <TableCell>
                            <Chip
                              label={getCategoryName(item.categoryId)}
                              size="small"
                              variant="outlined"
                            />
                          </TableCell>
                          <TableCell>
                            <Chip
                              label={getUserName(item.userId)}
                              size="small"
                              variant="outlined"
                            />
                          </TableCell>
                          <TableCell align="right">
                            <Typography
                              variant="body2"
                              fontWeight="bold"
                              color={item.originalType === 'expense' ? 'error.main' : 'success.main'}
                            >
                              {formatCurrency(item.amount)}
                            </Typography>
                          </TableCell>
                          <TableCell>
                            {item.deletedReason && (
                              <Tooltip title={item.deletedReason}>
                                <Typography variant="body2" noWrap sx={{ maxWidth: 150 }}>
                                  {item.deletedReason}
                                </Typography>
                              </Tooltip>
                            )}
                          </TableCell>
                          <TableCell align="center">
                            <Stack direction="row" spacing={1} justifyContent="center">
                              <IconButton
                                size="small"
                                color="primary"
                                onClick={() => handleRestore(item.trashId)}
                                title="復元"
                              >
                                <RestoreIcon />
                              </IconButton>
                              <IconButton
                                size="small"
                                color="error"
                                onClick={() => setConfirmDialog({ 
                                  open: true, 
                                  type: 'permanent', 
                                  item: item 
                                })}
                                title="完全削除"
                              >
                                <PermanentDeleteIcon />
                              </IconButton>
                            </Stack>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>

                <TablePagination
                  component="div"
                  count={trashItems.length}
                  page={page}
                  onPageChange={(e, newPage) => setPage(newPage)}
                  rowsPerPage={rowsPerPage}
                  onRowsPerPageChange={(e) => {
                    setRowsPerPage(parseInt(e.target.value, 10));
                    setPage(0);
                  }}
                  rowsPerPageOptions={[10, 25, 50, 100]}
                  labelRowsPerPage="表示件数："
                  labelDisplayedRows={({ from, to, count }) => 
                    `${from}-${to} / ${count}`
                  }
                />
              </>
            )}
          </GlassCard>
        </motion.div>

        {/* Confirmation Dialog */}
        <Dialog 
          open={confirmDialog.open} 
          onClose={() => setConfirmDialog({ open: false, type: '', item: null })}
          maxWidth="sm" 
          fullWidth
        >
          <DialogTitle>
            {confirmDialog.type === 'permanent' && '完全削除の確認'}
            {confirmDialog.type === 'empty' && 'ゴミ箱を空にする'}
            {confirmDialog.type === 'cleanup' && '古いアイテムの削除'}
          </DialogTitle>
          <DialogContent>
            {confirmDialog.type === 'permanent' && (
              <>
                <Alert severity="warning" sx={{ mb: 2 }}>
                  この操作は元に戻せません。取引は完全に削除されます。
                </Alert>
                {confirmDialog.item && (
                  <Box sx={{ p: 2, bgcolor: 'grey.50', borderRadius: 1 }}>
                    <Typography variant="body2" color="text.secondary">
                      {formatDate(confirmDialog.item.date)} - {confirmDialog.item.description}
                    </Typography>
                    <Typography variant="body2" fontWeight="bold">
                      {formatCurrency(confirmDialog.item.amount)}
                    </Typography>
                  </Box>
                )}
              </>
            )}
            {confirmDialog.type === 'empty' && (
              <Alert severity="warning">
                ゴミ箱のすべてのアイテムが完全に削除されます。この操作は元に戻せません。
              </Alert>
            )}
            {confirmDialog.type === 'cleanup' && (
              <Typography>
                30日以上前に削除されたアイテムを完全削除します。この操作は元に戻せません。
              </Typography>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setConfirmDialog({ open: false, type: '', item: null })}>
              キャンセル
            </Button>
            <Button 
              onClick={() => {
                if (confirmDialog.type === 'permanent') {
                  handlePermanentDelete(confirmDialog.item.trashId);
                } else if (confirmDialog.type === 'empty') {
                  handleEmptyTrash();
                } else if (confirmDialog.type === 'cleanup') {
                  handleCleanupOld();
                }
                setConfirmDialog({ open: false, type: '', item: null });
              }}
              variant="contained" 
              color="error"
            >
              削除実行
            </Button>
          </DialogActions>
        </Dialog>

        {/* Snackbar */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={() => setSnackbar(prev => ({ ...prev, open: false }))}
          message={snackbar.message}
        />
      </motion.div>
    </Container>
  );
};

export default TrashManagement;
</file>

<file path="src/pages/Users.js">
import React, { useState, useEffect } from 'react';
import {
  Container,
  Grid,
  Typography,
  Box,
  Stack,
  Avatar,
  Alert,
  Snackbar,
  Backdrop,
  CircularProgress,
} from '@mui/material';
import {
  People as PeopleIcon,
  PersonAdd as PersonAddIcon,
  Star as StarIcon,
  Receipt as ReceiptIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import GlassCard, { GlassCardContent } from '../components/common/GlassCard';
import UserList from '../components/UserManagement/UserList';
import UserDialog from '../components/UserManagement/UserDialog';
import useUsers from '../hooks/useUsers';

const Users = () => {
  // Custom hook for user management
  const {
    users,
    loading,
    error,
    stats,
    starredUsers,
    usersByDepartment,
    usersByRole,
    addUser,
    updateUser,
    removeUser,
    toggleUserActive,
    toggleUserStarred,
    performBulkAction,
    exportUsers,
    refreshData,
    clearError,
  } = useUsers();

  // Local state for UI
  const [dialogState, setDialogState] = useState({
    open: false,
    mode: 'view', // 'view', 'create', 'edit', 'delete'
    user: null,
  });
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success',
  });

  // Handle dialog operations
  const openDialog = (mode, user = null) => {
    setDialogState({ open: true, mode, user });
  };

  const closeDialog = () => {
    setDialogState({ open: false, mode: 'view', user: null });
  };

  // Handle user operations
  const handleAddUser = () => {
    openDialog('create');
  };

  const handleEditUser = (user) => {
    openDialog('edit', user);
  };

  const handleViewUser = (user) => {
    openDialog('view', user);
  };

  const handleDeleteUser = (userId) => {
    const user = users.find(u => u.id === userId);
    openDialog('delete', user);
  };

  // Handle dialog save operations
  const handleDialogSave = async (formData) => {
    try {
      if (dialogState.mode === 'create') {
        await addUser(formData);
        showSnackbar('ユーザーが正常に追加されました', 'success');
      } else if (dialogState.mode === 'edit') {
        await updateUser(dialogState.user.id, formData);
        showSnackbar('ユーザー情報が正常に更新されました', 'success');
      }
      closeDialog();
    } catch (error) {
      showSnackbar(error.message || '操作に失敗しました', 'error');
    }
  };

  // Handle dialog delete operation
  const handleDialogDelete = async (userId) => {
    try {
      await removeUser(userId);
      showSnackbar('ユーザーが正常に削除されました', 'success');
      closeDialog();
    } catch (error) {
      showSnackbar(error.message || '削除に失敗しました', 'error');
    }
  };

  // Handle toggle operations
  const handleToggleStarred = async (userId) => {
    try {
      await toggleUserStarred(userId);
      const user = users.find(u => u.id === userId);
      const message = user?.isStarred 
        ? 'お気に入りから削除しました' 
        : 'お気に入りに追加しました';
      showSnackbar(message, 'info');
    } catch (error) {
      showSnackbar('操作に失敗しました', 'error');
    }
  };

  const handleToggleActive = async (userId) => {
    try {
      await toggleUserActive(userId);
      const user = users.find(u => u.id === userId);
      const message = user?.isActive 
        ? 'ユーザーを非アクティブ化しました' 
        : 'ユーザーをアクティブ化しました';
      showSnackbar(message, 'info');
    } catch (error) {
      showSnackbar('操作に失敗しました', 'error');
    }
  };

  // Handle bulk operations
  const handleBulkAction = async (action, userIds) => {
    try {
      await performBulkAction(action, userIds);
      let message = '';
      switch (action) {
        case 'activate':
          message = `${userIds.length}人のユーザーをアクティブ化しました`;
          break;
        case 'deactivate':
          message = `${userIds.length}人のユーザーを非アクティブ化しました`;
          break;
        case 'delete':
          message = `${userIds.length}人のユーザーを削除しました`;
          break;
        case 'export':
          const selectedUsers = users.filter(u => userIds.includes(u.id));
          exportUsers(selectedUsers);
          message = `${userIds.length}人のユーザーをエクスポートしました`;
          break;
        default:
          message = '一括操作が完了しました';
      }
      showSnackbar(message, 'success');
    } catch (error) {
      showSnackbar('一括操作に失敗しました', 'error');
    }
  };

  // Handle export
  const handleExport = () => {
    try {
      exportUsers();
      showSnackbar('ユーザーデータをエクスポートしました', 'success');
    } catch (error) {
      showSnackbar('エクスポートに失敗しました', 'error');
    }
  };

  // Show snackbar
  const showSnackbar = (message, severity = 'success') => {
    setSnackbar({ open: true, message, severity });
  };

  const closeSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };

  // Clear error when component unmounts or error changes
  useEffect(() => {
    if (error) {
      showSnackbar(error, 'error');
      clearError();
    }
  }, [error, clearError]);

  // Calculate financial summary
  const totalExpenses = users.reduce((sum, user) => sum + (user.totalExpenses || 0), 0);
  const totalIncome = users.reduce((sum, user) => sum + (user.totalIncome || 0), 0);
  const totalTransactions = users.reduce((sum, user) => sum + (user.transactionCount || 0), 0);

  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.5,
        ease: [0.4, 0, 0.2, 1],
      },
    },
  };

  return (
    <Container maxWidth="xl">
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {/* Page Header */}
        <motion.div variants={itemVariants}>
          <Typography
            variant="h3"
            gutterBottom
            sx={{
              background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 700,
              mb: 4,
            }}
          >
            ユーザー管理
          </Typography>
        </motion.div>

        {/* Statistics Cards */}
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard hover>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" spacing={2}>
                    <Avatar sx={{ bgcolor: 'primary.main', width: 56, height: 56 }}>
                      <PeopleIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.total}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        総ユーザー数
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard hover>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" spacing={2}>
                    <Avatar sx={{ bgcolor: 'success.main', width: 56, height: 56 }}>
                      <PersonAddIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {stats.active}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        アクティブユーザー
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard hover>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" spacing={2}>
                    <Avatar sx={{ bgcolor: 'warning.main', width: 56, height: 56 }}>
                      <StarIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {starredUsers.length}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        お気に入り
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <motion.div variants={itemVariants}>
              <GlassCard hover>
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" spacing={2}>
                    <Avatar sx={{ bgcolor: 'info.main', width: 56, height: 56 }}>
                      <ReceiptIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold">
                        {totalTransactions.toLocaleString()}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        総取引数
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        </Grid>

        {/* Financial Summary */}
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid item xs={12} md={6}>
            <motion.div variants={itemVariants}>
              <GlassCard
                gradient="linear-gradient(135deg, #11998e 0%, #38ef7d 100%)"
                hover
              >
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" spacing={2}>
                    <Avatar sx={{ bgcolor: 'success.main', width: 56, height: 56 }}>
                      <TrendingUpIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold" color="success.main">
                        ¥{totalIncome.toLocaleString()}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        全ユーザー総収入
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} md={6}>
            <motion.div variants={itemVariants}>
              <GlassCard
                gradient="linear-gradient(135deg, #fa709a 0%, #fee140 100%)"
                hover
              >
                <GlassCardContent>
                  <Stack direction="row" alignItems="center" spacing={2}>
                    <Avatar sx={{ bgcolor: 'error.main', width: 56, height: 56 }}>
                      <TrendingDownIcon />
                    </Avatar>
                    <Box>
                      <Typography variant="h4" fontWeight="bold" color="error.main">
                        ¥{totalExpenses.toLocaleString()}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        全ユーザー総支出
                      </Typography>
                    </Box>
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        </Grid>

        {/* Department and Role Summary */}
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid item xs={12} md={6}>
            <motion.div variants={itemVariants}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h6" gutterBottom>
                    部署別分布
                  </Typography>
                  <Stack spacing={1}>
                    {Object.entries(usersByDepartment)
                      .sort((a, b) => b[1].length - a[1].length)
                      .slice(0, 5)
                      .map(([dept, deptUsers], index) => {
                        const percentage = users.length > 0 ? ((deptUsers.length / users.length) * 100).toFixed(1) : 0;
                        return (
                          <Box key={dept} sx={{ display: 'flex', justifyContent: 'space-between' }}>
                            <Typography variant="body2">{dept}</Typography>
                            <Typography variant="body2" color="text.secondary">
                              {deptUsers.length}人 ({percentage}%)
                            </Typography>
                          </Box>
                        );
                      })}
                    {Object.keys(usersByDepartment).length > 5 && (
                      <Typography variant="caption" color="text.secondary">
                        他 {Object.keys(usersByDepartment).length - 5} 部署
                      </Typography>
                    )}
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>

          <Grid item xs={12} md={6}>
            <motion.div variants={itemVariants}>
              <GlassCard>
                <GlassCardContent>
                  <Typography variant="h6" gutterBottom>
                    役割別分布
                  </Typography>
                  <Stack spacing={1}>
                    {Object.entries(usersByRole)
                      .sort((a, b) => b[1].length - a[1].length)
                      .slice(0, 5)
                      .map(([role, roleUsers], index) => {
                        const percentage = users.length > 0 ? ((roleUsers.length / users.length) * 100).toFixed(1) : 0;
                        return (
                          <Box key={role} sx={{ display: 'flex', justifyContent: 'space-between' }}>
                            <Typography variant="body2">{role}</Typography>
                            <Typography variant="body2" color="text.secondary">
                              {roleUsers.length}人 ({percentage}%)
                            </Typography>
                          </Box>
                        );
                      })}
                    {Object.keys(usersByRole).length > 5 && (
                      <Typography variant="caption" color="text.secondary">
                        他 {Object.keys(usersByRole).length - 5} 役割
                      </Typography>
                    )}
                  </Stack>
                </GlassCardContent>
              </GlassCard>
            </motion.div>
          </Grid>
        </Grid>

        {/* User List */}
        <motion.div variants={itemVariants}>
          <UserList
            users={users}
            loading={loading}
            onEdit={handleEditUser}
            onDelete={handleDeleteUser}
            onView={handleViewUser}
            onAdd={handleAddUser}
            onToggleStarred={handleToggleStarred}
            onToggleActive={handleToggleActive}
            onBulkAction={handleBulkAction}
            onRefresh={refreshData}
            onExport={handleExport}
          />
        </motion.div>

        {/* User Dialog */}
        <UserDialog
          open={dialogState.open}
          user={dialogState.user}
          mode={dialogState.mode}
          onClose={closeDialog}
          onSave={handleDialogSave}
          onDelete={handleDialogDelete}
          onEdit={handleEditUser}
          onToggleStarred={handleToggleStarred}
          onToggleActive={handleToggleActive}
          loading={loading}
        />

        {/* Loading Backdrop */}
        <Backdrop
          sx={{ color: '#fff', zIndex: (theme) => theme.zIndex.drawer + 1 }}
          open={loading}
        >
          <CircularProgress color="inherit" />
        </Backdrop>

        {/* Snackbar for notifications */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={closeSnackbar}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        >
          <Alert
            onClose={closeSnackbar}
            severity={snackbar.severity}
            variant="filled"
            sx={{ width: '100%' }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </motion.div>
    </Container>
  );
};

export default Users;
</file>

<file path="src/services/aiService.js">
import storage from './storage';

/**
 * AI Service for expense management with category suggestions
 * Provides AI-powered features like category recommendation and expense analysis
 */
class AIService {
  constructor() {
    this.apiKey = this.getApiKey();
    this.apiEndpoint = 'https://api.openai.com/v1/chat/completions';
    this.requestTimeout = 30000;
    this.maxRetries = 3;
  }

  /**
   * Get API key from settings
   */
  getApiKey() {
    try {
      const settings = storage.get('settings') || {};
      return settings.openaiApiKey || '';
    } catch (error) {
      console.error('Failed to get API key from settings:', error);
      return '';
    }
  }

  /**
   * Update API settings
   */
  updateSettings(apiKey, endpoint = null) {
    this.apiKey = apiKey;
    if (endpoint) {
      this.apiEndpoint = endpoint;
    }
  }

  /**
   * Test API connection
   */
  async testConnection() {
    if (!this.apiKey) {
      return { success: false, error: 'APIキーが設定されていません' };
    }

    try {
      const response = await fetch(`${this.apiEndpoint.replace('/chat/completions', '')}/models`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        signal: AbortSignal.timeout(this.requestTimeout)
      });

      if (response.ok) {
        return { success: true, message: 'API接続に成功しました' };
      } else {
        return { success: false, error: `API接続に失敗しました: ${response.status}` };
      }
    } catch (error) {
      return { success: false, error: `API接続エラー: ${error.message}` };
    }
  }

  /**
   * Make API request with retry logic
   */
  async makeApiRequest(messages, retryCount = 0) {
    if (!this.apiKey) {
      throw new Error('APIキーが設定されていません');
    }

    try {
      const response = await fetch(this.apiEndpoint, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: messages,
          max_tokens: 150,
          temperature: 0.3
        }),
        signal: AbortSignal.timeout(this.requestTimeout)
      });

      if (!response.ok) {
        if (response.status === 429 && retryCount < this.maxRetries) {
          // Rate limit exceeded, retry with exponential backoff
          const delay = Math.pow(2, retryCount) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
          return this.makeApiRequest(messages, retryCount + 1);
        }
        
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`API Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
      }

      const data = await response.json();
      return data.choices[0]?.message?.content || '';
    } catch (error) {
      if (retryCount < this.maxRetries && error.name !== 'AbortError') {
        const delay = Math.pow(2, retryCount) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.makeApiRequest(messages, retryCount + 1);
      }
      throw error;
    }
  }

  /**
   * Suggest category based on description
   */
  async suggestCategory(description, type = 'expense') {
    try {
      // Get existing categories for context
      const categories = storage.get('categories') || [];
      const relevantCategories = categories
        .filter(cat => cat.type === type && cat.isActive !== false)
        .map(cat => cat.name)
        .slice(0, 10); // Limit to avoid token limits

      const messages = [
        {
          role: 'system',
          content: `あなたは日本の経費管理システムのAIアシスタントです。ユーザーが入力した${type === 'expense' ? '支出' : '収入'}の説明に基づいて、最適なカテゴリを提案してください。
          
現在利用可能なカテゴリ: ${relevantCategories.length > 0 ? relevantCategories.join(', ') : 'なし'}

回答は以下の形式で行ってください：
- 推奨カテゴリ: [カテゴリ名]
- 理由: [簡潔な説明]
- 税務上の注意点: [該当する場合のみ]

既存のカテゴリから選択することを優先しますが、適切なものがない場合は新しいカテゴリを提案してください。`
        },
        {
          role: 'user',
          content: `${type === 'expense' ? '支出' : '収入'}の説明: "${description}"`
        }
      ];

      const response = await this.makeApiRequest(messages);
      return {
        success: true,
        suggestion: response,
        availableCategories: relevantCategories
      };

    } catch (error) {
      console.error('Category suggestion failed:', error);
      return {
        success: false,
        error: error.message,
        suggestion: null
      };
    }
  }

  /**
   * Analyze expense for tax deduction eligibility
   */
  async analyzeExpenseDeduction(description, amount, category) {
    try {
      const messages = [
        {
          role: 'system',
          content: `あなたは日本の税務に詳しいAIアシスタントです。入力された経費について、税務上の扱いや経費として計上できるかどうかを分析してください。

回答は以下の形式で行ってください：
- 経費計上の可否: [可能/不可能/条件付き可能]
- 勘定科目: [推奨される勘定科目]
- 注意点: [税務上の注意点]
- 必要書類: [保管すべき書類]

一般的な税務知識に基づいて回答し、具体的な税務相談は税理士に確認するよう促してください。`
        },
        {
          role: 'user',
          content: `経費の詳細:
- 説明: ${description}
- 金額: ${amount}円
- カテゴリ: ${category}

この経費の税務上の扱いについて分析してください。`
        }
      ];

      const response = await this.makeApiRequest(messages);
      return {
        success: true,
        analysis: response
      };

    } catch (error) {
      console.error('Expense analysis failed:', error);
      return {
        success: false,
        error: error.message,
        analysis: null
      };
    }
  }

  /**
   * Generate monthly expense insights
   */
  async generateMonthlyInsights(expenseData, incomeData) {
    try {
      // Summarize data for AI analysis
      const totalExpenses = expenseData.reduce((sum, exp) => sum + exp.amount, 0);
      const totalIncome = incomeData.reduce((sum, inc) => sum + inc.amount, 0);
      
      const expensesByCategory = {};
      expenseData.forEach(exp => {
        const category = exp.categoryName || 'その他';
        expensesByCategory[category] = (expensesByCategory[category] || 0) + exp.amount;
      });

      const topCategories = Object.entries(expensesByCategory)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const messages = [
        {
          role: 'system',
          content: `あなたは財務分析の専門家です。提供された月次の収支データを分析し、実用的なアドバイスを提供してください。

回答は以下の形式で行ってください：
- 収支の概要: [総収入、総支出、純利益/損失]
- 支出の傾向: [主要な支出カテゴリの分析]
- 改善提案: [具体的な節約や効率化の提案]
- 注意点: [注意すべき支出パターンや異常値]

日本の税務や会計基準を考慮したアドバイスを提供してください。`
        },
        {
          role: 'user',
          content: `今月の収支データ:
- 総収入: ${totalIncome.toLocaleString()}円
- 総支出: ${totalExpenses.toLocaleString()}円
- 純利益: ${(totalIncome - totalExpenses).toLocaleString()}円

主要支出カテゴリ:
${topCategories.map(([category, amount]) => `- ${category}: ${amount.toLocaleString()}円`).join('\n')}

取引件数: 支出${expenseData.length}件、収入${incomeData.length}件

この収支状況について分析とアドバイスをお願いします。`
        }
      ];

      const response = await this.makeApiRequest(messages);
      return {
        success: true,
        insights: response
      };

    } catch (error) {
      console.error('Monthly insights generation failed:', error);
      return {
        success: false,
        error: error.message,
        insights: null
      };
    }
  }

  /**
   * Learn from user's category selection (for future improvements)
   */
  learnFromSelection(description, selectedCategory, type) {
    try {
      // Store learning data for future improvements
      const learningData = storage.get('ai_learning') || [];
      const newEntry = {
        description: description.toLowerCase(),
        category: selectedCategory,
        type,
        timestamp: new Date().toISOString()
      };

      // Keep only recent 1000 entries to manage storage
      learningData.push(newEntry);
      if (learningData.length > 1000) {
        learningData.splice(0, learningData.length - 1000);
      }

      storage.set('ai_learning', learningData);
      return { success: true };

    } catch (error) {
      console.error('Failed to store learning data:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get category suggestions based on learned patterns
   */
  getLocalCategorySuggestion(description, type = 'expense') {
    try {
      const learningData = storage.get('ai_learning') || [];
      const categories = storage.get('categories') || [];
      
      // Find similar descriptions
      const descLower = description.toLowerCase();
      const matches = learningData
        .filter(entry => entry.type === type)
        .filter(entry => {
          const entryDesc = entry.description;
          return entryDesc.includes(descLower) || descLower.includes(entryDesc);
        })
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

      if (matches.length > 0) {
        // Return most recent matching category
        const suggestedCategoryName = matches[0].category;
        const category = categories.find(cat => cat.name === suggestedCategoryName);
        
        if (category) {
          return {
            success: true,
            category: category,
            confidence: matches.length > 1 ? 'high' : 'medium',
            source: 'local_learning'
          };
        }
      }

      return { success: false, message: '学習データから適切なカテゴリが見つかりませんでした' };

    } catch (error) {
      console.error('Local category suggestion failed:', error);
      return { success: false, error: error.message };
    }
  }
}

// Create singleton instance
const aiService = new AIService();

// Export individual functions for backward compatibility
export const suggestCategory = (description, type) => aiService.suggestCategory(description, type);
export const analyzeExpenseDeduction = (description, amount, category) => aiService.analyzeExpenseDeduction(description, amount, category);
export const generateMonthlyInsights = (expenseData, incomeData) => aiService.generateMonthlyInsights(expenseData, incomeData);
export const learnFromSelection = (description, selectedCategory, type) => aiService.learnFromSelection(description, selectedCategory, type);
export const getLocalCategorySuggestion = (description, type) => aiService.getLocalCategorySuggestion(description, type);
export const testApiConnection = () => aiService.testConnection();
export const updateApiSettings = (apiKey, endpoint) => aiService.updateSettings(apiKey, endpoint);

export default aiService;
</file>

<file path="src/services/categoryService.js">
import storage from './storage';

/**
 * Category Service - Handles all category-related operations
 */

// Create a new category
export const createCategory = async (categoryData) => {
  try {
    const newCategory = storage.addItem('categories', categoryData);
    return { success: true, data: newCategory };
  } catch (error) {
    console.error('Error creating category:', error);
    return { success: false, error: error.message };
  }
};

// Get category by ID
export const getCategoryById = async (id) => {
  try {
    const category = storage.findById('categories', id);
    return { success: true, data: category };
  } catch (error) {
    console.error('Error getting category:', error);
    return { success: false, error: error.message };
  }
};

// Get all categories
export const getAllCategories = async () => {
  try {
    const categories = storage.get('categories') || [];
    return { success: true, data: categories };
  } catch (error) {
    console.error('Error getting categories:', error);
    return { success: false, error: error.message };
  }
};

// Get categories by type
export const getCategoriesByType = async (type) => {
  try {
    const categories = storage.findWhere('categories', { type, isActive: true });
    return { success: true, data: categories };
  } catch (error) {
    console.error('Error getting categories by type:', error);
    return { success: false, error: error.message };
  }
};

// Update category
export const updateCategory = async (id, updates) => {
  try {
    const updatedCategory = storage.updateItem('categories', id, updates);
    return { success: true, data: updatedCategory };
  } catch (error) {
    console.error('Error updating category:', error);
    return { success: false, error: error.message };
  }
};

// Delete category
export const deleteCategory = async (id) => {
  try {
    // Check if category is in use
    const expenses = storage.findWhere('expenses', { categoryId: id });
    const income = storage.findWhere('income', { categoryId: id });
    
    if (expenses.length > 0 || income.length > 0) {
      return { 
        success: false, 
        error: 'カテゴリは使用中のため削除できません。' 
      };
    }
    
    storage.deleteItem('categories', id);
    return { success: true };
  } catch (error) {
    console.error('Error deleting category:', error);
    return { success: false, error: error.message };
  }
};

// Get category statistics
export const getCategoryStats = async (categoryId) => {
  try {
    const expenses = storage.findWhere('expenses', { categoryId });
    const income = storage.findWhere('income', { categoryId });
    
    const expenseTotal = expenses.reduce((sum, item) => sum + item.amount, 0);
    const incomeTotal = income.reduce((sum, item) => sum + item.amount, 0);
    
    return {
      success: true,
      data: {
        expenseCount: expenses.length,
        expenseTotal,
        incomeCount: income.length,
        incomeTotal,
        totalTransactions: expenses.length + income.length,
        netAmount: incomeTotal - expenseTotal
      }
    };
  } catch (error) {
    console.error('Error getting category stats:', error);
    return { success: false, error: error.message };
  }
};

const categoryService = {
  createCategory,
  getCategoryById,
  getAllCategories,
  getCategoriesByType,
  updateCategory,
  deleteCategory,
  getCategoryStats
};

export default categoryService;
</file>

<file path="src/services/expenseService.js">
import storage from './storage';
import userService from './userService';
import categoryService from './categoryService';

/**
 * Expense Service - Handles all expense-related operations
 */

// Create a new expense
export const createExpense = async (expenseData) => {
  try {
    // Validate required fields
    if (!expenseData.date || !expenseData.categoryId || !expenseData.amount) {
      return { 
        success: false, 
        error: '日付、カテゴリ、金額は必須です。' 
      };
    }

    // Validate amount
    if (expenseData.amount <= 0) {
      return { 
        success: false, 
        error: '金額は0より大きい値を入力してください。' 
      };
    }

    // Create expense
    const newExpense = storage.addItem('expenses', {
      ...expenseData,
      status: expenseData.status || 'pending',
      tags: expenseData.tags || [],
      receiptIds: expenseData.receiptIds || []
    });

    return { success: true, data: newExpense };
  } catch (error) {
    console.error('Error creating expense:', error);
    return { success: false, error: error.message };
  }
};

// Get expense by ID
export const getExpenseById = async (id) => {
  try {
    const expense = storage.findById('expenses', id);
    return { success: true, data: expense };
  } catch (error) {
    console.error('Error getting expense:', error);
    return { success: false, error: error.message };
  }
};

// Helper function to populate expense with related data
const populateExpenseData = async (expense) => {
  const [userResult, categoryResult] = await Promise.all([
    expense.userId ? userService.getUserById(expense.userId) : null,
    expense.categoryId ? categoryService.getCategoryById(expense.categoryId) : null
  ]);

  return {
    ...expense,
    user: userResult?.success ? userResult.data : null,
    category: categoryResult?.success ? categoryResult.data : null
  };
};

// Get all expenses
export const getAllExpenses = async () => {
  try {
    const expenses = storage.get('expenses') || [];
    
    // Populate each expense with user and category data
    const populatedExpenses = await Promise.all(
      expenses.map(expense => populateExpenseData(expense))
    );
    
    return { success: true, data: populatedExpenses };
  } catch (error) {
    console.error('Error getting expenses:', error);
    return { success: false, error: error.message };
  }
};

// Get expenses by criteria
export const getExpensesByCriteria = async (criteria) => {
  try {
    const expenses = storage.findWhere('expenses', criteria);
    return { success: true, data: expenses };
  } catch (error) {
    console.error('Error getting expenses by criteria:', error);
    return { success: false, error: error.message };
  }
};

// Get expenses by date range
export const getExpensesByDateRange = async (startDate, endDate) => {
  try {
    const expenses = storage.get('expenses') || [];
    const filtered = expenses.filter(expense => {
      const expenseDate = new Date(expense.date);
      return expenseDate >= new Date(startDate) && expenseDate <= new Date(endDate);
    });
    
    // Populate each expense with user and category data
    const populatedExpenses = await Promise.all(
      filtered.map(expense => populateExpenseData(expense))
    );
    
    return { success: true, data: populatedExpenses };
  } catch (error) {
    console.error('Error getting expenses by date range:', error);
    return { success: false, error: error.message };
  }
};

// Update expense
export const updateExpense = async (id, updates) => {
  try {
    // Validate amount if updating
    if (updates.amount !== undefined && updates.amount <= 0) {
      return { 
        success: false, 
        error: '金額は0より大きい値を入力してください。' 
      };
    }

    const updatedExpense = storage.updateItem('expenses', id, updates);
    return { success: true, data: updatedExpense };
  } catch (error) {
    console.error('Error updating expense:', error);
    return { success: false, error: error.message };
  }
};

// Delete expense
export const deleteExpense = async (id) => {
  try {
    storage.deleteItem('expenses', id);
    return { success: true };
  } catch (error) {
    console.error('Error deleting expense:', error);
    return { success: false, error: error.message };
  }
};

// Approve expense
export const approveExpense = async (id, approvedBy) => {
  try {
    const updatedExpense = storage.updateItem('expenses', id, {
      status: 'approved',
      approvedBy,
      approvedAt: new Date().toISOString()
    });
    return { success: true, data: updatedExpense };
  } catch (error) {
    console.error('Error approving expense:', error);
    return { success: false, error: error.message };
  }
};

// Reject expense
export const rejectExpense = async (id, rejectedReason) => {
  try {
    const updatedExpense = storage.updateItem('expenses', id, {
      status: 'rejected',
      rejectedReason
    });
    return { success: true, data: updatedExpense };
  } catch (error) {
    console.error('Error rejecting expense:', error);
    return { success: false, error: error.message };
  }
};

// Get expense statistics
export const getExpenseStats = async (startDate, endDate) => {
  try {
    const result = await getExpensesByDateRange(startDate, endDate);
    if (!result.success) return result;

    const expenses = result.data;
    const total = expenses.reduce((sum, expense) => sum + expense.amount, 0);
    
    // Group by category
    const byCategory = expenses.reduce((acc, expense) => {
      if (!acc[expense.categoryId]) {
        acc[expense.categoryId] = {
          count: 0,
          total: 0
        };
      }
      acc[expense.categoryId].count++;
      acc[expense.categoryId].total += expense.amount;
      return acc;
    }, {});

    // Group by status
    const byStatus = expenses.reduce((acc, expense) => {
      if (!acc[expense.status]) {
        acc[expense.status] = {
          count: 0,
          total: 0
        };
      }
      acc[expense.status].count++;
      acc[expense.status].total += expense.amount;
      return acc;
    }, {});

    return {
      success: true,
      data: {
        count: expenses.length,
        total,
        average: expenses.length > 0 ? total / expenses.length : 0,
        byCategory,
        byStatus
      }
    };
  } catch (error) {
    console.error('Error getting expense stats:', error);
    return { success: false, error: error.message };
  }
};

const expenseService = {
  createExpense,
  getExpenseById,
  getAllExpenses,
  getExpensesByCriteria,
  getExpensesByDateRange,
  updateExpense,
  deleteExpense,
  approveExpense,
  rejectExpense,
  getExpenseStats
};

export default expenseService;
</file>

<file path="src/services/fileService.js">
import storage from './storage';

/**
 * File Service - Handles file uploads and management
 */

// Supported image types
const SUPPORTED_IMAGE_TYPES = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

// Convert file to base64
const fileToBase64 = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = error => reject(error);
  });
};

// Validate file
const validateFile = (file) => {
  const errors = [];
  
  if (!SUPPORTED_IMAGE_TYPES.includes(file.type)) {
    errors.push('サポートされていないファイル形式です。JPEG、PNG、GIF、WebPのみ対応しています。');
  }
  
  if (file.size > MAX_FILE_SIZE) {
    errors.push('ファイルサイズが大きすぎます。10MB以下にしてください。');
  }
  
  return errors;
};

// Create thumbnail
const createThumbnail = (file, maxWidth = 300, maxHeight = 300, quality = 0.8) => {
  return new Promise((resolve, reject) => {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        try {
          // Calculate new dimensions
          let { width, height } = img;
          
          if (width > height) {
            if (width > maxWidth) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            }
          } else {
            if (height > maxHeight) {
              width = (width * maxHeight) / height;
              height = maxHeight;
            }
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // Draw resized image
          ctx.drawImage(img, 0, 0, width, height);
          
          // Convert to base64
          const thumbnail = canvas.toDataURL('image/jpeg', quality);
          
          // Clean up object URL
          URL.revokeObjectURL(img.src);
          
          resolve(thumbnail);
        } catch (error) {
          console.error('Error creating thumbnail:', error);
          reject(error);
        }
      };
      
      img.onerror = (error) => {
        console.error('Error loading image for thumbnail:', error);
        URL.revokeObjectURL(img.src);
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    } catch (error) {
      console.error('Error in createThumbnail:', error);
      reject(error);
    }
  });
};

// Upload file
export const uploadFile = async (file, description = '') => {
  try {
    // Validate file
    const validationErrors = validateFile(file);
    if (validationErrors.length > 0) {
      return {
        success: false,
        error: validationErrors.join(' ')
      };
    }
    
    // Convert to base64
    const base64Data = await fileToBase64(file);
    
    // Create thumbnail (with fallback)
    let thumbnail = null;
    try {
      thumbnail = await createThumbnail(file);
    } catch (error) {
      console.warn('Failed to create thumbnail, using original:', error);
      // If thumbnail creation fails, use the original image for small files
      if (file.size < 500000) { // 500KB
        thumbnail = base64Data;
      }
    }
    
    // Create file record
    const fileRecord = {
      id: `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      originalName: file.name,
      fileName: `${Date.now()}_${file.name}`,
      mimeType: file.type,
      size: file.size,
      description: description,
      data: base64Data,
      thumbnail: thumbnail,
      uploadedAt: new Date().toISOString(),
      uploadedBy: 'user'
    };
    
    // Save to storage
    const savedFile = storage.addItem('files', fileRecord);
    
    return {
      success: true,
      data: {
        id: savedFile.id,
        originalName: savedFile.originalName,
        fileName: savedFile.fileName,
        mimeType: savedFile.mimeType,
        size: savedFile.size,
        description: savedFile.description,
        data: savedFile.data, // Include the full data for preview
        thumbnail: savedFile.thumbnail,
        uploadedAt: savedFile.uploadedAt
      }
    };
    
  } catch (error) {
    console.error('Error uploading file:', error);
    return {
      success: false,
      error: 'ファイルのアップロードに失敗しました。'
    };
  }
};

// Get file by ID
export const getFileById = async (id) => {
  try {
    const file = storage.findById('files', id);
    if (!file) {
      return {
        success: false,
        error: 'ファイルが見つかりません。'
      };
    }
    
    return {
      success: true,
      data: file
    };
  } catch (error) {
    console.error('Error getting file:', error);
    return {
      success: false,
      error: 'ファイルの取得に失敗しました。'
    };
  }
};

// Get multiple files by IDs
export const getFilesByIds = async (ids) => {
  try {
    const files = [];
    for (const id of ids) {
      const result = await getFileById(id);
      if (result.success) {
        files.push(result.data);
      }
    }
    
    return {
      success: true,
      data: files
    };
  } catch (error) {
    console.error('Error getting files:', error);
    return {
      success: false,
      error: 'ファイルの取得に失敗しました。'
    };
  }
};

// Delete file
export const deleteFile = async (id) => {
  try {
    storage.deleteItem('files', id);
    return {
      success: true
    };
  } catch (error) {
    console.error('Error deleting file:', error);
    return {
      success: false,
      error: 'ファイルの削除に失敗しました。'
    };
  }
};

// Get all files
export const getAllFiles = async () => {
  try {
    const files = storage.get('files') || [];
    return {
      success: true,
      data: files
    };
  } catch (error) {
    console.error('Error getting all files:', error);
    return {
      success: false,
      error: 'ファイル一覧の取得に失敗しました。'
    };
  }
};

// Format file size
export const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

// Check if file is image
export const isImageFile = (mimeType) => {
  return SUPPORTED_IMAGE_TYPES.includes(mimeType);
};

const fileService = {
  uploadFile,
  getFileById,
  getFilesByIds,
  deleteFile,
  getAllFiles,
  formatFileSize,
  isImageFile
};

export default fileService;
</file>

<file path="src/services/incomeService.js">
import storage from './storage';
import userService from './userService';
import categoryService from './categoryService';

/**
 * Income Service - Handles all income-related operations
 */

// Create a new income
export const createIncome = async (incomeData) => {
  try {
    // Validate required fields
    if (!incomeData.date || !incomeData.categoryId || !incomeData.amount || (!incomeData.source && !incomeData.description)) {
      return { 
        success: false, 
        error: '日付、カテゴリ、金額、説明は必須です。' 
      };
    }

    // Validate amount
    if (incomeData.amount <= 0) {
      return { 
        success: false, 
        error: '金額は0より大きい値を入力してください。' 
      };
    }

    // Create income
    const newIncome = storage.addItem('income', {
      ...incomeData,
      status: incomeData.status || 'confirmed',
      tags: incomeData.tags || [],
      fileIds: incomeData.fileIds || []
    });

    return { success: true, data: newIncome };
  } catch (error) {
    console.error('Error creating income:', error);
    return { success: false, error: error.message };
  }
};

// Get income by ID
export const getIncomeById = async (id) => {
  try {
    const income = storage.findById('income', id);
    return { success: true, data: income };
  } catch (error) {
    console.error('Error getting income:', error);
    return { success: false, error: error.message };
  }
};

// Helper function to populate income with related data
const populateIncomeData = async (income) => {
  const [userResult, categoryResult] = await Promise.all([
    income.userId ? userService.getUserById(income.userId) : null,
    income.categoryId ? categoryService.getCategoryById(income.categoryId) : null
  ]);

  return {
    ...income,
    user: userResult?.success ? userResult.data : null,
    category: categoryResult?.success ? categoryResult.data : null
  };
};

// Get all income
export const getAllIncome = async () => {
  try {
    const income = storage.get('income') || [];
    
    // Populate each income with user and category data
    const populatedIncome = await Promise.all(
      income.map(inc => populateIncomeData(inc))
    );
    
    return { success: true, data: populatedIncome };
  } catch (error) {
    console.error('Error getting income:', error);
    return { success: false, error: error.message };
  }
};

// Get income by criteria
export const getIncomeByCriteria = async (criteria) => {
  try {
    const income = storage.findWhere('income', criteria);
    return { success: true, data: income };
  } catch (error) {
    console.error('Error getting income by criteria:', error);
    return { success: false, error: error.message };
  }
};

// Get income by date range
export const getIncomeByDateRange = async (startDate, endDate) => {
  try {
    const income = storage.get('income') || [];
    const filtered = income.filter(item => {
      const incomeDate = new Date(item.date);
      return incomeDate >= new Date(startDate) && incomeDate <= new Date(endDate);
    });
    
    // Populate each income with user and category data
    const populatedIncome = await Promise.all(
      filtered.map(inc => populateIncomeData(inc))
    );
    
    return { success: true, data: populatedIncome };
  } catch (error) {
    console.error('Error getting income by date range:', error);
    return { success: false, error: error.message };
  }
};

// Update income
export const updateIncome = async (id, updates) => {
  try {
    // Validate amount if updating
    if (updates.amount !== undefined && updates.amount <= 0) {
      return { 
        success: false, 
        error: '金額は0より大きい値を入力してください。' 
      };
    }

    const updatedIncome = storage.updateItem('income', id, updates);
    return { success: true, data: updatedIncome };
  } catch (error) {
    console.error('Error updating income:', error);
    return { success: false, error: error.message };
  }
};

// Delete income
export const deleteIncome = async (id) => {
  try {
    storage.deleteItem('income', id);
    return { success: true };
  } catch (error) {
    console.error('Error deleting income:', error);
    return { success: false, error: error.message };
  }
};

// Get income statistics
export const getIncomeStats = async (startDate, endDate) => {
  try {
    const result = await getIncomeByDateRange(startDate, endDate);
    if (!result.success) return result;

    const income = result.data;
    const total = income.reduce((sum, item) => sum + item.amount, 0);
    
    // Group by category
    const byCategory = income.reduce((acc, item) => {
      if (!acc[item.categoryId]) {
        acc[item.categoryId] = {
          count: 0,
          total: 0
        };
      }
      acc[item.categoryId].count++;
      acc[item.categoryId].total += item.amount;
      return acc;
    }, {});

    // Group by source
    const bySource = income.reduce((acc, item) => {
      if (!acc[item.source]) {
        acc[item.source] = {
          count: 0,
          total: 0
        };
      }
      acc[item.source].count++;
      acc[item.source].total += item.amount;
      return acc;
    }, {});

    return {
      success: true,
      data: {
        count: income.length,
        total,
        average: income.length > 0 ? total / income.length : 0,
        byCategory,
        bySource
      }
    };
  } catch (error) {
    console.error('Error getting income stats:', error);
    return { success: false, error: error.message };
  }
};

const incomeService = {
  createIncome,
  getIncomeById,
  getAllIncome,
  getIncomeByCriteria,
  getIncomeByDateRange,
  updateIncome,
  deleteIncome,
  getIncomeStats
};

export default incomeService;
</file>

<file path="src/services/invoiceService.js">
import storage from './storage';

/**
 * Invoice Service - Handles all invoice-related operations
 */

// Create a new invoice
export const createInvoice = async (invoiceData) => {
  try {
    // Validate required fields
    if (!invoiceData.title || !invoiceData.amount || !invoiceData.dueDate) {
      return { 
        success: false, 
        error: 'タイトル、金額、期日は必須です。' 
      };
    }

    // Validate amount
    if (invoiceData.amount <= 0) {
      return { 
        success: false, 
        error: '金額は0より大きい値を入力してください。' 
      };
    }

    // Validate due date
    const dueDate = new Date(invoiceData.dueDate);
    if (isNaN(dueDate.getTime())) {
      return { 
        success: false, 
        error: '有効な期日を入力してください。' 
      };
    }

    // Create invoice
    const newInvoice = storage.addItem('invoices', {
      ...invoiceData,
      status: invoiceData.status || 'pending',
      isRecurring: invoiceData.isRecurring || false,
      recurringType: invoiceData.recurringType || 'monthly',
      nextDueDate: invoiceData.isRecurring ? calculateNextDueDate(dueDate, invoiceData.recurringType) : null,
      notificationSent: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    return { success: true, data: newInvoice };
  } catch (error) {
    console.error('Error creating invoice:', error);
    return { success: false, error: error.message };
  }
};

// Calculate next due date for recurring invoices
const calculateNextDueDate = (currentDueDate, recurringType) => {
  const nextDate = new Date(currentDueDate);
  
  switch (recurringType) {
    case 'weekly':
      nextDate.setDate(nextDate.getDate() + 7);
      break;
    case 'monthly':
      nextDate.setMonth(nextDate.getMonth() + 1);
      break;
    case 'quarterly':
      nextDate.setMonth(nextDate.getMonth() + 3);
      break;
    case 'yearly':
      nextDate.setFullYear(nextDate.getFullYear() + 1);
      break;
    default:
      nextDate.setMonth(nextDate.getMonth() + 1);
  }
  
  return nextDate.toISOString();
};

// Get invoice by ID
export const getInvoiceById = async (id) => {
  try {
    const invoice = storage.findById('invoices', id);
    return { success: true, data: invoice };
  } catch (error) {
    console.error('Error getting invoice:', error);
    return { success: false, error: error.message };
  }
};

// Get all invoices
export const getAllInvoices = async () => {
  try {
    const invoices = storage.get('invoices') || [];
    return { success: true, data: invoices };
  } catch (error) {
    console.error('Error getting invoices:', error);
    return { success: false, error: error.message };
  }
};

// Get invoices by status
export const getInvoicesByStatus = async (status) => {
  try {
    const invoices = storage.findWhere('invoices', { status });
    return { success: true, data: invoices };
  } catch (error) {
    console.error('Error getting invoices by status:', error);
    return { success: false, error: error.message };
  }
};

// Get upcoming invoices (due within specified days)
export const getUpcomingInvoices = async (daysAhead = 7) => {
  try {
    const invoices = storage.get('invoices') || [];
    const now = new Date();
    const futureDate = new Date();
    futureDate.setDate(now.getDate() + daysAhead);

    const upcoming = invoices.filter(invoice => {
      const dueDate = new Date(invoice.dueDate);
      return dueDate >= now && dueDate <= futureDate && invoice.status === 'pending';
    });

    return { success: true, data: upcoming };
  } catch (error) {
    console.error('Error getting upcoming invoices:', error);
    return { success: false, error: error.message };
  }
};

// Get overdue invoices
export const getOverdueInvoices = async () => {
  try {
    const invoices = storage.get('invoices') || [];
    const now = new Date();

    const overdue = invoices.filter(invoice => {
      const dueDate = new Date(invoice.dueDate);
      return dueDate < now && invoice.status === 'pending';
    });

    return { success: true, data: overdue };
  } catch (error) {
    console.error('Error getting overdue invoices:', error);
    return { success: false, error: error.message };
  }
};

// Update invoice
export const updateInvoice = async (id, updates) => {
  try {
    // Validate amount if updating
    if (updates.amount !== undefined && updates.amount <= 0) {
      return { 
        success: false, 
        error: '金額は0より大きい値を入力してください。' 
      };
    }

    const updatedInvoice = storage.updateItem('invoices', id, {
      ...updates,
      updatedAt: new Date().toISOString()
    });

    return { success: true, data: updatedInvoice };
  } catch (error) {
    console.error('Error updating invoice:', error);
    return { success: false, error: error.message };
  }
};

// Mark invoice as paid
export const markInvoiceAsPaid = async (id) => {
  try {
    const invoice = storage.findById('invoices', id);
    if (!invoice) {
      return { success: false, error: '請求書が見つかりません。' };
    }

    const updatedInvoice = storage.updateItem('invoices', id, {
      status: 'paid',
      paidAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    // If it's a recurring invoice, create the next invoice
    if (invoice.isRecurring && invoice.nextDueDate) {
      const nextInvoice = {
        ...invoice,
        id: undefined, // Let storage assign new ID
        dueDate: invoice.nextDueDate,
        nextDueDate: calculateNextDueDate(new Date(invoice.nextDueDate), invoice.recurringType),
        status: 'pending',
        paidAt: null,
        notificationSent: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      await createInvoice(nextInvoice);
    }

    return { success: true, data: updatedInvoice };
  } catch (error) {
    console.error('Error marking invoice as paid:', error);
    return { success: false, error: error.message };
  }
};

// Delete invoice
export const deleteInvoice = async (id) => {
  try {
    storage.deleteItem('invoices', id);
    return { success: true };
  } catch (error) {
    console.error('Error deleting invoice:', error);
    return { success: false, error: error.message };
  }
};

// Get invoice statistics
export const getInvoiceStats = async () => {
  try {
    const invoices = storage.get('invoices') || [];
    const now = new Date();

    const total = invoices.length;
    const pending = invoices.filter(i => i.status === 'pending').length;
    const paid = invoices.filter(i => i.status === 'paid').length;
    const overdue = invoices.filter(i => {
      const dueDate = new Date(i.dueDate);
      return dueDate < now && i.status === 'pending';
    }).length;

    const totalAmount = invoices.reduce((sum, i) => sum + i.amount, 0);
    const pendingAmount = invoices
      .filter(i => i.status === 'pending')
      .reduce((sum, i) => sum + i.amount, 0);
    const paidAmount = invoices
      .filter(i => i.status === 'paid')
      .reduce((sum, i) => sum + i.amount, 0);

    return {
      success: true,
      data: {
        total,
        pending,
        paid,
        overdue,
        totalAmount,
        pendingAmount,
        paidAmount
      }
    };
  } catch (error) {
    console.error('Error getting invoice stats:', error);
    return { success: false, error: error.message };
  }
};

const invoiceService = {
  createInvoice,
  getInvoiceById,
  getAllInvoices,
  getInvoicesByStatus,
  getUpcomingInvoices,
  getOverdueInvoices,
  updateInvoice,
  markInvoiceAsPaid,
  deleteInvoice,
  getInvoiceStats
};

export default invoiceService;
</file>

<file path="src/services/notificationService.js">
import storage from './storage';
import invoiceService from './invoiceService';

/**
 * Notification Service - Handles all notification-related operations
 */

// Create a new notification
export const createNotification = async (notificationData) => {
  try {
    const newNotification = storage.addItem('notifications', {
      ...notificationData,
      isRead: false,
      createdAt: new Date().toISOString(),
    });

    return { success: true, data: newNotification };
  } catch (error) {
    console.error('Error creating notification:', error);
    return { success: false, error: error.message };
  }
};

// Get all notifications
export const getAllNotifications = async () => {
  try {
    const notifications = storage.get('notifications') || [];
    // Sort by creation date (newest first)
    notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    return { success: true, data: notifications };
  } catch (error) {
    console.error('Error getting notifications:', error);
    return { success: false, error: error.message };
  }
};

// Get unread notifications
export const getUnreadNotifications = async () => {
  try {
    const notifications = storage.findWhere('notifications', { isRead: false });
    notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    return { success: true, data: notifications };
  } catch (error) {
    console.error('Error getting unread notifications:', error);
    return { success: false, error: error.message };
  }
};

// Mark notification as read
export const markAsRead = async (notificationId) => {
  try {
    const updatedNotification = storage.updateItem('notifications', notificationId, {
      isRead: true,
      readAt: new Date().toISOString()
    });
    return { success: true, data: updatedNotification };
  } catch (error) {
    console.error('Error marking notification as read:', error);
    return { success: false, error: error.message };
  }
};

// Mark all notifications as read
export const markAllAsRead = async () => {
  try {
    const notifications = storage.get('notifications') || [];
    const unreadNotifications = notifications.filter(n => !n.isRead);
    
    for (const notification of unreadNotifications) {
      storage.updateItem('notifications', notification.id, {
        isRead: true,
        readAt: new Date().toISOString()
      });
    }
    
    return { success: true };
  } catch (error) {
    console.error('Error marking all notifications as read:', error);
    return { success: false, error: error.message };
  }
};

// Delete notification
export const deleteNotification = async (notificationId) => {
  try {
    storage.deleteItem('notifications', notificationId);
    return { success: true };
  } catch (error) {
    console.error('Error deleting notification:', error);
    return { success: false, error: error.message };
  }
};

// Clear all notifications
export const clearAllNotifications = async () => {
  try {
    storage.set('notifications', []);
    return { success: true };
  } catch (error) {
    console.error('Error clearing notifications:', error);
    return { success: false, error: error.message };
  }
};

// Check for invoice due date notifications
export const checkInvoiceDueDates = async () => {
  try {
    const [upcomingResult, overdueResult] = await Promise.all([
      invoiceService.getUpcomingInvoices(3), // 3 days ahead
      invoiceService.getOverdueInvoices()
    ]);

    const notifications = [];

    // Create notifications for upcoming invoices
    if (upcomingResult.success) {
      for (const invoice of upcomingResult.data) {
        const daysUntilDue = Math.ceil(
          (new Date(invoice.dueDate) - new Date()) / (1000 * 60 * 60 * 24)
        );

        const existingNotifications = storage.findWhere('notifications', {
          type: 'invoice_due_soon',
          relatedId: invoice.id
        });

        // Don't create duplicate notifications
        if (existingNotifications.length === 0) {
          await createNotification({
            type: 'invoice_due_soon',
            title: '請求書期日間近',
            message: `請求書「${invoice.title}」の期日まで${daysUntilDue}日です。`,
            priority: 'medium',
            relatedId: invoice.id,
            relatedType: 'invoice'
          });
        }
      }
    }

    // Create notifications for overdue invoices
    if (overdueResult.success) {
      for (const invoice of overdueResult.data) {
        const daysOverdue = Math.floor(
          (new Date() - new Date(invoice.dueDate)) / (1000 * 60 * 60 * 24)
        );

        const existingNotifications = storage.findWhere('notifications', {
          type: 'invoice_overdue',
          relatedId: invoice.id
        });

        // Don't create duplicate notifications
        if (existingNotifications.length === 0) {
          await createNotification({
            type: 'invoice_overdue',
            title: '請求書期日超過',
            message: `請求書「${invoice.title}」が${daysOverdue}日遅れています。`,
            priority: 'high',
            relatedId: invoice.id,
            relatedType: 'invoice'
          });
        }
      }
    }

    return { success: true, data: notifications };
  } catch (error) {
    console.error('Error checking invoice due dates:', error);
    return { success: false, error: error.message };
  }
};

// Get notification statistics
export const getNotificationStats = async () => {
  try {
    const notifications = storage.get('notifications') || [];
    
    const total = notifications.length;
    const unread = notifications.filter(n => !n.isRead).length;
    const high = notifications.filter(n => n.priority === 'high').length;
    const medium = notifications.filter(n => n.priority === 'medium').length;
    const low = notifications.filter(n => n.priority === 'low').length;

    // Group by type
    const byType = notifications.reduce((acc, notification) => {
      acc[notification.type] = (acc[notification.type] || 0) + 1;
      return acc;
    }, {});

    return {
      success: true,
      data: {
        total,
        unread,
        high,
        medium,
        low,
        byType
      }
    };
  } catch (error) {
    console.error('Error getting notification stats:', error);
    return { success: false, error: error.message };
  }
};

// Auto-check for notifications (can be called periodically)
export const autoCheckNotifications = async () => {
  try {
    await checkInvoiceDueDates();
    return { success: true };
  } catch (error) {
    console.error('Error in auto-check notifications:', error);
    return { success: false, error: error.message };
  }
};

const notificationService = {
  createNotification,
  getAllNotifications,
  getUnreadNotifications,
  markAsRead,
  markAllAsRead,
  deleteNotification,
  clearAllNotifications,
  checkInvoiceDueDates,
  getNotificationStats,
  autoCheckNotifications
};

export default notificationService;
</file>

<file path="src/services/ocrServiceNew.js">
import Tesseract from 'tesseract.js';
import { preprocessImage, needsPreprocessing } from '../utils/imagePreprocessing';
import storage from './storage';

/**
 * OCR Service - Alternative implementation for Tesseract.js v5 with GPT enhancement
 */

// Perform OCR on an image file - simplified version
export const performOCR = async (imageFile, onProgress) => {
  try {
    
    // Update progress
    if (onProgress) {
      onProgress({
        status: 'initializing',
        progress: 0
      });
    }

    // Check if preprocessing is needed
    let processedImage = imageFile;
    const shouldPreprocess = await needsPreprocessing(imageFile);
    
    if (shouldPreprocess) {
      if (onProgress) {
        onProgress({
          status: 'preprocessing',
          progress: 20
        });
      }
      processedImage = await preprocessImage(imageFile);
    }

    // Create a worker for better control over parameters
    const worker = await Tesseract.createWorker('jpn+eng');
    
    // Set parameters for better Japanese recognition
    await worker.setParameters({
      tessedit_pageseg_mode: Tesseract.PSM.AUTO, // Automatic page segmentation
      preserve_interword_spaces: '1',
      // Remove whitelist to allow all characters
    });
    
    // Since we can't get progress updates without logger, simulate progress
    if (onProgress) {
      onProgress({
        status: 'processing',
        progress: 50
      });
    }
    
    // Perform recognition
    const result = await worker.recognize(processedImage);
    
    
    // Terminate worker
    await worker.terminate();
    
    // Complete progress
    if (onProgress) {
      onProgress({
        status: 'completed',
        progress: 100
      });
    }

    // Extract and return data
    const ocrData = {
      text: result.data?.text || '',
      confidence: result.data?.confidence || 0,
      lines: []
    };

    // Process lines if available
    if (result.data?.lines && Array.isArray(result.data.lines)) {
      ocrData.lines = result.data.lines.map(line => ({
        text: line.text || '',
        confidence: line.confidence || 0,
        bbox: line.bbox || null
      }));
    }

    return {
      success: true,
      data: ocrData
    };
  } catch (error) {
    console.error('OCR Error:', error);
    return {
      success: false,
      error: `OCR処理中にエラーが発生しました: ${error.message}`
    };
  }
};

// Enhance OCR text using GPT
async function enhanceOCRWithGPT(ocrText) {
  try {
    const settings = storage.get('settings') || {};
    const apiKey = settings.openaiApiKey;
    
    if (!apiKey) {
      return ocrText;
    }
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: `あなたは日本のレシートや領収書を解析するAIアシスタントです。
与えられたOCRテキスト（文字認識の生データ）から、以下の情報を正確に抽出してください：

1. 合計金額（税込）
2. 日付（YYYY-MM-DD形式）
3. 店舗名/会社名
4. 商品明細（商品名と価格のリスト）
5. 税額
6. カテゴリ（食費、交通費、消耗品費など）

OCRの誤認識を修正し、日本語として正しい形に整形してください。
情報が不明確な場合は、最も可能性の高い解釈をしてください。

出力は以下のJSON形式で返してください：
{
  "amount": 金額（数値）,
  "date": "YYYY-MM-DD",
  "vendor": "店舗名",
  "items": [{"name": "商品名", "price": 価格}],
  "tax": 税額（数値）,
  "category": "カテゴリ名",
  "originalText": "整形後のテキスト"
}`
          },
          {
            role: 'user',
            content: `以下のOCRテキストからレシート情報を抽出してください：\n\n${ocrText}`
          }
        ],
        max_tokens: 800,
        temperature: 0.3
      })
    });
    
    if (!response.ok) {
      return ocrText;
    }
    
    const data = await response.json();
    const content = data.choices[0]?.message?.content;
    
    if (!content) {
      return ocrText;
    }
    
    try {
      // Parse JSON response
      const parsed = JSON.parse(content);
      return parsed;
    } catch (jsonError) {
      // Return the enhanced text even if JSON parsing fails
      return content;
    }
  } catch (error) {
    return ocrText;
  }
}

// Extract expense/income data from OCR text
export const extractTransactionData = (ocrText) => {
  try {
    // Validate input
    if (!ocrText || typeof ocrText !== 'string') {
      return {
        success: false,
        error: 'OCRテキストが無効です',
        data: null
      };
    }
    
    const data = {
      amount: null,
      date: null,
      vendor: null,
      items: [],
      category: null,
      tax: null,
      total: null
    };

    // Extract amount (look for patterns like ¥1,234 or 1,234円)
    const amountPatterns = [
      /¥\s*([\d,]+)/g,
      /([\d,]+)\s*円/g,
      /合計[：:]\s*([\d,]+)/g,
      /TOTAL[：:]\s*([\d,]+)/g,
      /計[：:]\s*([\d,]+)/g,
    ];

    for (const pattern of amountPatterns) {
      const matches = ocrText.matchAll(pattern);
      for (const match of matches) {
        const amount = parseInt(match[1].replace(/,/g, ''));
        if (amount && (!data.amount || amount > data.amount)) {
          data.amount = amount;
        }
      }
    }

    // Extract date (various formats)
    const datePatterns = [
      /(\d{4})[年/-](\d{1,2})[月/-](\d{1,2})[日]?/g,
      /(\d{1,2})[月/-](\d{1,2})[日/-](\d{4})/g,
      /令和(\d+)年(\d{1,2})月(\d{1,2})日/g,
      /R(\d+)\.(\d{1,2})\.(\d{1,2})/g,
    ];

    for (const pattern of datePatterns) {
      const match = ocrText.match(pattern);
      if (match) {
        let year, month, day;
        
        if (match[0].includes('令和') || match[0].startsWith('R')) {
          // Convert Japanese era to Western year
          year = 2018 + parseInt(match[1]);
          month = match[2];
          day = match[3];
        } else if (match[1].length === 4) {
          year = match[1];
          month = match[2];
          day = match[3];
        } else {
          year = match[3];
          month = match[1];
          day = match[2];
        }
        
        data.date = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
        break;
      }
    }

    // Extract vendor/store name (usually at the top of receipt)
    const lines = ocrText.split('\n').filter(line => line.trim());
    if (lines.length > 0) {
      // First non-empty line is often the store name
      data.vendor = lines[0].trim();
    }

    // Extract tax information
    const taxPatterns = [
      /消費税[：:]\s*([\d,]+)/g,
      /税[：:]\s*([\d,]+)/g,
      /内税[：:]\s*([\d,]+)/g,
    ];

    for (const pattern of taxPatterns) {
      const match = ocrText.match(pattern);
      if (match) {
        data.tax = parseInt(match[1].replace(/,/g, ''));
        break;
      }
    }

    // Try to categorize based on vendor or items
    const categoryKeywords = {
      '交通費': ['JR', '鉄道', 'タクシー', 'バス', '交通', '駅', 'SUICA', 'PASMO'],
      '食費': ['レストラン', '食堂', 'カフェ', 'コーヒー', '弁当', 'ランチ', 'ディナー', '食品'],
      '消耗品費': ['文具', 'オフィス', '事務', 'コピー', '印刷', 'ペン', '紙'],
      '接待費': ['会食', '接待', 'ホテル', 'レストラン', 'バー'],
      '通信費': ['携帯', 'モバイル', '電話', 'インターネット', 'Wi-Fi'],
      '書籍費': ['書店', '本', 'ブック', 'Amazon', '出版'],
    };

    for (const [category, keywords] of Object.entries(categoryKeywords)) {
      if (keywords.some(keyword => ocrText.includes(keyword))) {
        data.category = category;
        break;
      }
    }

    // Extract individual items (lines with prices)
    const itemPattern = /(.+?)\s+([\d,]+)\s*円?/g;
    const itemMatches = ocrText.matchAll(itemPattern);
    for (const match of itemMatches) {
      const itemName = match[1].trim();
      const itemPrice = parseInt(match[2].replace(/,/g, ''));
      if (itemName && itemPrice && itemPrice < (data.amount || Infinity)) {
        data.items.push({
          name: itemName,
          price: itemPrice
        });
      }
    }

    return {
      success: true,
      data,
      confidence: data.amount ? 'high' : 'low'
    };
  } catch (error) {
    console.error('Error extracting transaction data:', error);
    return {
      success: false,
      error: 'データ抽出中にエラーが発生しました。'
    };
  }
};

// Process receipt image and extract structured data
export const processReceipt = async (imageFile, onProgress) => {
  try {
    // First perform OCR
    const ocrResult = await performOCR(imageFile, onProgress);
    
    if (!ocrResult.success) {
      return ocrResult;
    }

    // Update progress for GPT processing
    if (onProgress) {
      onProgress({
        status: 'analyzing',
        progress: 70
      });
    }

    // Try to enhance with GPT if OCR text is available
    let enhancedData = null;
    if (ocrResult.data.text) {
      enhancedData = await enhanceOCRWithGPT(ocrResult.data.text);
    }

    // If GPT returned structured data, use it
    if (enhancedData && typeof enhancedData === 'object' && enhancedData.amount) {
      
      // Complete progress
      if (onProgress) {
        onProgress({
          status: 'completed',
          progress: 100
        });
      }
      
      return {
        success: true,
        data: {
          amount: enhancedData.amount,
          date: enhancedData.date,
          vendor: enhancedData.vendor,
          items: enhancedData.items || [],
          category: enhancedData.category,
          tax: enhancedData.tax,
          ocrText: enhancedData.originalText || ocrResult.data.text,
          confidence: 85, // Higher confidence with GPT enhancement
          enhanced: true
        }
      };
    }

    // Fallback to traditional extraction if GPT enhancement failed
    const extractResult = extractTransactionData(ocrResult.data.text);
    
    if (!extractResult.success) {
      return extractResult;
    }

    // Complete progress
    if (onProgress) {
      onProgress({
        status: 'completed',
        progress: 100
      });
    }

    return {
      success: true,
      data: {
        ...extractResult.data,
        ocrText: ocrResult.data.text,
        confidence: ocrResult.data.confidence,
        enhanced: false
      }
    };
  } catch (error) {
    console.error('Error processing receipt:', error);
    return {
      success: false,
      error: 'レシート処理中にエラーが発生しました。'
    };
  }
};

const ocrService = {
  performOCR,
  extractTransactionData,
  processReceipt,
  cleanupWorker: async () => {} // No cleanup needed for this approach
};

export default ocrService;
</file>

<file path="src/services/settingsService.js">
import storage from './storage';

/**
 * Settings Service - Handles all settings-related operations
 */

// Get all settings
export const getAllSettings = async () => {
  try {
    const settings = storage.get('settings') || {};
    return { success: true, data: settings };
  } catch (error) {
    console.error('Error getting settings:', error);
    return { success: false, error: error.message };
  }
};

// Get specific setting
export const getSetting = async (key) => {
  try {
    const settings = storage.get('settings') || {};
    return { success: true, data: settings[key] };
  } catch (error) {
    console.error('Error getting setting:', error);
    return { success: false, error: error.message };
  }
};

// Update setting
export const updateSetting = async (key, value) => {
  try {
    const settings = storage.get('settings') || {};
    settings[key] = value;
    settings.updatedAt = new Date().toISOString();
    storage.set('settings', settings);
    return { success: true, data: settings };
  } catch (error) {
    console.error('Error updating setting:', error);
    return { success: false, error: error.message };
  }
};

// Update multiple settings
export const updateSettings = async (updates) => {
  try {
    const settings = storage.get('settings') || {};
    Object.keys(updates).forEach(key => {
      settings[key] = updates[key];
    });
    settings.updatedAt = new Date().toISOString();
    storage.set('settings', settings);
    return { success: true, data: settings };
  } catch (error) {
    console.error('Error updating settings:', error);
    return { success: false, error: error.message };
  }
};

// Reset settings to defaults
export const resetSettings = async () => {
  try {
    const defaultSettings = {
      currency: 'JPY',
      dateFormat: 'YYYY-MM-DD',
      timeFormat: '24h',
      theme: 'light',
      language: 'ja',
      autoBackup: true,
      maxFileSize: 10485760, // 10MB
      updatedAt: new Date().toISOString()
    };
    storage.set('settings', defaultSettings);
    return { success: true, data: defaultSettings };
  } catch (error) {
    console.error('Error resetting settings:', error);
    return { success: false, error: error.message };
  }
};

// Export settings
export const exportSettings = async () => {
  try {
    const settings = storage.get('settings') || {};
    return { 
      success: true, 
      data: {
        settings,
        exportedAt: new Date().toISOString()
      }
    };
  } catch (error) {
    console.error('Error exporting settings:', error);
    return { success: false, error: error.message };
  }
};

// Import settings
export const importSettings = async (importData) => {
  try {
    if (!importData || !importData.settings) {
      return { 
        success: false, 
        error: '無効なインポートデータです。' 
      };
    }
    
    const settings = {
      ...importData.settings,
      updatedAt: new Date().toISOString()
    };
    storage.set('settings', settings);
    return { success: true, data: settings };
  } catch (error) {
    console.error('Error importing settings:', error);
    return { success: false, error: error.message };
  }
};

const settingsService = {
  getAllSettings,
  getSetting,
  updateSetting,
  updateSettings,
  resetSettings,
  exportSettings,
  importSettings
};

export default settingsService;
</file>

<file path="src/services/storage.js">
/**
 * Simple storage service using localStorage
 * This provides a reliable, synchronous storage solution
 */

class StorageService {
  constructor() {
    this.prefix = 'attureExpence_';
    this.initializeDefaultData();
  }

  // Helper method to get full key with prefix
  getKey(key) {
    return `${this.prefix}${key}`;
  }

  // Get data from storage
  get(key) {
    try {
      const data = localStorage.getItem(this.getKey(key));
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error(`Error getting ${key}:`, error);
      return null;
    }
  }

  // Set data to storage
  set(key, value) {
    try {
      localStorage.setItem(this.getKey(key), JSON.stringify(value));
      return true;
    } catch (error) {
      console.error(`Error setting ${key}:`, error);
      return false;
    }
  }

  // Remove data from storage
  remove(key) {
    try {
      localStorage.removeItem(this.getKey(key));
      return true;
    } catch (error) {
      console.error(`Error removing ${key}:`, error);
      return false;
    }
  }

  // Clear all data
  clear() {
    try {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.startsWith(this.prefix)) {
          localStorage.removeItem(key);
        }
      });
      return true;
    } catch (error) {
      console.error('Error clearing storage:', error);
      return false;
    }
  }

  // Initialize with default data if empty
  initializeDefaultData() {
    // Check if already initialized
    if (this.get('initialized')) {
      return;
    }

    const now = new Date().toISOString();

    // Default categories with proper Japanese tax accounting structure
    const defaultCategories = [
      // Income categories (収益勘定)
      { id: 1, name: '売上高', type: 'income', color: '#4CAF50', icon: 'salary', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 2, name: '受取手数料', type: 'income', color: '#2196F3', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 3, name: '受取利息', type: 'income', color: '#00BCD4', icon: 'investment', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 4, name: '受取配当金', type: 'income', color: '#009688', icon: 'investment', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 5, name: '雑収入', type: 'income', color: '#795548', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 6, name: '有価証券売却益', type: 'income', color: '#607D8B', icon: 'investment', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 7, name: '固定資産売却益', type: 'income', color: '#455A64', icon: 'investment', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 8, name: '為替差益', type: 'income', color: '#37474F', icon: 'investment', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 9, name: '保険差益', type: 'income', color: '#263238', icon: 'health', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 10, name: '補助金収入', type: 'income', color: '#4CAF50', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 11, name: '助成金収入', type: 'income', color: '#43A047', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 12, name: '受取家賃', type: 'income', color: '#388E3C', icon: 'home', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 13, name: '受託収益', type: 'income', color: '#2E7D32', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 14, name: '工事収益', type: 'income', color: '#1B5E20', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 15, name: '役務収益', type: 'income', color: '#33691E', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 16, name: '保守料収入', type: 'income', color: '#827717', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 17, name: '会費収入', type: 'income', color: '#F57F17', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 18, name: 'ロイヤリティ収入', type: 'income', color: '#F57C00', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 19, name: '広告収入', type: 'income', color: '#EF6C00', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 20, name: 'サブスクリプション収入', type: 'income', color: '#E65100', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 21, name: 'ライセンス収入', type: 'income', color: '#BF360C', icon: 'work', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 22, name: 'キャンセル料収入', type: 'income', color: '#3E2723', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 23, name: '返品減額収入', type: 'income', color: '#5D4037', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },

      // Expense categories with groups (費用勘定)
      // 人件費 (Personnel Expenses) - Parent Category
      { id: 24, name: '人件費', type: 'expense', color: '#F44336', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 25, name: '給与手当', type: 'expense', color: '#F44336', icon: 'salary', parentId: 24, isActive: true, createdAt: now, updatedAt: now },
      { id: 26, name: '法定福利費', type: 'expense', color: '#F44336', icon: 'health', parentId: 24, isActive: true, createdAt: now, updatedAt: now },
      { id: 27, name: '福利厚生費', type: 'expense', color: '#F44336', icon: 'health', parentId: 24, isActive: true, createdAt: now, updatedAt: now },
      { id: 28, name: '役員報酬', type: 'expense', color: '#F44336', icon: 'salary', parentId: 24, isActive: true, createdAt: now, updatedAt: now },
      { id: 29, name: '教育研修費', type: 'expense', color: '#F44336', icon: 'education', parentId: 24, isActive: true, createdAt: now, updatedAt: now },
      { id: 30, name: '採用費', type: 'expense', color: '#F44336', icon: 'work', parentId: 24, isActive: true, createdAt: now, updatedAt: now },

      // 売上原価 (Cost of Sales) - Parent Category
      { id: 31, name: '売上原価', type: 'expense', color: '#E91E63', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 32, name: '仕入高', type: 'expense', color: '#E91E63', icon: 'shopping', parentId: 31, isActive: true, createdAt: now, updatedAt: now },
      { id: 33, name: '外注費', type: 'expense', color: '#E91E63', icon: 'work', parentId: 31, isActive: true, createdAt: now, updatedAt: now },
      { id: 34, name: '材料費', type: 'expense', color: '#E91E63', icon: 'shopping', parentId: 31, isActive: true, createdAt: now, updatedAt: now },
      { id: 35, name: '加工費', type: 'expense', color: '#E91E63', icon: 'work', parentId: 31, isActive: true, createdAt: now, updatedAt: now },

      // 販売費 (Selling Expenses) - Parent Category
      { id: 36, name: '販売費', type: 'expense', color: '#9C27B0', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 37, name: '広告宣伝費', type: 'expense', color: '#9C27B0', icon: 'entertainment', parentId: 36, isActive: true, createdAt: now, updatedAt: now },
      { id: 38, name: '販売促進費', type: 'expense', color: '#9C27B0', icon: 'entertainment', parentId: 36, isActive: true, createdAt: now, updatedAt: now },
      { id: 39, name: '営業費', type: 'expense', color: '#9C27B0', icon: 'work', parentId: 36, isActive: true, createdAt: now, updatedAt: now },
      { id: 40, name: '展示会費', type: 'expense', color: '#9C27B0', icon: 'entertainment', parentId: 36, isActive: true, createdAt: now, updatedAt: now },

      // 一般管理費 (General Administrative Expenses) - Parent Category
      { id: 41, name: '一般管理費', type: 'expense', color: '#3F51B5', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 42, name: '通信費', type: 'expense', color: '#3F51B5', icon: 'utilities', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 43, name: '旅費交通費', type: 'expense', color: '#3F51B5', icon: 'transport', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 44, name: '会議費', type: 'expense', color: '#3F51B5', icon: 'work', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 45, name: '交際費', type: 'expense', color: '#3F51B5', icon: 'food', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 46, name: '接待費', type: 'expense', color: '#3F51B5', icon: 'food', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 47, name: '水道光熱費', type: 'expense', color: '#3F51B5', icon: 'utilities', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 48, name: '家賃支払', type: 'expense', color: '#3F51B5', icon: 'home', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 49, name: '消耗品費', type: 'expense', color: '#3F51B5', icon: 'shopping', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 50, name: '事務用品費', type: 'expense', color: '#3F51B5', icon: 'shopping', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 51, name: '新聞図書費', type: 'expense', color: '#3F51B5', icon: 'education', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 52, name: '租税公課', type: 'expense', color: '#3F51B5', icon: 'category', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 53, name: '支払手数料', type: 'expense', color: '#3F51B5', icon: 'category', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 54, name: '保険料', type: 'expense', color: '#3F51B5', icon: 'health', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 55, name: '修繕費', type: 'expense', color: '#3F51B5', icon: 'work', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 56, name: '車両費', type: 'expense', color: '#3F51B5', icon: 'transport', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 57, name: '運搬費', type: 'expense', color: '#3F51B5', icon: 'transport', parentId: 41, isActive: true, createdAt: now, updatedAt: now },
      { id: 58, name: '雑費', type: 'expense', color: '#3F51B5', icon: 'category', parentId: 41, isActive: true, createdAt: now, updatedAt: now },

      // 減価償却・金融費用 (Depreciation & Financial Expenses) - Parent Category
      { id: 59, name: '減価償却・金融費用', type: 'expense', color: '#FF9800', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 60, name: '減価償却費', type: 'expense', color: '#FF9800', icon: 'investment', parentId: 59, isActive: true, createdAt: now, updatedAt: now },
      { id: 61, name: '支払利息', type: 'expense', color: '#FF9800', icon: 'investment', parentId: 59, isActive: true, createdAt: now, updatedAt: now },
      { id: 62, name: '貸倒損失', type: 'expense', color: '#FF9800', icon: 'investment', parentId: 59, isActive: true, createdAt: now, updatedAt: now },
      { id: 63, name: '為替差損', type: 'expense', color: '#FF9800', icon: 'investment', parentId: 59, isActive: true, createdAt: now, updatedAt: now },

      // その他費用 (Other Expenses) - Parent Category
      { id: 64, name: 'その他費用', type: 'expense', color: '#795548', icon: 'category', parentId: null, isActive: true, createdAt: now, updatedAt: now },
      { id: 65, name: '寄付金', type: 'expense', color: '#795548', icon: 'gift', parentId: 64, isActive: true, createdAt: now, updatedAt: now },
      { id: 66, name: '顧問料', type: 'expense', color: '#795548', icon: 'work', parentId: 64, isActive: true, createdAt: now, updatedAt: now },
      { id: 67, name: 'システム利用料', type: 'expense', color: '#795548', icon: 'freelance', parentId: 64, isActive: true, createdAt: now, updatedAt: now },
      { id: 68, name: 'クラウドサービス費', type: 'expense', color: '#795548', icon: 'freelance', parentId: 64, isActive: true, createdAt: now, updatedAt: now },
      { id: 69, name: '会費', type: 'expense', color: '#795548', icon: 'category', parentId: 64, isActive: true, createdAt: now, updatedAt: now }
    ];

    // Default settings
    const defaultSettings = {
      currency: 'JPY',
      dateFormat: 'YYYY-MM-DD',
      theme: 'light',
      language: 'ja',
      autoBackup: true,
      maxFileSize: 10485760, // 10MB
      updatedAt: now
    };

    // Initialize storage
    this.set('categories', defaultCategories);
    this.set('settings', defaultSettings);
    this.set('users', []);
    this.set('expenses', []);
    this.set('income', []);
    this.set('tags', []);
    this.set('files', []);
    this.set('initialized', true);

    console.log('Storage initialized with default data');
  }

  // Get next ID for a collection
  getNextId(collection) {
    const items = this.get(collection) || [];
    if (items.length === 0) return 1;
    const maxId = Math.max(...items.map(item => item.id || 0));
    return maxId + 1;
  }

  // Add item to a collection
  addItem(collection, item) {
    const items = this.get(collection) || [];
    const newItem = {
      ...item,
      id: item.id || this.getNextId(collection),
      createdAt: item.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    items.push(newItem);
    this.set(collection, items);
    return newItem;
  }

  // Update item in a collection
  updateItem(collection, id, updates) {
    const items = this.get(collection) || [];
    const index = items.findIndex(item => item.id === id);
    if (index === -1) return null;

    items[index] = {
      ...items[index],
      ...updates,
      id: items[index].id, // Preserve ID
      createdAt: items[index].createdAt, // Preserve creation date
      updatedAt: new Date().toISOString()
    };
    this.set(collection, items);
    return items[index];
  }

  // Delete item from a collection
  deleteItem(collection, id) {
    const items = this.get(collection) || [];
    const filtered = items.filter(item => item.id !== id);
    this.set(collection, filtered);
    return true;
  }

  // Find item by ID
  findById(collection, id) {
    const items = this.get(collection) || [];
    return items.find(item => item.id === id) || null;
  }

  // Find items by criteria
  findWhere(collection, criteria) {
    const items = this.get(collection) || [];
    return items.filter(item => {
      return Object.keys(criteria).every(key => item[key] === criteria[key]);
    });
  }

  // Export all data
  exportData() {
    const data = {};
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        const cleanKey = key.replace(this.prefix, '');
        data[cleanKey] = this.get(cleanKey);
      }
    });
    return data;
  }

  // Import data
  importData(data) {
    try {
      Object.keys(data).forEach(key => {
        this.set(key, data[key]);
      });
      return true;
    } catch (error) {
      console.error('Error importing data:', error);
      return false;
    }
  }
}

// Create singleton instance
const storage = new StorageService();

export default storage;
</file>

<file path="src/services/trashService.js">
import storage from './storage';

/**
 * Trash Service - Handles soft deletion and recovery of transactions
 */

// Move item to trash (soft delete)
export const moveToTrash = async (type, id, reason = '') => {
  try {
    let item;
    if (type === 'expense') {
      const expenses = storage.get('expenses') || [];
      item = expenses.find(e => e.id === id);
      if (item) {
        // Remove from expenses
        storage.set('expenses', expenses.filter(e => e.id !== id));
      }
    } else if (type === 'income') {
      const income = storage.get('income') || [];
      item = income.find(i => i.id === id);
      if (item) {
        // Remove from income
        storage.set('income', income.filter(i => i.id !== id));
      }
    }

    if (!item) {
      return { success: false, error: 'アイテムが見つかりません' };
    }

    // Add to trash
    const trashItem = {
      ...item,
      originalType: type,
      deletedAt: new Date().toISOString(),
      deletedReason: reason,
      trashId: `trash_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    };

    const trash = storage.get('trash') || [];
    trash.push(trashItem);
    storage.set('trash', trash);

    return { success: true, data: trashItem };
  } catch (error) {
    console.error('Error moving to trash:', error);
    return { success: false, error: error.message };
  }
};

// Get all trash items
export const getAllTrash = async () => {
  try {
    const trash = storage.get('trash') || [];
    // Sort by deletion date (newest first)
    const sortedTrash = trash.sort((a, b) => new Date(b.deletedAt) - new Date(a.deletedAt));
    return { success: true, data: sortedTrash };
  } catch (error) {
    console.error('Error getting trash:', error);
    return { success: false, error: error.message };
  }
};

// Restore item from trash
export const restoreFromTrash = async (trashId) => {
  try {
    const trash = storage.get('trash') || [];
    const itemIndex = trash.findIndex(item => item.trashId === trashId);
    
    if (itemIndex === -1) {
      return { success: false, error: 'ゴミ箱にアイテムが見つかりません' };
    }

    const trashItem = trash[itemIndex];
    const { originalType, deletedAt, deletedReason, trashId: _, ...originalItem } = trashItem;

    // Restore to original collection
    if (originalType === 'expense') {
      const expenses = storage.get('expenses') || [];
      expenses.push(originalItem);
      storage.set('expenses', expenses);
    } else if (originalType === 'income') {
      const income = storage.get('income') || [];
      income.push(originalItem);
      storage.set('income', income);
    }

    // Remove from trash
    trash.splice(itemIndex, 1);
    storage.set('trash', trash);

    return { success: true, data: originalItem };
  } catch (error) {
    console.error('Error restoring from trash:', error);
    return { success: false, error: error.message };
  }
};

// Permanently delete item from trash
export const permanentlyDelete = async (trashId) => {
  try {
    const trash = storage.get('trash') || [];
    const filteredTrash = trash.filter(item => item.trashId !== trashId);
    
    if (filteredTrash.length === trash.length) {
      return { success: false, error: 'ゴミ箱にアイテムが見つかりません' };
    }

    storage.set('trash', filteredTrash);
    return { success: true };
  } catch (error) {
    console.error('Error permanently deleting:', error);
    return { success: false, error: error.message };
  }
};

// Empty trash (delete all)
export const emptyTrash = async () => {
  try {
    storage.set('trash', []);
    return { success: true };
  } catch (error) {
    console.error('Error emptying trash:', error);
    return { success: false, error: error.message };
  }
};

// Auto-cleanup old trash items (older than 30 days)
export const cleanupOldTrash = async (daysOld = 30) => {
  try {
    const trash = storage.get('trash') || [];
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);

    const filteredTrash = trash.filter(item => {
      const deletedDate = new Date(item.deletedAt);
      return deletedDate > cutoffDate;
    });

    storage.set('trash', filteredTrash);
    
    const deletedCount = trash.length - filteredTrash.length;
    return { 
      success: true, 
      data: { 
        deletedCount, 
        remainingCount: filteredTrash.length 
      } 
    };
  } catch (error) {
    console.error('Error cleaning up trash:', error);
    return { success: false, error: error.message };
  }
};

const trashService = {
  moveToTrash,
  getAllTrash,
  restoreFromTrash,
  permanentlyDelete,
  emptyTrash,
  cleanupOldTrash
};

export default trashService;
</file>

<file path="src/services/userService.js">
import storage from './storage';

/**
 * User Service - Handles all user-related operations
 */

// Validation helpers
const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePhone = (phone) => {
  if (!phone) return true; // Phone is optional
  const phoneRegex = /^[\d\-+()\\s]+$/;
  return phoneRegex.test(phone);
};

// Create a new user
export const createUser = async (userData) => {
  try {
    // Validate required fields
    if (!userData.name || !userData.email || !userData.department) {
      return { 
        success: false, 
        error: '名前、メールアドレス、部署は必須です。' 
      };
    }

    // Validate email
    if (!validateEmail(userData.email)) {
      return { 
        success: false, 
        error: '有効なメールアドレスを入力してください。' 
      };
    }

    // Validate phone if provided
    if (userData.phone && !validatePhone(userData.phone)) {
      return { 
        success: false, 
        error: '有効な電話番号を入力してください。' 
      };
    }

    // Check if email already exists
    const existingUser = storage.findWhere('users', { email: userData.email });
    if (existingUser.length > 0) {
      return { 
        success: false, 
        error: 'このメールアドレスは既に使用されています。' 
      };
    }

    // Create user
    const newUser = storage.addItem('users', {
      ...userData,
      status: userData.status || 'active',
      avatar: userData.avatar || null
    });

    // New users have no transactions
    const userWithTransactionData = {
      ...newUser,
      totalExpenses: 0,
      totalIncome: 0,
      transactionCount: 0,
      lastActivity: null,
      isActive: newUser.status === 'active'
    };

    return { success: true, data: userWithTransactionData };
  } catch (error) {
    console.error('Error creating user:', error);
    return { success: false, error: error.message };
  }
};

// Get user by ID
export const getUserById = async (id) => {
  try {
    const user = storage.findById('users', id);
    if (!user) {
      return { success: false, error: 'User not found' };
    }
    
    // Get user's expenses
    const expenses = storage.findWhere('expenses', { userId: user.id });
    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);
    
    // Get user's income
    const income = storage.findWhere('income', { userId: user.id });
    const totalIncome = income.reduce((sum, inc) => sum + inc.amount, 0);
    
    // Calculate transaction count
    const transactionCount = expenses.length + income.length;
    
    // Get last activity date
    const allTransactions = [...expenses, ...income];
    let lastActivity = null;
    if (allTransactions.length > 0) {
      const sortedTransactions = allTransactions.sort((a, b) => 
        new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt)
      );
      lastActivity = sortedTransactions[0].updatedAt || sortedTransactions[0].createdAt;
    }
    
    const userWithTransactionData = {
      ...user,
      totalExpenses,
      totalIncome,
      transactionCount,
      lastActivity,
      isActive: user.status === 'active'
    };
    
    return { success: true, data: userWithTransactionData };
  } catch (error) {
    console.error('Error getting user:', error);
    return { success: false, error: error.message };
  }
};

// Get all users
export const getAllUsers = async () => {
  try {
    const users = storage.get('users') || [];
    
    // Calculate transaction data for each user
    const usersWithTransactionData = users.map(user => {
      // Get user's expenses
      const expenses = storage.findWhere('expenses', { userId: user.id });
      const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);
      
      // Get user's income
      const income = storage.findWhere('income', { userId: user.id });
      const totalIncome = income.reduce((sum, inc) => sum + inc.amount, 0);
      
      // Calculate transaction count
      const transactionCount = expenses.length + income.length;
      
      // Get last activity date
      const allTransactions = [...expenses, ...income];
      let lastActivity = null;
      if (allTransactions.length > 0) {
        const sortedTransactions = allTransactions.sort((a, b) => 
          new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt)
        );
        lastActivity = sortedTransactions[0].updatedAt || sortedTransactions[0].createdAt;
      }
      
      return {
        ...user,
        totalExpenses,
        totalIncome,
        transactionCount,
        lastActivity,
        isActive: user.status === 'active'
      };
    });
    
    return { success: true, data: usersWithTransactionData };
  } catch (error) {
    console.error('Error getting users:', error);
    return { success: false, error: error.message };
  }
};

// Update user
export const updateUser = async (id, updates) => {
  try {
    // Validate email if updating
    if (updates.email && !validateEmail(updates.email)) {
      return { 
        success: false, 
        error: '有効なメールアドレスを入力してください。' 
      };
    }

    // Validate phone if updating
    if (updates.phone && !validatePhone(updates.phone)) {
      return { 
        success: false, 
        error: '有効な電話番号を入力してください。' 
      };
    }

    // Check if email already exists (excluding current user)
    if (updates.email) {
      const existingUser = storage.findWhere('users', { email: updates.email });
      if (existingUser.length > 0 && existingUser[0].id !== id) {
        return { 
          success: false, 
          error: 'このメールアドレスは既に使用されています。' 
        };
      }
    }

    const updatedUser = storage.updateItem('users', id, updates);
    
    // Get transaction data for the updated user
    const expenses = storage.findWhere('expenses', { userId: updatedUser.id });
    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);
    
    const income = storage.findWhere('income', { userId: updatedUser.id });
    const totalIncome = income.reduce((sum, inc) => sum + inc.amount, 0);
    
    const transactionCount = expenses.length + income.length;
    
    const allTransactions = [...expenses, ...income];
    let lastActivity = null;
    if (allTransactions.length > 0) {
      const sortedTransactions = allTransactions.sort((a, b) => 
        new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt)
      );
      lastActivity = sortedTransactions[0].updatedAt || sortedTransactions[0].createdAt;
    }
    
    const userWithTransactionData = {
      ...updatedUser,
      totalExpenses,
      totalIncome,
      transactionCount,
      lastActivity,
      isActive: updatedUser.status === 'active'
    };
    
    return { success: true, data: userWithTransactionData };
  } catch (error) {
    console.error('Error updating user:', error);
    return { success: false, error: error.message };
  }
};

// Delete user
export const deleteUser = async (id) => {
  try {
    // Check if user has any transactions
    const expenses = storage.findWhere('expenses', { userId: id });
    const income = storage.findWhere('income', { userId: id });
    
    if (expenses.length > 0 || income.length > 0) {
      return { 
        success: false, 
        error: 'このユーザーには取引記録があるため削除できません。' 
      };
    }
    
    storage.deleteItem('users', id);
    return { success: true };
  } catch (error) {
    console.error('Error deleting user:', error);
    return { success: false, error: error.message };
  }
};

// Toggle user active status
export const toggleUserActive = async (id) => {
  try {
    const user = storage.findById('users', id);
    if (!user) {
      return { success: false, error: 'ユーザーが見つかりません。' };
    }
    
    const newStatus = user.status === 'active' ? 'inactive' : 'active';
    const updatedUser = storage.updateItem('users', id, { status: newStatus });
    
    // Get transaction data for the updated user
    const expenses = storage.findWhere('expenses', { userId: updatedUser.id });
    const totalExpenses = expenses.reduce((sum, expense) => sum + expense.amount, 0);
    
    const income = storage.findWhere('income', { userId: updatedUser.id });
    const totalIncome = income.reduce((sum, inc) => sum + inc.amount, 0);
    
    const transactionCount = expenses.length + income.length;
    
    const allTransactions = [...expenses, ...income];
    let lastActivity = null;
    if (allTransactions.length > 0) {
      const sortedTransactions = allTransactions.sort((a, b) => 
        new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt)
      );
      lastActivity = sortedTransactions[0].updatedAt || sortedTransactions[0].createdAt;
    }
    
    const userWithTransactionData = {
      ...updatedUser,
      totalExpenses,
      totalIncome,
      transactionCount,
      lastActivity,
      isActive: updatedUser.status === 'active'
    };
    
    return { success: true, data: userWithTransactionData };
  } catch (error) {
    console.error('Error toggling user status:', error);
    return { success: false, error: error.message };
  }
};

// Get user statistics
export const getUserStats = async (userId) => {
  try {
    const expenses = storage.findWhere('expenses', { userId });
    const income = storage.findWhere('income', { userId });
    
    const expenseTotal = expenses.reduce((sum, item) => sum + item.amount, 0);
    const incomeTotal = income.reduce((sum, item) => sum + item.amount, 0);
    
    return {
      success: true,
      data: {
        expenseCount: expenses.length,
        expenseTotal,
        incomeCount: income.length,
        incomeTotal,
        totalTransactions: expenses.length + income.length,
        netAmount: incomeTotal - expenseTotal
      }
    };
  } catch (error) {
    console.error('Error getting user stats:', error);
    return { success: false, error: error.message };
  }
};

const userService = {
  createUser,
  getUserById,
  getAllUsers,
  updateUser,
  deleteUser,
  toggleUserActive,
  getUserStats
};

export default userService;
</file>

<file path="src/styles/animations.css">
/* Modern CSS Animations for ExpenceAtture */

/* Fade animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInLeft {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes fadeInRight {
  from {
    opacity: 0;
    transform: translateX(30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Scale animations */
@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

@keyframes heartbeat {
  0% {
    transform: scale(1);
  }
  14% {
    transform: scale(1.1);
  }
  28% {
    transform: scale(1);
  }
  42% {
    transform: scale(1.1);
  }
  56% {
    transform: scale(1);
  }
}

/* Rotation animations */
@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes rotateIn {
  from {
    opacity: 0;
    transform: rotate(-200deg);
  }
  to {
    opacity: 1;
    transform: rotate(0);
  }
}

/* Slide animations */
@keyframes slideInLeft {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideInUp {
  from {
    transform: translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes slideInDown {
  from {
    transform: translateY(-100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Bounce animations */
@keyframes bounce {
  0%, 20%, 50%, 80%, 100% {
    transform: translateY(0);
  }
  40% {
    transform: translateY(-30px);
  }
  60% {
    transform: translateY(-15px);
  }
}

@keyframes bounceIn {
  0% {
    opacity: 0;
    transform: scale(0.3);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
  }
  70% {
    transform: scale(0.9);
  }
  100% {
    transform: scale(1);
  }
}

/* Shake animation */
@keyframes shake {
  0%, 100% {
    transform: translateX(0);
  }
  10%, 30%, 50%, 70%, 90% {
    transform: translateX(-10px);
  }
  20%, 40%, 60%, 80% {
    transform: translateX(10px);
  }
}

/* Gradient animations */
@keyframes gradientShift {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

@keyframes gradientFlow {
  0% {
    background-position: 0% 0%;
  }
  50% {
    background-position: 100% 100%;
  }
  100% {
    background-position: 0% 0%;
  }
}

/* Shimmer effect */
@keyframes shimmer {
  0% {
    background-position: -1000px 0;
  }
  100% {
    background-position: 1000px 0;
  }
}

/* Glow animation */
@keyframes glow {
  0% {
    box-shadow: 0 0 5px rgba(102, 126, 234, 0.2);
  }
  50% {
    box-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 30px rgba(102, 126, 234, 0.6);
  }
  100% {
    box-shadow: 0 0 5px rgba(102, 126, 234, 0.2);
  }
}

/* Float animation */
@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

/* Wave animation */
@keyframes wave {
  0%, 100% {
    transform: rotate(0deg);
  }
  10% {
    transform: rotate(14deg);
  }
  20% {
    transform: rotate(-8deg);
  }
  30% {
    transform: rotate(14deg);
  }
  40% {
    transform: rotate(-4deg);
  }
  50% {
    transform: rotate(10deg);
  }
  60% {
    transform: rotate(0deg);
  }
}

/* Flip animation */
@keyframes flipIn {
  from {
    transform: perspective(400px) rotateY(90deg);
    opacity: 0;
  }
  to {
    transform: perspective(400px) rotateY(0deg);
    opacity: 1;
  }
}

/* Utility classes */
.animate-fade-in {
  animation: fadeIn 0.5s ease-out;
}

.animate-fade-in-up {
  animation: fadeInUp 0.6s ease-out;
}

.animate-fade-in-down {
  animation: fadeInDown 0.6s ease-out;
}

.animate-fade-in-left {
  animation: fadeInLeft 0.6s ease-out;
}

.animate-fade-in-right {
  animation: fadeInRight 0.6s ease-out;
}

.animate-scale-in {
  animation: scaleIn 0.5s ease-out;
}

.animate-pulse {
  animation: pulse 2s infinite;
}

.animate-heartbeat {
  animation: heartbeat 1.5s ease-in-out infinite;
}

.animate-rotate {
  animation: rotate 2s linear infinite;
}

.animate-bounce {
  animation: bounce 2s infinite;
}

.animate-shake {
  animation: shake 0.5s;
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

.animate-wave {
  animation: wave 2s ease-in-out infinite;
  transform-origin: 70% 70%;
}

.animate-shimmer {
  background: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0) 100%
  );
  background-size: 1000px 100%;
  animation: shimmer 2s infinite;
}

.animate-glow {
  animation: glow 2s ease-in-out infinite;
}

.animate-gradient-shift {
  background-size: 200% 200%;
  animation: gradientShift 5s ease infinite;
}

/* Hover animations */
.hover-grow {
  transition: transform 0.3s ease;
}
.hover-grow:hover {
  transform: scale(1.05);
}

.hover-shrink {
  transition: transform 0.3s ease;
}
.hover-shrink:hover {
  transform: scale(0.95);
}

.hover-rotate {
  transition: transform 0.3s ease;
}
.hover-rotate:hover {
  transform: rotate(5deg);
}

.hover-lift {
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}
.hover-lift:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

/* Glass morphism utilities */
.glass-effect {
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.18);
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
}

.glass-effect-dark {
  background: rgba(17, 25, 40, 0.25);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.125);
  box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
}

/* Smooth transitions */
.transition-all {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.transition-transform {
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.transition-opacity {
  transition: opacity 0.3s ease;
}

.transition-colors {
  transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}

/* Animation delays */
.delay-100 {
  animation-delay: 100ms;
}

.delay-200 {
  animation-delay: 200ms;
}

.delay-300 {
  animation-delay: 300ms;
}

.delay-400 {
  animation-delay: 400ms;
}

.delay-500 {
  animation-delay: 500ms;
}

/* Loading animations */
@keyframes loadingDots {
  0%, 80%, 100% {
    opacity: 0;
  }
  40% {
    opacity: 1;
  }
}

.loading-dots span {
  animation: loadingDots 1.4s infinite;
}

.loading-dots span:nth-child(2) {
  animation-delay: 0.2s;
}

.loading-dots span:nth-child(3) {
  animation-delay: 0.4s;
}

/* Skeleton loading effect */
@keyframes skeleton {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: calc(200px + 100%) 0;
  }
}

.skeleton {
  background-color: #e2e5e7;
  background-image: linear-gradient(
    90deg,
    #e2e5e7,
    #f0f0f0,
    #e2e5e7
  );
  background-size: 200px 100%;
  background-repeat: no-repeat;
  animation: skeleton 1.5s ease-in-out infinite;
}
</file>

<file path="src/theme/theme.js">
import { createTheme } from '@mui/material/styles';

// Beautiful color palette with gradients
const colors = {
  primary: {
    main: '#6366f1',
    light: '#818cf8',
    dark: '#4f46e5',
    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
  },
  secondary: {
    main: '#ec4899',
    light: '#f472b6',
    dark: '#db2777',
    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
  },
  success: {
    main: '#10b981',
    light: '#34d399',
    dark: '#059669',
    gradient: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
  },
  warning: {
    main: '#f59e0b',
    light: '#fbbf24',
    dark: '#d97706',
    gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
  },
  error: {
    main: '#ef4444',
    light: '#f87171',
    dark: '#dc2626',
    gradient: 'linear-gradient(135deg, #ff0844 0%, #ffb199 100%)',
  },
  background: {
    light: {
      default: '#f8fafc',
      paper: 'rgba(255, 255, 255, 0.8)',
      gradient: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
    },
    dark: {
      default: '#0f172a',
      paper: 'rgba(30, 41, 59, 0.8)',
      gradient: 'linear-gradient(135deg, #1e293b 0%, #334155 100%)',
    },
  },
  glass: {
    light: {
      background: 'rgba(255, 255, 255, 0.25)',
      border: 'rgba(255, 255, 255, 0.18)',
      shadow: '0 8px 32px 0 rgba(31, 38, 135, 0.15)',
    },
    dark: {
      background: 'rgba(17, 25, 40, 0.25)',
      border: 'rgba(255, 255, 255, 0.125)',
      shadow: '0 8px 32px 0 rgba(0, 0, 0, 0.37)',
    },
  },
};

// Create light theme
export const lightTheme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: colors.primary.main,
      light: colors.primary.light,
      dark: colors.primary.dark,
    },
    secondary: {
      main: colors.secondary.main,
      light: colors.secondary.light,
      dark: colors.secondary.dark,
    },
    success: {
      main: colors.success.main,
      light: colors.success.light,
      dark: colors.success.dark,
    },
    warning: {
      main: colors.warning.main,
      light: colors.warning.light,
      dark: colors.warning.dark,
    },
    error: {
      main: colors.error.main,
      light: colors.error.light,
      dark: colors.error.dark,
    },
    background: {
      default: colors.background.light.default,
      paper: colors.background.light.paper,
    },
    text: {
      primary: '#1e293b',
      secondary: '#64748b',
    },
  },
  typography: {
    fontFamily: '"Inter", "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    h1: {
      fontSize: '3.5rem',
      fontWeight: 700,
      letterSpacing: '-0.02em',
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2.5rem',
      fontWeight: 600,
      letterSpacing: '-0.01em',
      lineHeight: 1.3,
    },
    h3: {
      fontSize: '2rem',
      fontWeight: 600,
      letterSpacing: '-0.01em',
      lineHeight: 1.4,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 600,
      lineHeight: 1.5,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 600,
      lineHeight: 1.6,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 600,
      lineHeight: 1.7,
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.75,
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.7,
    },
    button: {
      textTransform: 'none',
      fontWeight: 600,
      letterSpacing: '0.02em',
    },
  },
  shape: {
    borderRadius: 16,
  },
  shadows: [
    'none',
    '0 2px 4px 0 rgba(0, 0, 0, 0.05)',
    '0 4px 8px 0 rgba(0, 0, 0, 0.05)',
    '0 8px 16px 0 rgba(0, 0, 0, 0.05)',
    '0 12px 24px 0 rgba(0, 0, 0, 0.05)',
    '0 16px 32px 0 rgba(0, 0, 0, 0.05)',
    '0 20px 40px 0 rgba(0, 0, 0, 0.05)',
    '0 24px 48px 0 rgba(0, 0, 0, 0.05)',
    '0 28px 56px 0 rgba(0, 0, 0, 0.05)',
    '0 32px 64px 0 rgba(0, 0, 0, 0.05)',
    '0 36px 72px 0 rgba(0, 0, 0, 0.05)',
    '0 40px 80px 0 rgba(0, 0, 0, 0.05)',
    '0 44px 88px 0 rgba(0, 0, 0, 0.05)',
    '0 48px 96px 0 rgba(0, 0, 0, 0.05)',
    '0 52px 104px 0 rgba(0, 0, 0, 0.05)',
    '0 56px 112px 0 rgba(0, 0, 0, 0.05)',
    '0 60px 120px 0 rgba(0, 0, 0, 0.05)',
    '0 64px 128px 0 rgba(0, 0, 0, 0.05)',
    '0 68px 136px 0 rgba(0, 0, 0, 0.05)',
    '0 72px 144px 0 rgba(0, 0, 0, 0.05)',
    '0 76px 152px 0 rgba(0, 0, 0, 0.05)',
    '0 80px 160px 0 rgba(0, 0, 0, 0.05)',
    '0 84px 168px 0 rgba(0, 0, 0, 0.05)',
    '0 88px 176px 0 rgba(0, 0, 0, 0.05)',
    '0 92px 184px 0 rgba(0, 0, 0, 0.05)',
  ],
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          padding: '10px 24px',
          fontSize: '0.875rem',
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
          '&:hover': {
            transform: 'translateY(-2px)',
            boxShadow: '0 8px 24px 0 rgba(0, 0, 0, 0.1)',
          },
        },
        contained: {
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0 8px 24px 0 rgba(0, 0, 0, 0.1)',
          },
        },
        containedPrimary: {
          background: colors.primary.gradient,
          '&:hover': {
            background: colors.primary.gradient,
            opacity: 0.9,
          },
        },
        containedSecondary: {
          background: colors.secondary.gradient,
          '&:hover': {
            background: colors.secondary.gradient,
            opacity: 0.9,
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
          backgroundColor: colors.glass.light.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          border: `1px solid ${colors.glass.light.border}`,
          boxShadow: colors.glass.light.shadow,
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 20,
          backgroundColor: colors.glass.light.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          border: `1px solid ${colors.glass.light.border}`,
          boxShadow: colors.glass.light.shadow,
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: '0 12px 48px 0 rgba(31, 38, 135, 0.2)',
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: colors.glass.light.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          borderBottom: `1px solid ${colors.glass.light.border}`,
          boxShadow: 'none',
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: colors.glass.light.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          borderRight: `1px solid ${colors.glass.light.border}`,
          boxShadow: colors.glass.light.shadow,
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 12,
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-1px)',
              boxShadow: '0 4px 12px 0 rgba(0, 0, 0, 0.05)',
            },
            '&.Mui-focused': {
              transform: 'translateY(-1px)',
              boxShadow: '0 4px 12px 0 rgba(99, 102, 241, 0.1)',
            },
          },
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          fontWeight: 600,
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
          '&:hover': {
            transform: 'scale(1.05)',
          },
        },
      },
    },
  },
});

// Create dark theme
export const darkTheme = createTheme({
  ...lightTheme,
  palette: {
    mode: 'dark',
    primary: {
      main: colors.primary.light,
      light: colors.primary.main,
      dark: colors.primary.dark,
    },
    secondary: {
      main: colors.secondary.light,
      light: colors.secondary.main,
      dark: colors.secondary.dark,
    },
    success: {
      main: colors.success.light,
      light: colors.success.main,
      dark: colors.success.dark,
    },
    warning: {
      main: colors.warning.light,
      light: colors.warning.main,
      dark: colors.warning.dark,
    },
    error: {
      main: colors.error.light,
      light: colors.error.main,
      dark: colors.error.dark,
    },
    background: {
      default: colors.background.dark.default,
      paper: colors.background.dark.paper,
    },
    text: {
      primary: '#f1f5f9',
      secondary: '#94a3b8',
    },
  },
  components: {
    ...lightTheme.components,
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
          backgroundColor: colors.glass.dark.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          border: `1px solid ${colors.glass.dark.border}`,
          boxShadow: colors.glass.dark.shadow,
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 20,
          backgroundColor: colors.glass.dark.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          border: `1px solid ${colors.glass.dark.border}`,
          boxShadow: colors.glass.dark.shadow,
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: '0 12px 48px 0 rgba(0, 0, 0, 0.5)',
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: colors.glass.dark.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          borderBottom: `1px solid ${colors.glass.dark.border}`,
          boxShadow: 'none',
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: colors.glass.dark.background,
          backdropFilter: 'blur(20px)',
          WebkitBackdropFilter: 'blur(20px)',
          borderRight: `1px solid ${colors.glass.dark.border}`,
          boxShadow: colors.glass.dark.shadow,
        },
      },
    },
  },
});

// Export theme utilities
export const getGradient = (color) => colors[color]?.gradient || colors.primary.gradient;
export const getGlassStyle = (mode) => colors.glass[mode] || colors.glass.light;
</file>

<file path="src/utils/formatters.js">
/**
 * Format large numbers with abbreviations (K, M, B)
 * @param {number} num - The number to format
 * @param {number} digits - Number of decimal places (default: 1)
 * @returns {string} Formatted number string
 */
export const formatLargeNumber = (num, digits = 1) => {
  if (!num || isNaN(num)) return '0';
  
  const si = [
    { value: 1E9, symbol: 'B' },
    { value: 1E6, symbol: 'M' },
    { value: 1E3, symbol: 'K' }
  ];
  
  for (let i = 0; i < si.length; i++) {
    if (num >= si[i].value) {
      return (num / si[i].value).toFixed(digits).replace(/\.0+$/, '') + si[i].symbol;
    }
  }
  
  return num.toString();
};

/**
 * Format currency with proper Japanese formatting
 * @param {number} amount - The amount to format
 * @param {boolean} abbreviated - Whether to abbreviate large numbers
 * @returns {string} Formatted currency string
 */
export const formatCurrency = (amount, abbreviated = false) => {
  if (!amount || isNaN(amount)) return '¥0';
  
  if (abbreviated && Math.abs(amount) >= 10000) {
    return `¥${formatLargeNumber(amount)}`;
  }
  
  return `¥${amount.toLocaleString('ja-JP')}`;
};

/**
 * Format percentage with proper decimal places
 * @param {number} value - The percentage value
 * @param {number} digits - Number of decimal places (default: 1)
 * @returns {string} Formatted percentage string
 */
export const formatPercentage = (value, digits = 1) => {
  if (!value || isNaN(value)) return '0%';
  return `${value.toFixed(digits)}%`;
};

/**
 * Format date according to user's date format settings
 * @param {Date|string} date - The date to format
 * @param {string} dateFormat - The date format setting (e.g., 'YYYY-MM-DD', 'MM/DD/YYYY', etc.)
 * @returns {string} Formatted date string
 */
export const formatDate = (date, dateFormat = 'YYYY-MM-DD') => {
  if (!date) return '';
  
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  
  if (isNaN(dateObj.getTime())) return '';
  
  const year = dateObj.getFullYear();
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const day = dateObj.getDate().toString().padStart(2, '0');
  
  switch (dateFormat) {
    case 'YYYY-MM-DD':
      return `${year}-${month}-${day}`;
    
    case 'MM/DD/YYYY':
      return `${month}/${day}/${year}`;
    
    case 'DD/MM/YYYY':
      return `${day}/${month}/${year}`;
    
    case 'YYYY年MM月DD日':
      return `${year}年${month}月${day}日`;
    
    case 'MM月DD日, YYYY年':
      return `${month}月${day}日, ${year}年`;
    
    default:
      // Fallback to ISO format
      return `${year}-${month}-${day}`;
  }
};
</file>

<file path="src/utils/imagePreprocessing.js">
/**
 * Image preprocessing utilities for better OCR results
 */

/**
 * Preprocess image for better OCR recognition
 * @param {File|Blob} imageFile - The image file to preprocess
 * @returns {Promise<Blob>} - The preprocessed image
 */
export const preprocessImage = async (imageFile) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const img = new Image();
      
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Scale image if too large (max 2000px width)
        let width = img.width;
        let height = img.height;
        const maxWidth = 2000;
        
        if (width > maxWidth) {
          height = (maxWidth / width) * height;
          width = maxWidth;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        // Draw image
        ctx.drawImage(img, 0, 0, width, height);
        
        // Get image data
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // Convert to grayscale and increase contrast
        for (let i = 0; i < data.length; i += 4) {
          // Convert to grayscale
          const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
          
          // Increase contrast
          let value = gray;
          value = ((value - 128) * 1.5) + 128; // 1.5 is contrast factor
          value = Math.max(0, Math.min(255, value));
          
          // Apply threshold for better text recognition
          // This helps with receipts that might have poor lighting
          if (value > 180) {
            value = 255; // White
          } else if (value < 80) {
            value = 0; // Black
          }
          
          data[i] = value;
          data[i + 1] = value;
          data[i + 2] = value;
        }
        
        // Put the processed image data back
        ctx.putImageData(imageData, 0, 0);
        
        // Convert canvas to blob
        canvas.toBlob((blob) => {
          resolve(blob);
        }, 'image/png', 0.95);
      };
      
      img.onerror = reject;
      img.src = e.target.result;
    };
    
    reader.onerror = reject;
    reader.readAsDataURL(imageFile);
  });
};

/**
 * Check if image needs preprocessing based on basic analysis
 * @param {File|Blob} imageFile - The image file to check
 * @returns {Promise<boolean>} - Whether preprocessing is recommended
 */
export const needsPreprocessing = async (imageFile) => {
  return new Promise((resolve) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const img = new Image();
      
      img.onload = () => {
        // Check if image is too large
        if (img.width > 2000 || img.height > 2000) {
          resolve(true);
          return;
        }
        
        // For now, always recommend preprocessing for receipts
        resolve(true);
      };
      
      img.onerror = () => resolve(false);
      img.src = e.target.result;
    };
    
    reader.onerror = () => resolve(false);
    reader.readAsDataURL(imageFile);
  });
};
</file>

<file path="src/App.js">
import React, { useState } from 'react';
import { HashRouter as Router, Routes, Route } from 'react-router-dom';
import { ThemeProvider, CssBaseline, Box } from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { Chart as ChartJS, registerables } from 'chart.js';
import { ja } from 'date-fns/locale';

// Import custom theme and components
import { lightTheme, darkTheme } from './theme/theme';
import Sidebar from './components/Navigation/Sidebar';
import './styles/animations.css';

// Import pages
import Dashboard from './pages/Dashboard';
import Registration from './pages/Registration';
import TransactionList from './pages/TransactionList';
import TrashManagement from './pages/TrashManagement';
import Analytics from './pages/Analytics';
import Settings from './pages/Settings';
import Invoices from './pages/Invoices';
import Notifications from './pages/Notifications';
import Users from './pages/Users';

// Register Chart.js components
ChartJS.register(...registerables);

function App() {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [themeMode, setThemeMode] = useState(() => {
    return localStorage.getItem('themeMode') || 'light';
  });

  // Storage is automatically initialized when imported

  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen);
  };

  const toggleTheme = () => {
    const newMode = themeMode === 'light' ? 'dark' : 'light';
    setThemeMode(newMode);
    localStorage.setItem('themeMode', newMode);
  };

  const currentTheme = themeMode === 'light' ? lightTheme : darkTheme;

  return (
    <Router>
      <ThemeProvider theme={currentTheme}>
        <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ja}>
          <CssBaseline />
          <Box sx={{ display: 'flex', minHeight: '100vh' }}>
            {/* Sidebar */}
            <Sidebar
              open={sidebarOpen}
              onToggle={toggleSidebar}
              themeMode={themeMode}
              onToggleTheme={toggleTheme}
            />

            {/* Main Content */}
            <Box
              component="main"
              sx={{
                flexGrow: 1,
                p: 3,
                marginLeft: 0,
                transition: 'margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
                background: currentTheme.palette.mode === 'dark'
                  ? 'linear-gradient(135deg, #1e293b 0%, #334155 100%)'
                  : 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
                minHeight: '100vh',
              }}
            >
              <Routes>
                <Route path="/" element={<Dashboard />} />
                <Route path="/registration" element={<Registration />} />
                <Route path="/transactions" element={<TransactionList />} />
                <Route path="/trash" element={<TrashManagement />} />
                <Route path="/users" element={<Users />} />
                <Route path="/analytics" element={<Analytics />} />
                <Route path="/invoices" element={<Invoices />} />
                <Route path="/notifications" element={<Notifications />} />
                <Route path="/settings" element={<Settings />} />
                {/* Redirect any unknown routes to dashboard */}
                <Route path="*" element={<Dashboard />} />
              </Routes>
            </Box>
          </Box>
        </LocalizationProvider>
      </ThemeProvider>
    </Router>
  );
}

export default App;
</file>

<file path="src/index.css">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

* {
  box-sizing: border-box;
}

/* Custom scrollbar for webkit browsers */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}
</file>

<file path="src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build
/dist

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Electron
/out
/electron-builder.yml

# IDE
.idea
.vscode
*.swp
*.swo
*~

# OS
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Compiled binary addons
build/Release

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# Electron Builder
dist_electron/
installBuilds/

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini
</file>

<file path="ICON_SETUP.md">
# アイコン設定ガイド

このドキュメントでは、Electron アプリケーションのビルド時に必要なアイコンファイルの配置について説明します。

## 必要なアイコンファイル

### 1. アプリケーションアイコン

Electron アプリケーションでは、各プラットフォーム用に異なる形式のアイコンが必要です：

- **Windows**: `.ico` ファイル
- **macOS**: `.icns` ファイル
- **Linux**: `.png` ファイル

### 2. アイコンファイルの配置場所

プロジェクトのルートディレクトリに `assets` フォルダを作成し、以下のファイルを配置してください：

```
AttureExpence/
├── assets/
│   ├── icon.ico     # Windows用アイコン (最低256x256px推奨)
│   ├── icon.icns    # macOS用アイコン
│   └── icon.png     # Linux用アイコン (512x512px推奨)
├── public/
│   ├── favicon.ico  # ブラウザタブ用アイコン
│   └── logo192.png  # PWA用アイコン
│   └── logo512.png  # PWA用アイコン
└── ...
```

**重要**: `assets`フォルダは`build`フォルダと違い、ビルド時に上書きされないため、アイコンファイルが安全に保持されます。

### 3. アイコンサイズの推奨仕様

#### Windows (.ico)
- 16x16, 32x32, 48x48, 256x256 ピクセルを含む
- 256色以上推奨

#### macOS (.icns)
- 16x16, 32x32, 64x64, 128x128, 256x256, 512x512, 1024x1024 ピクセルを含む

#### Linux (.png)
- 512x512 ピクセル推奨

### 4. アイコンの作成方法

#### オンラインツール
1. **CloudConvert**: https://cloudconvert.com/
   - PNG から ICO/ICNS への変換が可能

2. **ICO Convert**: https://icoconvert.com/
   - PNG から ICO への変換専用

3. **Image2icon**: http://www.img2icnsapp.com/
   - macOS用、PNG から ICNS への変換

#### コマンドラインツール

**electron-icon-builder** を使用する場合：
```bash
npm install --save-dev electron-icon-builder
```

元画像（1024x1024px の PNG）を `assets/icon.png` として配置し、以下を実行：
```bash
npx electron-icon-builder --input=assets/icon.png --output=assets
```

### 5. package.json の設定

```json
{
  "build": {
    "appId": "com.atture.expence",
    "productName": "AttureExpence",
    "directories": {
      "output": "release"
    },
    "mac": {
      "icon": "assets/icon.icns",
      "category": "public.app-category.finance"
    },
    "win": {
      "icon": "assets/icon.ico"
    },
    "linux": {
      "icon": "assets/icon.png",
      "category": "Office"
    }
  }
}
```

### 6. ビルドコマンド

アイコンファイルを配置した後、以下のコマンドでビルドします：

```bash
# Windows用
npm run build:win

# macOS用
npm run build:mac

# Linux用
npm run build:linux

# 全プラットフォーム
npm run build:all
```

### 7. トラブルシューティング

#### アイコンが表示されない場合
1. ファイル名が正確か確認（大文字小文字に注意）
2. ファイル形式が正しいか確認
3. `node_modules` と `dist` フォルダを削除して再ビルド

#### macOS でアイコンが更新されない場合
```bash
# アイコンキャッシュをクリア
sudo rm -rf /Library/Caches/com.apple.iconservices.store
killall Dock
```

### 8. 追加のアイコン設定

#### メニューバーアイコン（macOS）
`build/` に以下を追加：
- `trayIcon.png` (16x16)
- `trayIcon@2x.png` (32x32)

#### 通知アイコン
`build/` に以下を追加：
- `notification.png` (256x256)

## ビルド状況

✅ **ビルド設定完了**: package.json の設定は正常に動作します
✅ **プレースホルダーアイコン作成済み**: 基本的なアイコンファイルが `assets/` に配置されています
✅ **ESLint警告修正済み**: 主要な未使用インポートエラーを修正済み

### ビルド結果の確認方法

```bash
# macOS用ビルド結果（releaseフォルダに出力）
release/AttureExpence-1.0.0-arm64.dmg        # インストーラー
release/AttureExpence-1.0.0-arm64-mac.zip    # ポータブル版
release/mac-arm64/AttureExpence.app/          # アプリケーション

# アプリケーションを直接実行
open release/mac-arm64/AttureExpence.app/

# 古いビルドファイルをクリーンアップ
npm run clean
```

### 現在の警告について

以下の警告は機能に影響しませんが、今後改善可能です：
- コード署名証明書がない警告（配布時に必要）
- いくつかのReact Hooks依存関係の警告
- 未使用のインポート（残り分）

## まとめ

1. **現在の状態**: ビルドは成功し、実行可能なアプリケーションが生成されています
2. **アイコンの改善**: `assets/` フォルダのプレースホルダーアイコンを高品質なものに置き換えてください
3. **ビルドコマンド**: `npm run build:mac`, `npm run build:win`, `npm run build:linux` が使用可能
4. **配布可能**: `release/` フォルダにDMGファイルとZIPファイルが出力され、ユーザーに配布可能な状態です

これらの手順に従うことで、各プラットフォームで適切なアイコンが表示され、プロフェッショナルなアプリケーションを配布できます。
</file>

<file path="main.js">
const { app, BrowserWindow, Menu } = require('electron');
const path = require('path');

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    minWidth: 800,
    minHeight: 600,
    title: 'Expan - 経費・収入管理',
    titleBarStyle: 'default',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      enableRemoteModule: false,
      webSecurity: false, // Temporarily disabled to allow Tesseract.js to load language files
      preload: path.join(__dirname, 'preload.js')
    },
    show: false // Don't show until ready
  });

  // Load the app
  const isDev = process.env.ELECTRON_START_URL;
  const startUrl = isDev ? process.env.ELECTRON_START_URL : `file://${path.join(__dirname, 'build/index.html')}`;
  
  mainWindow.loadURL(startUrl);

  // Show window when ready
  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
    
    // Open DevTools in development
    if (isDev) {
      mainWindow.webContents.openDevTools();
    }
  });

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

// Create app menu
function createMenu() {
  const template = [
    {
      label: 'ファイル',
      submenu: [
        {
          label: '新規経費',
          accelerator: 'CmdOrCtrl+N',
          click: () => {
            mainWindow.webContents.send('menu-new-expense');
          }
        },
        { type: 'separator' },
        {
          label: '終了',
          accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
          click: () => {
            app.quit();
          }
        }
      ]
    },
    {
      label: '編集',
      submenu: [
        { label: '元に戻す', accelerator: 'CmdOrCtrl+Z', role: 'undo' },
        { label: 'やり直し', accelerator: 'Shift+CmdOrCtrl+Z', role: 'redo' },
        { type: 'separator' },
        { label: '切り取り', accelerator: 'CmdOrCtrl+X', role: 'cut' },
        { label: 'コピー', accelerator: 'CmdOrCtrl+C', role: 'copy' },
        { label: '貼り付け', accelerator: 'CmdOrCtrl+V', role: 'paste' }
      ]
    },
    {
      label: '表示',
      submenu: [
        { label: '再読み込み', accelerator: 'CmdOrCtrl+R', role: 'reload' },
        { label: '強制再読み込み', accelerator: 'CmdOrCtrl+Shift+R', role: 'forceReload' },
        { label: '開発者ツール', accelerator: 'F12', role: 'toggleDevTools' },
        { type: 'separator' },
        { label: '実際のサイズ', accelerator: 'CmdOrCtrl+0', role: 'resetZoom' },
        { label: '拡大', accelerator: 'CmdOrCtrl+Plus', role: 'zoomIn' },
        { label: '縮小', accelerator: 'CmdOrCtrl+-', role: 'zoomOut' },
        { type: 'separator' },
        { label: 'フルスクリーン', role: 'togglefullscreen' }
      ]
    },
    {
      label: 'ウィンドウ',
      submenu: [
        { label: '最小化', accelerator: 'CmdOrCtrl+M', role: 'minimize' },
        { label: '閉じる', accelerator: 'CmdOrCtrl+W', role: 'close' }
      ]
    }
  ];

  if (process.platform === 'darwin') {
    template.unshift({
      label: app.getName(),
      submenu: [
        { label: `${app.getName()}について`, role: 'about' },
        { type: 'separator' },
        { label: '環境設定', accelerator: 'Cmd+,', click: () => { mainWindow.webContents.send('menu-preferences'); } },
        { type: 'separator' },
        { label: 'サービス', role: 'services', submenu: [] },
        { type: 'separator' },
        { label: `${app.getName()}を隠す`, accelerator: 'Cmd+H', role: 'hide' },
        { label: 'その他を隠す', accelerator: 'Cmd+Shift+H', role: 'hideothers' },
        { label: 'すべてを表示', role: 'unhide' },
        { type: 'separator' },
        { label: '終了', accelerator: 'Cmd+Q', click: () => { app.quit(); } }
      ]
    });
  }

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
}

app.whenReady().then(() => {
  createWindow();
  createMenu();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
</file>

<file path="NAVIGATION_README.md">
# AttureExpence Navigation System

## Overview
A complete navigation system with routing and beautiful page components has been implemented with the following features:

## 🚀 Features

### Navigation Components
- **Enhanced Sidebar** with animated navigation items
- **Active state indicators** with gradient backgrounds
- **Smooth hover effects** and icon animations
- **Collapse/expand functionality** with responsive design
- **Theme toggle** integrated into sidebar
- **User profile section** with status indicators

### Page Components
1. **Dashboard** (`/`) - Beautiful dashboard with statistics cards and charts
2. **Registration** (`/registration`) - Expense/Income registration form page with tabs
3. **Analytics** (`/analytics`) - Data visualization and analytics page with multiple chart types
4. **Settings** (`/settings`) - Settings and configuration page with comprehensive options
5. **Users** (`/users`) - User management page with search, filters, and detailed user profiles

### Router & Transitions
- **React Router** implementation with animated page transitions
- **Custom transition hook** (`usePageTransition.js`) for smooth animations
- **Route-based animations** with different effects per page
- **Loading states** during transitions

## 🎨 Design Features

### Sidebar Navigation
- **Collapsible design** (280px expanded, 80px collapsed)
- **Gradient backgrounds** for active states
- **Icon animations** on hover (360° rotation)
- **Smooth transitions** with cubic-bezier easing
- **Tooltip support** when collapsed
- **Sub-menu support** with expand/collapse animations

### Page Transitions
- **Fade effects** for dashboard
- **Slide animations** for registration and settings
- **Scale effects** for user management
- **Rotate effects** for analytics
- **Staggered animations** for content elements

### Visual Enhancements
- **Glass morphism** design language
- **Gradient backgrounds** and text effects
- **Motion animations** using Framer Motion
- **Responsive design** for different screen sizes
- **Dark/Light theme** support

## 🛠 Technical Implementation

### File Structure
```
src/
├── components/
│   └── Navigation/
│       └── Sidebar.js           # Enhanced sidebar component
├── pages/
│   ├── Dashboard.js             # Main dashboard page
│   ├── Registration.js          # Expense/Income registration
│   ├── Analytics.js             # Data analytics and reports
│   ├── Settings.js              # Application settings
│   └── Users.js                 # User management
├── hooks/
│   └── usePageTransition.js     # Page transition hook
└── App.js                       # Updated with React Router
```

### Key Technologies
- **React Router DOM** v6+ for routing
- **Framer Motion** for animations
- **Material-UI** for components and theming
- **Date-fns** for date handling
- **Chart.js** for data visualization

### Navigation Menu Items
```javascript
const menuItems = [
  {
    text: 'ダッシュボード',
    path: '/',
    icon: <DashboardIcon />,
    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
  },
  {
    text: '収支登録',
    path: '/registration',
    icon: <AddIcon />,
    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
    subItems: [
      { text: '支出登録', path: '/registration?tab=expense' },
      { text: '収入登録', path: '/registration?tab=income' },
    ],
  },
  // ... more items
];
```

## 🎯 Usage

### Running the Application
```bash
# Install dependencies
npm install

# Start development server
npm start

# Build for production
npm run build
```

### Navigation Features
1. **Click menu items** to navigate between pages
2. **Use the collapse button** to toggle sidebar width
3. **Theme toggle** available in sidebar footer
4. **Sub-menus** expand/collapse with animation
5. **Active page** highlighted with gradient background

### Page-Specific Features

#### Dashboard
- Real-time statistics cards
- Interactive charts and graphs
- Recent transactions list
- Monthly progress indicators

#### Registration
- Tabbed interface (Income/Expense)
- Form validation and auto-completion
- File upload for receipts
- Category suggestions
- User assignment

#### Analytics
- Multiple chart types (Bar, Line, Doughnut, Radar)
- Date range filtering
- Export functionality
- Performance comparisons

#### Settings
- Theme and appearance settings
- Category management
- User management
- API configuration
- Data backup/restore

#### Users
- User search and filtering
- Role-based permissions
- Activity tracking
- Profile management

## 🔧 Customization

### Adding New Pages
1. Create page component in `src/pages/`
2. Add route to `App.js`
3. Add menu item to `Sidebar.js`
4. Configure transition in `usePageTransition.js`

### Customizing Animations
- Modify `pageVariants` in `usePageTransition.js`
- Adjust transition durations and easing
- Add custom animation variants

### Theming
- Update gradients in menu items
- Modify theme colors in `theme/theme.js`
- Customize glass card effects

## 📱 Responsive Design
- **Desktop**: Full sidebar with text and icons
- **Tablet**: Collapsible sidebar with hover tooltips
- **Mobile**: Overlay sidebar with backdrop

## 🎨 Animation Details
- **Page transitions**: 300ms with cubic-bezier easing
- **Sidebar collapse**: 300ms smooth transition
- **Icon rotations**: 500ms on hover
- **Staggered content**: 100ms delay between items
- **Loading states**: Skeleton animations during transitions

The navigation system provides an intuitive, beautiful, and performant user experience with smooth animations and comprehensive functionality for the expense management application.
</file>

<file path="package.json">
{
  "name": "attureexpence",
  "version": "1.0.0",
  "description": "Expense tracking application with Electron, React, and Material UI",
  "main": "main.js",
  "scripts": {
    "start": "concurrently \"npm run react-start\" \"wait-on http://localhost:3002 && ELECTRON_START_URL=http://localhost:3002 electron .\"",
    "react-start": "BROWSER=none PORT=3002 react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "electron": "electron .",
    "electron-dev": "ELECTRON_START_URL=http://localhost:3000 electron .",
    "electron-build": "npm run build && electron-builder",
    "dist": "electron-builder",
    "build:win": "npm run build && electron-builder --win",
    "build:mac": "npm run build && electron-builder --mac",
    "build:linux": "npm run build && electron-builder --linux",
    "build:all": "npm run build && electron-builder -mwl",
    "clean": "rm -rf dist release build"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "concurrently": "^8.2.2",
    "electron": "^28.1.0",
    "electron-builder": "^24.9.1",
    "wait-on": "^7.2.0"
  },
  "dependencies": {
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.15.3",
    "@mui/material": "^5.15.3",
    "@mui/x-date-pickers": "^6.20.2",
    "chart.js": "^4.4.1",
    "date-fns": "^2.30.0",
    "dexie": "^3.2.4",
    "dexie-react-hooks": "^1.1.7",
    "electron-store": "^10.0.1",
    "framer-motion": "^10.16.16",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.6.1",
    "react-scripts": "5.0.1",
    "tesseract.js": "^6.0.1"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ],
    "rules": {
      "react-hooks/exhaustive-deps": "warn"
    }
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "build": {
    "appId": "com.attureexpence.app",
    "productName": "AttureExpence",
    "directories": {
      "output": "release"
    },
    "files": [
      "build/**/*",
      "main.js",
      "preload.js",
      "node_modules/**/*",
      "!node_modules/*/{test,__tests__,tests,powered-test,example,examples}",
      "!node_modules/.bin",
      "!**/*.{iml,o,hprof,orig,pyc,pyo,rbc,swp,csproj,sln,xproj}",
      "!.editorconfig",
      "!**/._*",
      "!**/{.DS_Store,.git,.hg,.svn,CVS,RCS,SCCS,.gitignore,.gitattributes}",
      "!**/{__pycache__,thumbs.db,.flowconfig,.idea,.vs,.nyc_output}",
      "!**/{appveyor.yml,.travis.yml,circle.yml}",
      "!**/{npm-debug.log,yarn.lock,.yarn-integrity,.yarn-metadata.json}"
    ],
    "extends": null,
    "mac": {
      "category": "public.app-category.finance",
      "icon": "assets/icon.icns"
    },
    "win": {
      "target": "nsis",
      "icon": "assets/icon.ico"
    },
    "linux": {
      "target": "AppImage",
      "icon": "assets/icon.png",
      "category": "Office"
    }
  },
  "homepage": "./"
}
</file>

<file path="preload.js">
const { contextBridge, ipcRenderer } = require('electron');

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld('electronAPI', {
  // Send messages to main process
  send: (channel, data) => {
    const validChannels = ['menu-new-expense', 'menu-preferences'];
    if (validChannels.includes(channel)) {
      ipcRenderer.send(channel, data);
    }
  },
  
  // Receive messages from main process
  receive: (channel, func) => {
    const validChannels = ['menu-new-expense', 'menu-preferences'];
    if (validChannels.includes(channel)) {
      // Deliberately strip event as it includes `sender` 
      ipcRenderer.on(channel, (event, ...args) => func(...args));
    }
  },
  
  // Remove listeners
  removeAllListeners: (channel) => {
    const validChannels = ['menu-new-expense', 'menu-preferences'];
    if (validChannels.includes(channel)) {
      ipcRenderer.removeAllListeners(channel);
    }
  },

  // Platform information
  platform: process.platform,
  
  // File operations (if needed in the future)
  fileOperations: {
    // Add file operations here if needed
  }
});
</file>

<file path="README.md">
# Expan - 経費・収入管理デスクトップアプリ

合同会社Atture向け経費・収入管理デスクトップアプリケーション

## 🚀 特徴

- **Electron + React + Material UI** を使用したモダンなデスクトップアプリ
- **ガラスモーフィズムデザイン** で美しいユーザーインターフェース
- **AI統合** による自動カテゴリ分類機能
- **ローカルデータベース** でセキュアなデータ管理
- **リアルタイム分析** とインタラクティブなチャート

## 📋 主な機能

### 💼 ユーザー・関係者管理
- ユーザープロファイルの登録・編集・削除
- 役割と部署の管理
- ユーザー別支出統計

### 💰 経費・収入登録
- 直感的な登録フォーム
- AI による自動カテゴリ分類
- レシート画像のアップロードと管理
- 立て替え申請機能

### 📊 分析・可視化
- リアルタイム財務ダッシュボード
- インタラクティブなチャート（円グラフ、棒グラフ、線グラフ）
- ユーザー別・部署別ランキング
- 高度なフィルタリング機能

### ⚙️ 設定・カスタマイズ
- ライト/ダークテーマ切り替え
- カスタムカラーテーマ
- カテゴリ管理
- ChatGPT API統合設定
- データインポート・エクスポート

## 🛠️ 技術スタック

- **フロントエンド**: React 18, Material-UI 5, Framer Motion
- **デスクトップ**: Electron 28
- **データベース**: Dexie.js (IndexedDB)
- **チャート**: Chart.js, react-chartjs-2
- **デザイン**: Glassmorphism, CSS-in-JS
- **ルーティング**: React Router DOM

## 📦 インストールと実行

### 必要な環境
- Node.js 16+ 
- npm または yarn

### セットアップ
```bash
# 依存関係のインストール
npm install

# 開発サーバーの起動（Electronデスクトップアプリとして）
npm start

# プロダクション用ビルド
npm run build

# Electronアプリのパッケージ化
npm run electron-build
```

### スクリプト説明
- `npm start` - 開発用Electronアプリの起動（推奨）
- `npm run react-start` - Reactのみの開発サーバー
- `npm run electron` - ビルド済みアプリでElectronを起動
- `npm run build` - プロダクション用ビルド
- `npm run electron-build` - Electronアプリのパッケージ化

## 🎨 デザインシステム

### ガラスモーフィズム
- 透明度とブラー効果を使用した美しいガラス風デザイン
- 滑らかなアニメーションとトランジション
- カスタムグラデーションとシャドウ効果

### カラーパレット
- **プライマリ**: グラデーション（紫 → 青）
- **セカンダリ**: グラデーション（ピンク → オレンジ）
- **成功**: グラデーション（緑 → 青緑）
- **警告**: グラデーション（オレンジ → 赤）

## 📁 プロジェクト構造

```
src/
├── components/           # 再利用可能なコンポーネント
│   ├── Analytics/       # 分析関連コンポーネント
│   ├── Layout/          # レイアウトコンポーネント
│   ├── Navigation/      # ナビゲーションコンポーネント
│   ├── Registration/    # 登録フォームコンポーネント
│   ├── Settings/        # 設定関連コンポーネント
│   ├── UserManagement/  # ユーザー管理コンポーネント
│   └── common/          # 共通コンポーネント
├── db/                  # データベース関連
│   └── services/        # データサービス層
├── hooks/               # カスタムフック
├── pages/               # ページコンポーネント
├── services/            # 外部サービス（AI等）
├── styles/              # スタイルファイル
└── theme/               # テーマ設定
```

## 🔐 セキュリティ

- ローカルデータベースによるデータ保護
- ChatGPT APIキーの安全な管理
- contextIsolation有効化によるセキュリティ強化
- nodeIntegration無効化

## 🌟 AI機能

### 自動カテゴリ分類
- 経費内容からのインテリジェントなカテゴリ提案
- ユーザーの選択から学習する適応型システム
- カスタムカテゴリの作成と管理

### 将来の拡張予定
- OCR による領収書テキスト抽出
- 支出パターン分析
- 予算提案機能

## 🔧 開発者向け情報

### 環境変数
- `ELECTRON_START_URL` - 開発時のElectronスタートURL
- `BROWSER=none` - ブラウザの自動起動を無効化

### ビルド設定
- `homepage: "./"` - 相対パスでの動作
- Electron Builder設定済み（macOS/Windows/Linux対応）

## 📄 ライセンス

MIT License - 詳細は LICENSE ファイルを参照

## 🤝 貢献

プルリクエストや Issue の報告を歓迎します。

---

**開発者**: Claude Code Assistant  
**バージョン**: 1.0.0  
**最終更新**: 2025年5月29日
</file>

<file path="task.md">
# プロンプト：合同会社Atture(基本一人経営) 経費・収入管理デスクトップアプリの開発

## 開発環境
- Electron + React + Material UI を用いたモダンなデスクトップアプリ
- Mac上で動作（M1/M2含む）
- データはすべてローカルストレージ（IndexedDBまたはSQLite）に保存

## アプリ名（仮）
ExpenceAtture

## 主な機能一覧

### 1. ユーザー・関係者管理
- 名前・所属・役割などを登録できるユーザー一覧機能
- 経費や収入の項目に「誰が関わったか」を紐づけられる

### 2. 経費・収入登録
- 経費/収入の区分選択（タブなどで切り替え）
- 日付、金額、摘要、担当者、メモ（備考）を入力
- AI補助によるカテゴリ自動分類（「○○費」などの勘定科目）
- 経費分類候補をChatGPT APIで提示（例：「交通費」「消耗品費」など）
- 請求書やレシートの画像アップロード（ローカル保存）

### 3. タグ/カテゴリ機能
- 勘定科目（例：交際費、交通費など）をタグとして管理
- AIにより入力内容から推定して自動でタグを提案

### 4. 立て替え申請サポート
- 「立て替え」チェックボックスで別ユーザーの支払い扱いに
- 対象ユーザー、支払日、返済状況などを記録
- 備考欄に「どのアカウントで決済したか」なども記載可能

### 5. 分析ページ
- 今月・今期の「収入」「支出」集計と差額の可視化
- 円グラフまたは棒グラフでカテゴリ別支出を表示
- ユーザー別支出ランキングなども可能（オプション）

### 6. 設定画面
- ユーザー管理（追加・削除）
- 初期カテゴリ設定
- ChatGPT APIキーの登録
- テーマ変更（ライト/ダーク）

## UI/UXデザイン
- Material UIベースのモダンなインターフェース
- サイドバーで画面切り替え（「ダッシュボード」「登録」「分析」「設定」）
- モバイル対応は不要（デスクトップのみ想定）

## その他の要望
- 入力が面倒にならないように最低限のステップで記録可能にする
- 請求書などの画像プレビュー機能あり
- テーマカラーは変更可能（プレミアム用途にも対応可能な設計）
- ローカル完結でセキュリティを担保
- エクスポート機能（CSV or PDF形式）

## GPT連携の用途（任意）
- メモ欄や画像から「これは○○費として処理できます」と提案
- 入力された自由記述文からカテゴリを推定・整理
</file>

</files>
